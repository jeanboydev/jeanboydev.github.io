<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 虚拟机内存分配机制]]></title>
    <url>%2F2018%2F07%2F06%2Fjvm-memory%2F</url>
    <content type="text"><![CDATA[Java 虚拟机内存分配机制内存区域划分对于大多数的程序员来说，Java 内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的“堆”对应内存模型的 Java 堆，“栈”是指虚拟机栈，然而 Java 内存模型远比这更复杂，想深入了解 Java 的内存，还是有必要明白整个内存区域分。 了解 Java GC 机制，必须先清楚在 JVM 中内存区域的划分。 在 Java 运行时的数据区里，由 JVM 管理的内存区域分为下图几个模块： 程序计数器（Program Counter Register）程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。 字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。 每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。 如果程序执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（ native，由 C 语言编写完成）方法，则计数器的值为 Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义 OutOfMemoryError 的区域。 虚拟机栈（JVM Stack）一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作数栈、动态链接、方法出口等，当方法被调用时，栈帧在 JVM 栈中入栈，当方法执行完成时，栈帧出栈。 局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。 在局部变量表中，只有 long 和 double 类型会占用 2 个局部变量空间（Slot，对于32位机器，一个 Slot 就是 32 个 bit），其它都是 1 个 Slot。 需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。 虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出 StatckOverFlowError（栈溢出）；不过多数 Java 虚拟机都允许动态扩展虚拟机栈的大小（有少部分是固定长度的），所以线程可以一直申请栈，直到内存不足，此时，会抛出 OutOfMemoryError（内存溢出）。 每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。 本地方法栈（Native Method Statck）本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行 Java 方法的，而本地方法栈是用来执行 native 方法的，在很多虚拟机中（如：Sun 的 JDK 默认的 HotSpot 虚拟机），会将本地方法栈与虚拟机栈放在一起使用。 本地方法栈也是线程私有的。 堆区（Heap）堆区是理解 Java GC 机制最重要的区域，没有之一。 在 JVM 所管理的内存中，堆区是最大的一块，堆区也是 Java GC 机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。 堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。 一般的，根据 Java 虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。 如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出 OutOfMemoryError:Java heap space 异常。 关于堆区的内容还有很多，将在下面“内存分配机制”中详细介绍。 方法区（Method Area）在 Java 虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将 Java GC 的分代收集机制分为 3 个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的 HotSpot Java 虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。 不过，除 HotSpot 之外的多数虚拟机，并不将方法区当做永久代，HotSpot 本身，也计划取消永久代。 本文中，由于主要使用 Oracle JDK6.0，因此仍将使用永久代一词。 方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final 常量、静态变量、编译器即时编译的代码等。 方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。 一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。 在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。 在方法区上定义了 OutOfMemoryError:PermGen space 异常，在内存不足时抛出。 运行时常量池（Runtime Constant Pool） 方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如 String 类的 intern() 方法，作用是 String 维护了一个常量池，如果调用的字符 “abc” 已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。 直接内存（Direct Memory）直接内存并不是 JVM 管理的内存，可以这样理解，直接内存，就是 JVM 以外的机器内存。 比如：你有 4G 的内存，JVM占用了1G，则其余的 3G 就是直接内存，JDK 中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由 C 语言实现的 native 函数库分配在直接内存中，用存储在 JVM 堆中的 DirectByteBuffer 来引用。 由于直接内存受到本机器内存的限制，所以也可能出现 OutOfMemoryError 的异常。 内存分配机制以下面代码为例，来分析，Java 的实例对象在内存中的空间分配。 123456789101112131415161718192021//JVM 启动时将 Person.class 放入方法区public class Person &#123; //new Person 创建实例后，name 引用放入堆区，name 对象放入常量池 private String name; //new Person 创建实例后，age = 0 放入堆区 private int age; //Person 方法放入方法区，方法内代码作为 Code 属性放入方法区 public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; //toString 方法放入方法区，方法内代码作为 Code 属性放入方法区 @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 123456789101112131415//JVM 启动时将 Test.class 放入方法区public class Test &#123; //main 方法放入方法区，方法内代码作为 Code 属性放入方法区 public static void main(String[] args) &#123; //person1 是引用放入虚拟机栈区，new 关键字开辟堆内存 Person 自定义对象放入堆区 Person person1 = new Person("张三", 18); Person person2 = new Person("李四", 20); //通过 person 引用创建 toString() 方法栈帧 person1.toString(); person2.toString(); &#125;&#125; 首先 JVM 会将 Test.class, Person.class 加载到方法区，找到有 main() 方法的类开始执行。 如上图所示，JVM 找到 main() 方法入口，创建 main() 方法的栈帧放入虚拟机栈，开始执行 main() 方法。 1Person person1 = new Person("张三", 18); 执行到这句代码时，JVM 会先创建 Person 实例放入堆区，person2 也同理。 创建完 Person 两个实例，main() 方法中的 person1，person2 会指向堆区中的 0x001，0x002（这里的内存地址仅作为示范）。紧接着会调用 Person 的构造函数进行赋值，如下图： 如上图所示，新创建的的 Person 实例中的 name, age 开始都是默认值。 调用构造函数之后进行赋值，name 是 String 引用类型，会在常量池中创建并将地址赋值给 name，age 是基本数据类型将直接保存数值。 注：Java 中基本类型的包装类的大部分都实现了常量池技术，这些类是 Byte, Short, Integer, Long, Character, Boolean，另外两种浮点数类型的包装类则没有实现。 基本数据类型 包装类 （是否实现了常量池技术） byte Byte 是 boolean Boolean 是 short Short 是 char Character 是 int Integer 是 long Long 是 float Float 否 double Double 否 Person 实例初始化完后，执行到 toString() 方法，同 main() 方法一样 JVM 会创建一个 toString() 的栈帧放入虚拟机栈中，执行完之后返回一个值。 参考资料《深入理解 Java 虚拟机》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Java 虚拟机</category>
      </categories>
      <tags>
        <tag>Java 虚拟机</tag>
        <tag>内存分配机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机垃圾回收机制]]></title>
    <url>%2F2018%2F06%2F16%2Fjvm-gc%2F</url>
    <content type="text"><![CDATA[Java 虚拟机垃圾回收机制概述垃圾回收是一种自动的存储管理机制。 当一些被占用的内存不再需要时，就应该予以释放，以让出空间，这种存储资源管理，称为垃圾回收（Garbage Collection）。 垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。 哪些对象需要回收？自动垃圾回收机制就是寻找Java堆中的对象，并对对象进行分类判别，寻找出正在使用的对象和已经不会使用的对象，然后把那些不会使用的对象从堆上清除。 引用计数法 引用计数算法是垃圾收集器中的早期策略。 在这种方法中，堆中的每个对象实例都有一个引用计数。 当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。 当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。 特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。 任何引用计数为0的对象实例可以被当作垃圾收集。 引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题 可达性分析 可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。 当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。 如何回收 标记-清除算法 标记，也就是垃圾收集器会找出那些需要回收的对象所在的内存和不需要回收的对象所在的内存，并把它们标记出来，简单的说，也就是先找出垃圾在哪儿？ 所有堆中的对象都会被扫描一遍，以此来确定回收的对象，所以这通常会是一个相对比较耗时的过程。 清除，垃圾收集器会清除掉上一步标记出来的那些需要回收的对象区域。 存在的问题就是碎片问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法 标记清除算法每次执行都需要对堆中全部对象扫面一遍效率不高，为解决效率问题，复制算法将内存按容量划分为大小相等的两块，每次只是用其中的一块。 当这一块使用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都对半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 标记-整理算法 由于简单的标记清除可能会存在碎片的问题，所以又出现了压缩清除的方法，也就是先清除需要回收的对象，然后再对内存进行压缩操作，将内存分成可用和不可用两大部分。 内存分代当前商业虚拟机的垃圾收集都采用“分代收集”（Generation Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。 一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率较高、没有额外的空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来回收。 新生代 所有新 new 出来的对象都会最先出现在新生代中，当新生代这部分内存满了之后，就会发起一次垃圾收集事件，这种发生在新生代的垃圾收集称为 Minor collections。 这种收集通常比较快，因为新生代的大部分对象都是需要回收的，那些暂时无法回收的就会被移动到老年代。 全局暂停事件（Stop the World）：所有小收集（minor garbage collections）都是全局暂停事件，也就是意味着所有的应用线程都需要停止，直到垃圾回收的操作全部完成。类似于“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？” 老年代 老年代用来存储那些存活时间较长的对象。 一般来说，我们会给新生代的对象限定一个存活的时间，当达到这个时间还没有被收集的时候就会被移动到老年代中。随着时间的推移，老年代也会被填满，最终导致老年代也要进行垃圾回收。这个事件叫做大收集(major garbage collection)。 大收集也是全局暂停事件。通常大收集比较慢，因为它涉及到所有的存活对象。所以，对于对相应时间要求高的应用，应该将大收集最小化。此外，对于大收集，全局暂停事件的暂停时长会受到用于老年代的垃圾回收器的影响。 永久代 永久代存储了描述应用程序类和方法的元数据，JVM 运行应用程序的时候需要这些元数据。 永久代由 JVM 在运行时基于应用程序所使用的类产生。 此外，Java SE 类库的类和方法可能也存储在这里。 如果 JVM 发现有些类不在被其他类所需要，同时其他类需要更多的空间，这时候这些类可能就会被垃圾回收。 分代垃圾回收过程我们已经知道垃圾回收所需要的方法和堆内存的分代，那么接下来我们就来具体看一下垃圾回收的具体过程。 第一步 所有 new 出来的对象都会最先分配到新生代区域中，两个 survivor 区域初始化是为空的。 第二步，当 eden 区域满了之后，就引发一次小收集（minor garbage collections）。 第三步，当在小收集（minor garbage collections）存活下来的对象就会被移动到 S0 survivor 区域。 第四步，然后当 eden 区域又填满的时候，又会发生下一次的垃圾回收，存活的对象会被移动到 survivor 区域而未存活对象会被直接删除。 但是，不同的是，在这次的垃圾回收中，存活对象和之前的 survivor 中的对象都会被移动到 s1 中。 一旦所有对象都被移动到 s1 中，那么 s2 中的对象就会被清除，仔细观察图中的对象，数字表示经历的垃圾收集的次数。 目前我们已经有不同的年龄对象了。 第五步，下一次垃圾回收的时候，又会重复上次的步骤，清除需要回收的对象，并且又切换一次 survivor 区域，所有存活的对象都被移动至 s0。 eden 和 s1 区域被清除。 第六步，重复以上步骤，并记录对象的年龄，当有对象的年龄到达一定的阈值的时候，就将新生代中的对象移动到老年代中。在本例中，这个阈值为8。 第七步，接下来垃圾收集器就会重复以上步骤，不断的进行对象的清除和年代的移动。 最后，我们观察上述过程可以发现，大部分的垃圾收集过程都是在新生代进行的，直到老年代中的内存不够用了才会发起一次 大收集(major garbage collection)，会进行标记和整理压缩。 垃圾回收器的类型Java 提供多种类型的垃圾回收器。 JVM 中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。 Serial 收集器：新生代收集器，使用复制算法，使用一个线程进行 GC，串行，其它工作线程暂停。 ParNew 收集器：新生代收集器，使用复制算法，Serial 收集器的多线程版，用多个线程进行 GC，并行，其它工作线程暂停。 使用 -XX:+UseParNewGC 开关来控制使用 ParNew+Serial Old 收集器组合收集内存；使用 -XX:ParallelGCThreads 来设置执行内存回收的线程数。 Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注 CPU 吞吐量，即运行用户代码的时间/总时间。 使用 -XX:+UseParallelGC 开关控制使用 Parallel Scavenge+Serial Old 收集器组合回收垃圾。 Serial Old 收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。 Parallel Old 收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与 Parallel Scavenge 差不错，使用标记整理算法，在 Parallel Old 执行时，仍然需要暂停其它线程。 CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。 使用 -XX:+UseConcMarkSweepGC 进行 ParNew+CMS+Serial Old 进行内存回收，优先使用 ParNew+CMS，当用户线程内存不足时，采用备用方案 Serial Old 收集。 参考资料《深入理解 Java 虚拟机》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Java 虚拟机</category>
      </categories>
      <tags>
        <tag>Java 虚拟机</tag>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章看明白 HTTP，HTTPS，SSL/TSL 之间的关系]]></title>
    <url>%2F2018%2F05%2F22%2Finternet-http-https%2F</url>
    <content type="text"><![CDATA[HTTP，HTTPS，SSL/TSL概述什么是 HTTP ？超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。【摘自百度百科】 伴随着计算机网络和浏览器的诞生，HTTP1.0 也随之而来，处于计算机网络中的应用层，HTTP 是建立在 TCP 协议之上，所以 HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性。 早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从 Web 服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的 HTML 页面将要放在我们的 web 服务器上，用户端通过浏览器访问 url 地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。 设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。简单来说，HTTP 是一个网络协议，专门用来帮你传输 Web 内容的。 HTTP 和 TCP 之间的关系 简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。 HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接(Keep-Alive)”又称“持久连接(Persistent Connection)”）。 假设有一个网页，里面包含好多图片，还包含好多【外部的】 CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开） 相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。 在 HTTP 1.0 版本，【默认】使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）；到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”的）。所以，在 HTTP 1.1 中，【默认】采用的是“Keep-Alive”的方式。 URI 和 URL 之间的关系 URI （Uniform Resource Identifier，统一资源标识符）。 URI 属于 URL 更高层次的抽象，一种字符串文本标准。就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。二者的区别在于，URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（http://）。 12345678ftp://ftp.is.co.za/rfc/rfc1808.txt (URL)http://www.ietf.org/rfc/rfc2396.txt (URL)ldap://[2001:db8::7]/c=GB?objectClass?one (URL)mailto:John.Doe@example.com (URL)news:comp.infosystems.www.servers.unix (URL)tel:+1-816-555-1212telnet://192.0.2.16:80/ (URL)urn:oasis:names:specification:docbook:dtd:xml:4.1.2 IANA - Uniform Resource Identifier (URI) SCHEMES（统一资源标识符方案） 具体详见：http://baike.baidu.com/item/URI URL（Uniform Resource Locator，统一资源定位符） 通常而言，我们所熟悉的 URL 的常见定义格式为： 1scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor] scheme //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。 host //HTTP服务器的IP地址或者域名 port# //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/ path //访问资源的路径 url-params //所带参数 query-string //发送给http服务器的数据 anchor //锚点定位 具体详见：http://baike.baidu.com/item/URL HTTP 的缺点 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 HTTPS 的诞生为了解决 HTTP 协议的以上缺点，在上世纪90年代中期，由网景（NetScape）公司设计了 SSL 协议。SSL 是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）。 到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。 很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。 互联网加密协议历史： 1994年，NetScape 公司设计了 SSL 协议的1.0版，但是未发布。 1995年，NetScape 公司发布 SSL 2.0版，很快发现有严重漏洞。 1996年，SSL 3.0 版问世，得到大规模应用。 1999年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。 2006年和2008年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版。最新的变动是2011年 TLS 1.2 的修订版。 目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。 所谓的 HTTPS 其实是“HTTP over SSL”或“HTTP over TLS”，它是 HTTP 与 SSL/TSL 的结合使用而已。 “对称加密”与“非对称加密” 明文传输消息 “加密”和“解密” 通俗而言，你可以把“加密”和“解密”理解为某种【互逆的】数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。“加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东西——叫做“密钥”——来参与数学运算。 “对称加密” 所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。 存在疑问：密钥怎么传输？如果密钥可以安全的传输，那么消息也应该可以安全的传输，就像蛋生鸡，鸡生蛋一样。 “非对称加密” 所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用【不同的】密钥。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。 被劫持情况： 窃听者可以伪造服务器的公钥与客户端通讯，客户端以为是跟服务器通讯，其实是与窃听者在通讯，后果可想而知。 CA 证书CA 是 PKI 系统中通信双方信任的实体，被称为可信第三方（Trusted Third Party，简称TTP）。 CA 证书，顾名思义，就是 CA 颁发的证书。 CA 的初始是为了解决上面非对称加密被劫持的情况，服务器申请 CA 证书时将服务器的“公钥”提供给 CA，CA 使用自己的“私钥”将“服务器的公钥”加密后（即：CA证书）返回给服务器，服务器再将“CA 证书”提供给客户端。一般系统或者浏览器会内置 CA 的根证书（公钥）， HTTPS 中 CA 证书的获取 注：上图步骤 2 之后，客户端获取到“CA 证书”会进行本地验证，即使用本地系统或者浏览器中的公钥进行解密，每个“CA 证书”都会有一个证书编号可用于解密后进行比对（具体验证算法请查阅相关资料）。 步骤 5 之前使用的是对称加密，之后将使用对称加密来提高通讯效率。 SPDY2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，缩短 Web 页面的加载时间（50%）。 SPDY- The Chromium Projects SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 具体详见：http://baike.baidu.com/item/SPDY HTTP2.0顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE。 具体详见：http://baike.baidu.com/item/HTTP%202.0 参考资料《图解HTTP》、《图解TCP/IP》、百度百科 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
        <tag>TSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章看明白 TCP/IP，TCP，UDP，IP，Socket 之间的关系]]></title>
    <url>%2F2018%2F05%2F05%2Finternet-tcp-ip%2F</url>
    <content type="text"><![CDATA[TCP/IP，TCP，UDP，IP，Socket概述 什么是 TCP/IP？ TCP，UDP 有什么区别？ 什么是 Socket？ 网上这方面的资料有很多，但都很琐碎，没有系统化，要么看完很快就忘记了，要么就是看完迷迷糊糊似懂非懂，下面我们来一一攻破以上问题。 什么是 TCP/IP ？计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。 个人认为，因为 TCP/IP 族内的协议有很多，为了突出 TCP 与 IP 这两个协议的重要性，所以就用 TCP/IP 来表示 TCP/IP 协议族了。 网络参考模型 OSI 参考模型 OSI 参考模型是 ISO 的建议，它是为了使各层上的协议国际标准化而发展起来的。OSI 参考模型全称是开放系统互连参考模型(Open System Interconnection Reference Model)。这一参考模型共分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 TCP/IP 参考模型 TCP/IP 参考模型是首先由 ARPANET 所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为 TCP/IP 参考模型(TCP/IP Reference Model)。这一网络协议共分为四层：数据链路层、网络层、传输层和应用层。 TCP/IP 的分层管理TCP/IP 协议族里重要的一点就是分层。把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。 值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。 OSI中的层 功能 TCP/IP协议族 7 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等 6 表示层 数据格式化，代码转换，数据加密 没有协议 5 会话层 解除或建立与别的接点的联系 没有协议 4 传输层 提供端对端的接口 TCP，UDP 3 网络层 为数据包选择路由 IP，ICMP，OSPF，EIGRP，IGMP 2 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，MTU 1 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 数据链路层 数据链路层是负责接收 IP 数据包并通过网络发送，或者从网络上接收物理帧，抽出 IP 数据包，交给 IP 层。 ARP 是正向地址解析协议，通过已知的 IP，寻找对应主机的 MAC 地址。 RARP 是反向地址解析协议，通过 MAC 地址确定 IP 地址。比如无盘工作站还有 DHCP 服务。 常见的接口层协议有：Ethernet 802.3、Token Ring 802.5、X.25、Frame relay、HDLC、PPP ATM等。 网络层 负责相邻计算机之间的通信。其功能包括三方面。 处理来自传输层的分组发送请求，收到请求后，将分组装入 IP 数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。 处理输入数据报：首先检查其合法性，然后进行寻径–假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。 处理路径、流控、拥塞等问题。 网络层包括：IP(Internet Protocol) 协议、ICMP(Internet Control Message Protocol) 控制报文协议、ARP(Address Resolution Protocol) 地址转换协议、RARP(Reverse ARP) 反向地址转换协议。 IP 是网络层的核心，通过路由选择将下一条IP封装后交给接口层。IP数据报是无连接服务。 ICMP 是网络层的补充，可以回送报文。用来检测网络是否通畅。 Ping 命令就是发送 ICMP 的 echo 包，通过回送的 echo relay 进行网络测试。 传输层 提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送，即耳熟能详的“三次握手”过程，从而提供可靠的数据传输。 传输层协议主要是：传输控制协议 TCP(Transmission Control Protocol) 和用户数据报协议 UDP(User Datagram protocol)。 应用层 向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录 TELNET 使用 TELNET 协议提供在网络其它主机上注册的接口。TELNET 会话提供了基于字符的虚拟终端。文件传输访问 FTP 使用 FTP 协议来提供网络内机器间的文件拷贝功能。 应用层协议主要包括如下几个：FTP、TELNET、DNS、SMTP、NFS、HTTP。 FTP(File Transfer Protocol）是文件传输协议，一般上传下载用FTP服务，数据端口是 20H，控制端口是 21H。 Telnet 服务是用户远程登录服务，使用 23H 端口，使用明码传送，保密性差、简单方便。 DNS(Domain Name Service）是域名解析服务，提供域名到 IP 地址之间的转换，使用端口 53。 SMTP(Simple Mail Transfer Protocol）是简单邮件传输协议，用来控制信件的发送、中转，使用端口 25。 NFS（Network File System）是网络文件系统，用于网络中不同主机间的文件共享。 HTTP(Hypertext Transfer Protocol）是超文本传输协议，用于实现互联网中的 WWW 服务，使用端口 80。 什么是 TCP ？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 连接建立 TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答 SYN + ACK ，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP 使用的流量控制协议是可变大小的滑动窗口协议。 TCP三次握手的过程如下： 客户端发送 SYN（SEQ=x）报文给服务器端，进入 SYN_SEND 状态。 服务器端收到 SYN 报文，回应一个 SYN （SEQ=y）ACK(ACK=x+1）报文，进入 SYN_RECV 状态。 客户端收到服务器端的 SYN 报文，回应一个 ACK(ACK=y+1）报文，进入 Established 状态。 三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。 连接终止 建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。具体过程如下图所示。 某个应用进程首先调用 close，称该端执行“主动关闭”（active close）。该端的 TCP 于是发送一个 FIN 分节，表示数据发送完毕。 接收到这个 FIN 的对端执行 “被动关闭”（passive close），这个 FIN 由 TCP 确认。 注意：FIN 的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN 的接收意味着接收端应用进程在相应连接上再无额外数据可接收。 一段时间后，接收到这个文件结束符的应用进程将调用 close 关闭它的套接字。这导致它的 TCP 也发送一个 FIN。 接收这个最终FIN的原发送端 TCP（即执行主动关闭的那一端）确认这个 FIN。既然每个方向都需要一个 FIN 和一个 ACK，因此通常需要4个分节。 无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。 什么是 UDP ？UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是17。 UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。 UDP 是不具有可靠性的数据报协议。细微的处理他会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，确不能保证消息一定会到达。因此应用有时会根据自己的需要进行重发处理。 TCP 与 UDP 的区别TCP 用于在传输层有必要实现可靠传输的情况。由于它是面向有链接并具备顺序控制、重发控制等机制的，所以他可以为应用提供可靠的传输。 而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。 我们举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失会被重发，但这样无法流畅的传输通话人的声音，会导致无法进行正常交流。而采用 UDP，他不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也支持会影响某一小部分的通话。此外，在多播与广播通信中也是用 UDP 而不是 TCP。 什么是 IP ？网络之间互连的协议（IP）是 Internet Protocol 的外语缩写，IP 是在 TCP/IP 协议中网络层的主要协议，任务是仅仅根据源主机和目的主机的地址传送数据。为此目的，IP 定义了寻址方法和数据报的封装结构。第一个架构的主要版本，现在称为 IPv4，仍然是最主要的互联网协议，尽管世界各地正在积极部署 IPv6。 IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。 IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。 什么是 Socket ？应用在使用 TCP 或 UDP 时，会用到操作系统提供的类库。这种类库一般被称为 API（Application Programming Interface，应用编程接口）。 使用 TCP 或 UDP 通讯时，优惠广泛使用到套接字（Socket）的 API。套接字原本是由 BSD UNIX 开发的，但是后被移植到了 Windows 的 Winsock 以及嵌入式操作系统中。 应用程序利用套接字，可以设置对端的 IP 地址，端口号，并实现数据的发送与接收。 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 Socket。 建立网络通信连接至少要一对端口号(Socket)。Socket 本质是编程接口(API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口；HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。 TCP/IP 通讯示例 在 TCP/IP 通讯过程中，每个分层，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送端的目标地址一节协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层角度看，从上一层收到的包全部被认为是本层的数据。 假设甲给乙发送邮件，内容为：“早上好”。而从 TCP/IP 通信上看，是从一台计算机 A 向另一台计算机 B 发送邮件。我们通过这个例子来讲解一下 TCP/IP 通信的过程。 数据包的发送处理 应用程序处理 启动应用程序新建邮件，将收件人邮箱填好，再由键盘输入“早上好”，鼠标点击“发送”按钮就可以开始 TCP/IP 的通信了。 首先，应用程序会对邮件内容进行编码处理，例如：UTF-8，GB2312 等。这些编码相当于 OSI 的表示层功能。应用在发送邮件的那一刻建立 TCP 连接，从而利用这个 TCP 连接发送数据。它的过程首先是将应用的数据发送给下一层的 TCP，在做实际的转发处理。 TCP 模块处理 TCP根据应用的提示，负责建立连接，发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。 为了实现 TCP 的这一功能，需要在应用层数据的前端附加一个 TCP 的首部。TCP 的首部中包括源端口号和目标端口号、序号。随后将附加了 TCP 首部的包再发送给 IP。 IP 模块处理 IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 首部中包含接收端 IP 地址，发送端 IP 地址。随后 IP 包将被发送给连接这些路由器或主机网络接口的驱动程序，以实现真正的发送数据。 网络接口（以太网驱动）的处理 从 IP 传过来的 IP 包，对于以太网卡来说就是数据。给这些数据附加上以太网首部并进行发送处理。以太网首部中包含接收端 MAC 地址，发送端 MAC 地址，以太网类型，以太网数据协议。根据上述信息产生的以太网数据将被通过物理层传输给接收端。 数据包的接收处理 网络接口（以太网驱动）的处理 主机收到以太网包以后，首先从以太网的包首部找到 MAC 地址判断是否为发给自己的包。如果不是发给自己的则丢弃数据，如果是发给自己的则将数据传给处理 IP 的子程序。 IP 模块处理 IP 模块收到 IP 包首部以及后面的数据部分以后，也做类似的处理。如果判断得出包首部的 IP 地址与自己的 IP 地址匹配，则可接受数据并从中查找上一层的协议。并将后面的数据传给 TCP 或者 UDP 处理。对于有路由的情况下，接收端的地址往往不是自己的地址，此时需要借助路由控制表，从中找出应该送到的主机或者路由器以后再进行转发数据。 TCP 模块处理 在 TCP 模块中，首先会校验数据是否被破坏，然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据接收完毕后，接收端则发送一个“确认绘制”给发送端。数据被完整地接收以后，会传给由端口号识别的应用程序。 应用程序处理 接收端应用程序会直接接收发送端发送的数据。通过解析数据可以获知邮件的内容信息。 参考资料《图解HTTP》、《图解TCP/IP》、百度百科 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>TCP/IP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>IP</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章看明白 Android Service 启动过程]]></title>
    <url>%2F2018%2F04%2F21%2Fandroid-service-start%2F</url>
    <content type="text"><![CDATA[Android - Service 启动过程概述Service 启动过程与 Activity 启动过程比较相似，不了解 Activity 启动过程的可以先看一下：Activity 启动过程。 Service 的启动分两种情况：startService，bindService。 startService通常情况我们在调用 startService 启动 Service 是运行在 App 进程中的。下面主要讨论下运行在单独进程中的情况。 在 AndroidManifest 文件中把 Service 配置 android:process 上属性，Service 就可以启动在单独进程中了。 首先要明白一个问题，在 Activity 中使用的 startService 方法是定义在 Context 的抽象类中，它的真正实现者是 ContextImpl，所以我们首先进入 ContextImpl 类。 ContextImpl.startService() 12345678910111213141516171819@Overridepublic ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, mUser); &#125;private ComponentName startServiceCommon(Intent service, UserHandle user) &#123; try &#123; validateServiceIntent(service); service.prepareToLeaveProcess(); ComponentName cn = ActivityManagerNative.getDefault(). startService(mMainThread.getApplicationThread(), service,service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier()); //...... return cn; &#125; catch (RemoteException e) &#123; return null; &#125;&#125; 从 ContextImpl 类的 startService 开始，然后进入本类的 startServiceCommon 方法，并最终调用 ActivityManagerNative.getDefault() 对象的 startService 方法。其实这里的 ActivityManagerNative.getDefault() 就是 ActivityManagerProxy 对象。这里涉及到 Binder 相关知识，不了解的请看：Binder 机制。 ActivityManagerProxy.startService() 12345678910111213141516public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); service.writeToParcel(data, 0); data.writeString(resolvedType); data.writeInt(userId); mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); ComponentName res = ComponentName.readFromParcel(reply); data.recycle(); reply.recycle(); return res;&#125; 通过 Binder 调用 ActivityManagerNative 类中 onTransact 方法，其识别码为 START_SERVICE_TRANSACTION，并最终调用 ActivityManagerNative 的实现类 ActivityManagerService 的 startService 方法。 ActivityManagerService.startService() 123456789101112131415@Overridepublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; enforceNotIsolatedCaller("startService"); //...... synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 在这里调用 mServices 对象的 startServiceLocked 方法，这里的 mServices 对象是 ActiveServices 类。 ActiveServices.startServiceLocked() 123456789101112131415161718192021222324ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, int userId) &#123; //...... ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPid, callingUid, userId, true, callerFg); ServiceRecord r = res.record; //...... //这里紧接着会调用 startServiceInnerLocked 方法 return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);&#125;ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) &#123; //...... synchronized (r.stats.getBatteryStats()) &#123; r.stats.startRunningLocked(); &#125; //这里紧接着会调用 bringUpServiceLocked 方法 String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); //......&#125; 首先通过 retrieveServiceLocked 方法来解析 service 这个 Intent，就是解析前面我们在 AndroidManifest.xml 定义的 Service 标签的 intent-filter 相关内容，然后将解析结果放在 res.record 中，再调用 startServiceInnerLocked 方法。startServiceInnerLocked 方法中会调用 bringUpServiceLocked 方法。 ActiveServices.bringUpServiceLocked() 12345678910111213141516171819202122232425262728293031323334353637private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) &#123; //（1）这里如果当前的 ProcessRecord 不为 null，那就不需要重新创建进程， //而是调用 realStartServiceLocked 方法来启动 Service if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); realStartServiceLocked(r, app, execInFg); return null; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting service " + r.shortName, e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; //（2）如果是需要创建新进程，那么将调用 ActivityManagerService.startProcessLocked 方法来启动新进程 if (app == null) &#123; if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, "service", r.name, false, isolated, false)) == null) &#123; //...... bringDownServiceLocked(r); return msg; &#125; if (isolated) &#123; r.isolatedProc = app; &#125; &#125; //最后将 ServiceRecord 保存到成员变量 mPendingServices 中 if (!mPendingServices.contains(r)) &#123; mPendingServices.add(r); &#125;&#125; 这个方法比较重要，这里有两种选择，当 Service 所在的进程存在时，将调用realStartServiceLocked 方法来启动 Service，否则的话调用 startProcessLocked 方法来启动新进程。 ActivityManagerService.startProcessLocked() 12345678910111213private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = "android.app.ActivityThread"; checkTime(startTime, "startProcess: asking zygote to start proc"); //通过 processName，uid 等启动新进程 Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);&#125; 这里通过 Process 的 start 方法启动 ActivityThread 的新进程，我们进入该类的 main 方法。 ActivityThread.main() 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; //...... Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); //创建 ActivityThread 对象，并调用其 attach 方法 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125;private void attach(boolean system) &#123; final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; //这里调用了 ActivityManagerProxy.attachApplication 方法。 mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125;&#125; 在 Android 应用程序中，每一个进程对应一个 ActivityThread 实例，然后这里创建了 ActivityThread 对象并调用了其 attach 方法，在 attach 方法中又调用了 ActivityManagerProxy.attachApplication 方法。 ActivityManagerProxy.attachApplication() 12345678910public void attachApplication(IApplicationThread app) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 通过 Binder 机制会调用 ActivityManagerNative 中的 onTransact 方法，其识别码为 ATTACH_APPLICATION_TRANSACTION，并最终调用 ActivityManagerService 中的 attachApplication 方法。 ActivityManagerService.attachApplication() 123456789101112131415161718192021222324252627282930313233343536373839@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); //调用 attachApplicationLocked attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); //...... &#125;&#125;private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; // See if the top visible activity is waiting to run in this process... if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.wtf(TAG, "Exception thrown launching activities in " + app, e); badApp = true; &#125; &#125; // Find any services that should be running in this process... if (!badApp) &#123; try &#123; //这里会调用 ActiveServices 对象的 attachApplicationLocked 方法 didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; Slog.wtf(TAG, "Exception thrown starting services in " + app, e); badApp = true; &#125; &#125;&#125; 这里如果是启动 Service 将调用 ActiveServices 对象的 attachApplicationLocked 方法，而如果是启动 Activity 将调用 ActivityStackSupervisor 对象的 attachApplicationLocked 方法。 ActiveServices.attachApplicationLocked() -&gt; realStartServiceLocked() 12345678910111213private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; //...... app.thread.scheduleCreateService(r, r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState);&#125; 此处的 app.thread 是一个 IApplicationThread 对象，而 IApplicationThread 的代理类是 ApplicationThreadProxy，我们进入 app.thread 对象的 scheduleCreateService 方法。 ApplicationThreadProxy.scheduleCreateService() 12345678910111213public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); info.writeToParcel(data, 0); compatInfo.writeToParcel(data, 0); data.writeInt(processState); mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 通过 Binder 对象调用 ApplicationThreadNative 的 onTransact 方法，在其方法中调用子类的 scheduleCreateService 方法，即最终调用 ApplicationThreadNative 的子类 ApplicationThread 的 scheduleCreateService 方法。 ApplicationThread.scheduleCreateService() 1234567891011public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125; 通过 Handler 发送 Message 来处理该操作，并进入到 H 的 handleMessage 方法中，其识别码为 CREATE_SERVICE。 H.handleMessage() 123456789private class H extends Handler &#123; public void handleMessage(Message msg) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceCreate"); //这里调用 handleCreateService 方法 handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125; ApplicationThread.handleCreateService() 12345678910111213141516171819202122private void handleCreateService(CreateServiceData data) &#123; Service service = null; try &#123; //（1）通过类加载器来加载 Service 对象 java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; //...... &#125; //（2）这里创建 ContextImpl 对象 ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); //（3）这里调用 Service 的 onCreate 方法 service.onCreate(); mServices.put(data.token, service);&#125; 处通过类加载器 ClassLoader 来加载 Service 对象，此处的 data.info.name 就是我们要启动的 Service，加载完成后需要将其强转换为 Service 对象，也就是说我们的 Service 必须要继承于 Service 基类。 处这里先创建一个 ContextImpl 对象，每个 Activity 和 Service 都有一个 Context 对象。 处这里调用 Service 的 onCreate 方法。 bindService 如何 bind 一个 Service？ 123456789101112131415161718192021private void test()&#123; Intent intent = new Intent(this, XXXService.class); // bindService 的具体实现在 ContextImpl // BIND_AUTO_CREATE 参数具体使用的代码 ActivityServices bindService(intent, conn, BIND_AUTO_CREATE);&#125;private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 绑定成功 ... &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; // 绑定结束 ... &#125;&#125; ContextImpl.bindServce() 12345678910111213141516171819202122232425262728293031@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; // mMainThread.getHandler()，传入的 handle 是主线程的 Handle return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; IServiceConnection sd; //... if (mPackageInfo != null) &#123; // 1，将传入的 ServiceConnection 转化为 IServiceConnection 返回 // mPackgeInfo 是 LoadedApk sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); &#125; validateServiceIntent(service); try &#123; IBinder token = getActivityToken(); ... // 2，Binder 调用 AMS 的 bindService 方法，下面具体分析 int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); return res != 0; &#125; //...&#125; LoadedApk LoadedApk 对象是 Apk 文件在内存中的表示。 Apk 文件的相关信息，诸如 Apk 文件的代码和资源，甚至代码里面的 Activity，Service 等组件的信息我们都可以通过此对象获取。 123456789101112131415161718192021222324252627282930313233343536public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; synchronized (mServices) &#123; LoadedApk.ServiceDispatcher sd = null; // private final ArrayMap&lt;Context, // ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices // 根据当前的 Context 获取 ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); if (map != null) &#123; // 如果存在，尝试根据当前的 ServiceConnection 获取 ServiceDispatcher sd = map.get(c); &#125; if (sd == null) &#123; // 如果与 ServiceConnection 对应的 ServiceDispatcher 不存在，创建一个保存了当前 // ServiceConnection 的 ServiceDispatcher 对象， // 并将之前传入的主线的 Handle 保存，同时创建一个 InnerConnection 对象保存 sd = new ServiceDispatcher(c, context, handler, flags); if (map == null) &#123; map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;(); mServices.put(context, map); &#125; // 将该 ServiceConnection 与 ServiceDispatcher 关系保存 map.put(c, sd); &#125; else &#123; // 如果最开始就获取到 ServiceDispatcher，比如多次 bindService， // 就会调用 ServiceDispatcher 的 validate 判断此次 bindService 是否合法 // validate 的判断逻辑比较简单： // 1.判断当前的 context 是否和之前 bindService 的一样 // 2.判断当前 handler 是否是主线程的 handle // 以上两个条件都满足的情况下正常执行，反之抛出相应的异常 sd.validate(context, handler); &#125; return sd.getIServiceConnection(); &#125;&#125; ActivityManagerService.bindService() 1234567891011public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; //... synchronized(this) &#123; // 调用 ActiveServices 的 bindServiceLocked 方法 return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId); &#125;&#125; ActiveServices.bindServiceLocked() -&gt; bringUpServiceLocked() -&gt; realStartServiceLocked() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; //... try &#123; //... // 第一步，调用 ApplicationThread 的 scheduleCreateService 方法， // 之后会实例化 Service 并调用 Service 的 onCreate 方法，这里的过程跟上面 startService 中一样。 // 不会调用 onStartCommand app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); &#125; //... // 第二步，调用 requestServiceBindingLocked requestServiceBindingLocked(r, execInFg); updateServiceClientActivitiesLocked(app, null, true); // 第三步 // If the service is in the started state, and there are no // pending arguments, then fake up one so its onStartCommand() will // be called. if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), null, null)); &#125; // StartItem 的 taskRemoved 如果是 false 的话， // 调用下面方法会调用 Service 的 onStartCommand sendServiceArgsLocked(r, execInFg, true); //...&#125;private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123; //... if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; try &#123; //... // 调用 ApplicationThread 的 scheduleBindService 方法 r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); &#125; //... &#125; //... return true;&#125; ApplicationThread.scheduleBindService() 1234567891011121314151617181920212223private void handleBindService(BindServiceData data) &#123; // 根据 token 获取 Service token 具体分析 Service s = mServices.get(data.token); if (s != null) &#123; try &#123; // rebind 具体分析 if (!data.rebind) &#123; // 调用 Service 的 onBind，返回给客户端调用的 Binder IBinder binder = s.onBind(data.intent); // 调用 AMS 的 publishService，进而通知客户端连接成功 ActivityManagerNative.getDefault() .publishService(data.token, data.intent, binder); &#125; else &#123; s.onRebind(data.intent); ActivityManagerNative.getDefault() .serviceDoneExecuting(data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; ... &#125;&#125; 调用 ApplicationThread 的 scheduleBindService，scheduleBindService 通过 mH 发送一个 H.BIND_SERVICE 消息，mH 收到该消息调用 handleBindService(BindServiceData data)。 总结 startService 使用这种 start 方式启动的 Service 的生命周期如下：onCreate() -&gt; onStartCommand()（onStart()方法已过时） -&gt; onDestory() 说明：如果服务已经开启，不会重复的执行 onCreate()， 而是会调用 onStart() 和onStartCommand()。服务停止的时候调用 onDestory()。服务只会被停止一次。 特点：一旦服务开启跟调用者(开启者)就没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面的方法。 bindService 使用这种 start 方式启动的 Service 的生命周期如下：onCreate() -&gt; onBind() -&gt; onUnbind() -&gt; onDestory() 注意：绑定服务不会调用 onStart() 或者 onStartCommand() 方法 特点：bind 的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。 参考资料 startService 启动过程分析 《深入理解 Android 内核设计思想》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>启动过程</tag>
        <tag>源码分析</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系]]></title>
    <url>%2F2018%2F03%2F08%2Fandroid-surface-surfaceflinger%2F</url>
    <content type="text"><![CDATA[Android - SurfaceFlinger 图形系统概述 Android 系统启动过程 Activity 创建过程 Activity 与 Window 与 View 之间的关系 通过前面的知识我们知道了，Android 系统从按下开机键到桌面，从桌面点击 App 图标到 Activity 显示的过程。但是 Activity 是怎么显示在屏幕上的呢？下面我们就来讨论下这一过程。 SurfaceFlinger 启动过程SurfaceFlinger 启动过程： SurfaceFlinger 进程是由 init 进程创建的，运行在独立的 SurfaceFlinger 进程中。init 进程读取 init.rc 文件启动 SurfaceFlinger。 123456service surfaceflinger /system/bin/surfaceflinger class core user system group graphics drmrpc onrestart restart zygote writepid /dev/cpuset/system-background/tasks SurfaceFlinger 的创建会执行 main() 方法：main_surfaceflinger.cpp123456789101112131415161718192021222324int main(int, char**) &#123; ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4); sp&lt;ProcessState&gt; ps(ProcessState::self()); ps-&gt;startThreadPool(); //实例化 surfaceflinger sp&lt;SurfaceFlinger&gt; flinger = new SurfaceFlinger(); setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY); set_sched_policy(0, SP_FOREGROUND); //初始化 flinger-&gt;init(); //发布 surface flinger，注册到 ServiceManager sp&lt;IServiceManager&gt; sm(defaultServiceManager()); sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false); // 运行在当前线程 flinger-&gt;run(); return 0;&#125; SurfaceFlinger 的实例化会执行到：onFirstRef()123void SurfaceFlinger::onFirstRef() &#123; mEventQueue.init(this);&#125; onFirstRef() 中会创建 Handler 并初始化。MessageQueue.cpp：12345void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123; mFlinger = flinger; mLooper = new Looper(true); mHandler = new Handler(*this);&#125; 然后会执行到 SurfaceFlinger::init()：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void SurfaceFlinger::init() &#123; Mutex::Autolock _l(mStateLock); //初始化 EGL，作为默认的显示 mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); eglInitialize(mEGLDisplay, NULL, NULL); // 初始化硬件 composer 对象 mHwc = new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this)); //获取 RenderEngine 引擎 mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID()); //检索创建的 EGL 上下文 mEGLContext = mRenderEngine-&gt;getEGLContext(); //初始化非虚拟显示屏 for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123; DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i); //建立已连接的显示设备 if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123; bool isSecure = true; createBuiltinDisplayLocked(type); wp&lt;IBinder&gt; token = mBuiltinDisplays[i]; sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferConsumer&gt; consumer; //创建 BufferQueue 的生产者和消费者 BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, new GraphicBufferAlloc()); sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i, consumer); int32_t hwcId = allocateHwcDisplayId(type); //创建显示设备 sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token, fbs, producer, mRenderEngine-&gt;getEGLConfig()); if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123; hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL); &#125; mDisplays.add(token, hw); &#125; &#125; getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext); //当应用和 sf 的 vsync 偏移量一致时，则只创建一个 EventThread 线程 if (vsyncPhaseOffsetNs != sfVsyncPhaseOffsetNs) &#123; sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true, "app"); mEventThread = new EventThread(vsyncSrc); sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, true, "sf"); mSFEventThread = new EventThread(sfVsyncSrc); mEventQueue.setEventThread(mSFEventThread); &#125; else &#123; //创建 DispSyncSource 对象 sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true, "sf-app"); //创建线程 EventThread mEventThread = new EventThread(vsyncSrc); //设置 EventThread mEventQueue.setEventThread(mEventThread); &#125; //创建 EventControl mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run("EventControl", PRIORITY_URGENT_DISPLAY); //当不存在 HWComposer 时，则设置软件 vsync if (mHwc-&gt;initCheck() != NO_ERROR) &#123; mPrimaryDispSync.setPeriod(16666667); &#125; //初始化绘图状态 mDrawingState = mCurrentState; //初始化显示设备 initializeDisplays(); //启动开机动画 startBootAnim();&#125; 该方法主要功能是： 初始化 EGL 创建 HWComposer 初始化非虚拟显示屏 启动 EventThread 线程 启动开机动画 创建 HWComposer： 12345678910111213141516171819202122232425262728293031323334353637HWComposer::HWComposer(const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler):mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false) &#123; ... bool needVSyncThread = true; int fberr = loadFbHalModule(); //加载 framebuffer 的 HAL 层模块 loadHwcModule(); //加载 HWComposer 模块 //标记已分配的 display ID for (size_t i=0 ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123; mAllocatedDisplayIDs.markBit(i); &#125; if (mHwc) &#123; if (mHwc-&gt;registerProcs) &#123; mCBContext-&gt;hwc = this; mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; //VSYNC 信号的回调方法 mCBContext-&gt;procs.vsync = &amp;hook_vsync; if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) mCBContext-&gt;procs.hotplug = &amp;hook_hotplug; else mCBContext-&gt;procs.hotplug = NULL; memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero)); //注册回调函数 mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs); &#125; //进入此处，说明已成功打开硬件 composer 设备，则不再需要 vsync 线程 needVSyncThread = false; eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0); ... &#125; ... if (needVSyncThread) &#123; //不支持硬件的 VSYNC，则会创建线程来模拟定时 VSYNC 信号 mVSyncThread = new VSyncThread(*this); &#125;&#125; HWComposer 代表着硬件显示设备，注册了 VSYNC 信号的回调。VSYNC 信号本身是由显示驱动产生的，在不支持硬件的 VSYNC，则会创建“VSyncThread”线程来模拟定时 VSYNC 信号。 当硬件产生VSYNC信号时，则会发送消息，handler 收到消息进行处理。当 SurfaceFlinger 进程收到 VSync 信号后经层层调用，最终调用到该对象的 handleMessageRefresh() 方法。 SurfaceFlinger.cpp：123456789void SurfaceFlinger::handleMessageRefresh() &#123; ATRACE_CALL(); preComposition();//处理显示设备与 layers 的改变，更新光标 rebuildLayerStacks();//重建所有可见 Layer 列表，根据Z轴排序 setUpHWComposer();//更新 HWComposer 图层 doDebugFlashRegions(); doComposition();//生成 OpenGL 纹理图像 postComposition();//将图像传递到物理屏幕&#125; Surface 创建过程Surface 创建过程： Surface 创建的过程就是 Activity 显示的过程，在 ActivityThread.handleResumeActivity() 中调用了 Activity.makeVisible()，我们接着看下 Activity 是怎么显示出来的。 Activity.makeVisible：12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager();//此处 getWindowManager 获取的是 WindowManagerImpl 对象 wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; WindowManagerImpl.java：1234public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow);&#125; WindowManagerGlobal.java：12345678910111213public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; //创建 ViewRootImpl ViewRootImpl root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); //设置 View root.setView(view, wparams, panelParentView); ...&#125; 创建 ViewRootImpl：12345678910111213141516public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123; ... final Surface mSurface = new Surface(); //创建 Surface，此时 Surface 创建完什么都没有，详见下面分析 ... public ViewRootImpl(Context context, Display display) &#123; mContext = context; //获取 IWindowSession 的代理类 mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mThread = Thread.currentThread(); //主线程 mWindow = new W(this); mChoreographer = Choreographer.getInstance(); ... &#125;&#125; WindowManagerGlobal.java：12345678910111213141516171819public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; //获取 IMS 的代理类 InputMethodManager imm = InputMethodManager.getInstance(); //获取 WMS 的代理类 IWindowManager windowManager = getWindowManagerService(); //经过 Binder 调用，最终调用 WMS sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123;...&#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; ... &#125; &#125; return sWindowSession &#125;&#125; WindowManagerService.openSession：12345public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) &#123; //创建 Session 对象 Session session = new Session(this, callback, client, inputContext); return session;&#125; 再次经过 Binder 将数据写回 app 进程，则获取的便是 Session 的代理对象 IWindowSession。 创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。ViewRootImpl：12345678910111213public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; requestLayout(); //详见下面分析 ... //通过 Binder调用，进入 system 进程的 Session res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); ... &#125;&#125; 12345678final class Session extends IWindowSession.Stub implements IBinder.DeathRecipient &#123; public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; //调用 WMS.addWindow return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel); &#125;&#125; WindowManagerService.java：123456789101112131415161718192021222324252627282930public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ... WindowToken token = mTokenMap.get(attrs.token); //创建 WindowState WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); ... //调整 WindowManager 的 LayoutParams 参数 mPolicy.adjustWindowParamsLw(win.mAttrs); res = mPolicy.prepareAddWindowLw(win, attrs); addWindowToListInOrderLocked(win, true); // 设置 input mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); //详见下面分析 win.attach(); mWindowMap.put(client.asBinder(), win); if (win.canReceiveKeys()) &#123; //当该窗口能接收按键事件，则更新聚焦窗口 focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false /*updateInputWindows*/); &#125; assignLayersLocked(displayContent.getWindowList()); ...&#125;//WindowState.javavoid attach() &#123; mSession.windowAddedLocked();&#125; 创建 SurfaceSession 对象，并将当前 Session 添加到 WMS.mSessions 成员变量。Session.java：12345678910void windowAddedLocked() &#123; if (mSurfaceSession == null) &#123; mSurfaceSession = new SurfaceSession(); mService.mSessions.add(this); if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123; mService.dispatchNewAnimatorScaleLocked(this); &#125; &#125; mNumWindow++;&#125; SurfaceSession 的创建会调用 JNI，在 JNI 调用 nativeCreate()。android_view_SurfaceSession.cpp：12345static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123; SurfaceComposerClient* client = new SurfaceComposerClient(); client-&gt;incStrong((void*)nativeCreate); return reinterpret_cast&lt;jlong&gt;(client);&#125; 创建 SurfaceComposerClient 对象， 作为跟 SurfaceFlinger 通信的代理对象。12345678910111213SurfaceComposerClient::SurfaceComposerClient() &#123; //getComposerService() 将返回 SF 的 Binder 代理端的 BpSurfaceFlinger 对象 sp&lt;ISurfaceComposer&gt; sm(getComposerService()); //先调用 SF 的 createConnection()，再调用_init _init(sm, sm-&gt;createConnection()); if(mClient != 0) &#123; Mutex::Autolock _l(gLock); //gActiveConnections 是全局变量，把刚才创建的 client 保存到这个 map 中去 gActiveConnections.add(mClient-&gt;asBinder(), this); &#125;&#125; SurfaceFlinger.cpp：12345678910111213141516171819202122232425262728293031sp&lt;ISurfaceFlingerClient&gt;SurfaceFlinger::createConnection() &#123; Mutex::Autolock _l(mStateLock); uint32_t token = mTokens.acquire(); //先创建一个Client sp&lt;Client&gt; client = new Client(token, this); //把这个Client对象保存到mClientsMap中，token是它的标识。 status_t err = mClientsMap.add(token, client); /* 创建一个用于 Binder 通信的 BClient，BClient 派生于 ISurfaceFlingerClient， 它的作用是接受客户端的请求，然后把处理提交给 SF，注意，并不是提交给 Client。 Client 会创建一块共享内存，该内存由 getControlBlockMemory 函数返回。 */ sp&lt;BClient&gt; bclient = new BClient(this, token,client-&gt;getControlBlockMemory()); return bclient;&#125;Client::Client(ClientID clientID, constsp&lt;SurfaceFlinger&gt;&amp; flinger):ctrlblk(0), cid(clientID), mPid(0), mBitmap(0), mFlinger(flinger) &#123;const int pgsize = getpagesize(); //下面这个操作会使 cblksize 为页的大小，目前是4096字节 constint cblksize = ((sizeof(SharedClient)+(pgsize-1))&amp;~(pgsize-1)); mCblkHeap = new MemoryHeapBase(cblksize, 0, "SurfaceFlinger Clientcontrol-block"); ctrlblk = static_cast&lt;SharedClient *&gt;(mCblkHeap-&gt;getBase()); if(ctrlblk) &#123; new(ctrlblk) SharedClient;//原来 Surface 的 CB 对象就是在共享内存中创建的这个 SharedClient 对象 &#125;&#125; SharedClient：1234567891011121314151617181920class SharedClient &#123;public: SharedClient(); ~SharedClient(); status_t validate(size_t token) const; uint32_t getIdentity(size_t token) const;private: Mutexlock; Condition cv; //支持跨进程的同步对象 //NUM_LAYERS_MAX 为 31，SharedBufferStack 是什么？ SharedBufferStack surfaces[ NUM_LAYERS_MAX ];&#125;;//SharedClient的构造函数，没什么新意，不如Audio的CB对象复杂SharedClient::SharedClient():lock(Mutex::SHARED), cv(Condition::SHARED) &#123;&#125; 一个 Client 最多支持 31 个显示层。每一个显示层的生产/消费步调都由会对应的 SharedBufferStack 来控制。而它内部就用了几个成员变量来控制读写位置。 SharedBufferStack.h：12345678910class SharedBufferStack&#123; ...... //Buffer 是按块使用的，每个 Buffer 都有自己的编号，其实就是数组中的索引号。 volatile int32_t head; //FrontBuffer 的编号 volatile int32_t available; //空闲 Buffer 的个数 volatile int32_t queued; //脏 Buffer 的个数，脏 Buffer 表示有新数据的 Buffer volatile int32_t inUse; //SF 当前正在使用的 Buffer 的编号 volatilestatus_t status; //状态码 ...... &#125; SF 的一个 Client 分配一个跨进程共享的 SharedClient 对象。这个对象有31个 SharedBufferStack 元素，每一个 SharedBufferStack 对应于一个显示层。 一个显示层将创建两个 Buffer，后续的 PageFlipping 就是基于这两个 Buffer 展开的。 接着看 SurfaceComposerClient 中这个_init函数：12345678910111213void SurfaceComposerClient::_init( const sp&lt;ISurfaceComposer&gt;&amp; sm, constsp&lt;ISurfaceFlingerClient&gt;&amp; conn) &#123; mPrebuiltLayerState = 0; mTransactionOpen = 0; mStatus = NO_ERROR; mControl = 0; mClient = conn;// mClient 就是 BClient 的客户端 mControlMemory =mClient-&gt;getControlBlock(); mSignalServer = sm;// mSignalServer 就是 BpSurfaceFlinger //mControl 就是那个创建于共享内存之中的 SharedClient mControl = static_cast&lt;SharedClient*&gt;(mControlMemory-&gt;getBase());&#125; 创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。在 setView() 中调用了 requestLayout() 方法我们来看下这个方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void requestLayout() &#123; checkThread(); mLayoutRequested = true; scheduleTraversals();&#125;public void scheduleTraversals() &#123; if(!mTraversalScheduled) &#123; mTraversalScheduled = true; sendEmptyMessage(DO_TRAVERSAL); //发送 DO_TRAVERSAL 消息 &#125;&#125;public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ...... case DO_TRAVERSAL: ...... performTraversals();//调用 performTraversals() ...... break; ...... &#125;&#125;private void performTraversals() &#123; finalView host = mView;//还记得这mView吗？它就是 DecorView booleaninitialized = false; booleancontentInsetsChanged = false; booleanvisibleInsetsChanged; try &#123; relayoutResult= // 1. 关键函数relayoutWindow relayoutWindow(params, viewVisibility,insetsPending); &#125; ...... draw(fullRedrawNeeded);// 2. 开始绘制 ......&#125;private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending)throws RemoteException &#123; //原来是调用 IWindowSession 的 relayout()，暂且记住这个调用 int relayoutResult = sWindowSession.relayout(mWindow, params, (int) (mView.mMeasuredWidth * appScale + 0.5f), (int) (mView.mMeasuredHeight * appScale + 0.5f), viewVisibility, insetsPending, mWinFrame, mPendingContentInsets, mPendingVisibleInsets, mPendingConfiguration, mSurface); //mSurface 做为参数传进去了。 &#125; ......&#125;private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface;//mSurface 是 ViewRoot 的成员变量 ...... Canvascanvas; try &#123; int left = dirty.left; int top = dirty.top; int right = dirty.right; int bottom = dirty.bottom; //从 mSurface 中 lock 一块 Canvas canvas = surface.lockCanvas(dirty); ...... mView.draw(canvas);//调用 DecorView 的 draw 函数，canvas 就是画布 ...... //unlock 画布，屏幕上马上就能看到 View 的样子了 surface.unlockCanvasAndPost(canvas); &#125; ......&#125; 在 ViewRoot 构造时，会创建一个 Surface，它使用无参构造函数，代码如下所示：1final Surface mSurface = new Surface(); 此时创建完的 Surface 是空的，什么都没有。接着继续分析 relayoutWindow()，在 relayoutWindow() 中会调用 IWindowSession 的 relayout()，这是一个跨进程方法会调用到 WMS 中的 Session.relayout()，最后调用到 WindowManagerService.relayoutWindow()。12345678910111213141516public int relayoutWindow(Session session,IWindow client, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, boolean insetsPending, Rect outFrame, Rect outContentInsets, Rect outVisibleInsets, Configuration outConfig, SurfaceoutSurface)&#123; ..... try &#123; //win 就是 WinState，这里将创建一个本地的 Surface 对象 Surfacesurface = win.createSurfaceLocked(); if(surface != null) &#123; //先创建一个本地 surface，然后在 outSurface 的对象上调用 copyFrom //将本地 Surface 的信息拷贝到 outSurface 中，为什么要这么麻烦呢？ outSurface.copyFrom(surface); ......&#125; WindowManagerService.java::WindowState：123456789101112Surface createSurfaceLocked() &#123; ...... try &#123; //mSurfaceSession 就是在 Session 上创建的 SurfaceSession 对象 //这里，以它为参数，构造一个新的 Surface 对象 mSurface = new Surface(mSession.mSurfaceSession, mSession.mPid, mAttrs.getTitle().toString(), 0, w, h, mAttrs.format, flags); &#125; Surface.openTransaction();//打开一个事务处理 ...... Surface.closeTransaction();//关闭一个事务处理 ......&#125; 构造 Surface 对象：12345678public Surface(SurfaceSession s,//传入一个SurfaceSession对象 int pid, String name, int display, int w, int h, int format, int flags) throws OutOfResourcesException &#123; ...... mCanvas = new CompatibleCanvas(); //又一个 native 函数 init(s,pid,name,display,w,h,format,flags); mName = name; &#125; 123456789101112131415static void Surface_init(JNIEnv*env, jobject clazz, jobject session, jint pid, jstring jname, jint dpy, jint w, jint h, jint format, jintflags) &#123; //从 SurfaceSession 对象中取出之前创建的那个 SurfaceComposerClient 对象 SurfaceComposerClient* client = (SurfaceComposerClient*)env-&gt;GetIntField(session, sso.client); sp&lt;SurfaceControl&gt; surface;//注意它的类型是 SurfaceControl if (jname == NULL) &#123; //调用 SurfaceComposerClient 的 createSurface 函数，返回的 surface 是一个 SurfaceControl 类型 surface = client-&gt;createSurface(pid, dpy, w, h, format, flags); &#125; else&#123; ...... &#125; //把这个 surfaceControl 对象设置到 Java 层的 Surface 对象中 setSurfaceControl(env, clazz, surface);&#125; 在 createSurface 内部会使用 Binder 通信将请求发给 SurfaceFlinger：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354sp&lt;ISurface&gt;SurfaceFlinger::createSurface(ClientID clientId, int pid, const String8&amp; name, ISurfaceFlingerClient::surface_data_t* params, DisplayID d, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) &#123; sp&lt;LayerBaseClient&gt; layer;//LayerBaseClient 是 Layer 家族的基类 //这里又冒出一个 LayerBaseClient 的内部类，它也叫Surface sp&lt;LayerBaseClient::Surface&gt; surfaceHandle; Mutex::Autolock _l(mStateLock); //根据 clientId 找到 createConnection 时加入的那个 Client 对象 sp&lt;Client&gt; client = mClientsMap.valueFor(clientId); ...... //注意这个 id，它的值表示 Client 创建的是第几个显示层 //同时也表示将使用 SharedBufferStatck 数组的第 id 个元素 int32_t id = client-&gt;generateId(pid); //一个 Client 不能创建多于 NUM_LAYERS_MAX 个的Layer if(uint32_t(id) &gt;= NUM_LAYERS_MAX) &#123; return surfaceHandle; &#125; //根据 flags 参数来创建不同类型的显示层 switch(flags &amp; eFXSurfaceMask) &#123; case eFXSurfaceNormal: if (UNLIKELY(flags &amp; ePushBuffers)) &#123; //创建 PushBuffer 类型的显示层 layer = createPushBuffersSurfaceLocked(client, d, id, w, h, flags); &#125; else &#123; //创建 Normal 类型的显示层 layer = createNormalSurfaceLocked(client, d, id, w, h, flags, format); &#125; break; case eFXSurfaceBlur: //创建 Blur 类型的显示层 layer = createBlurSurfaceLocked(client, d, id, w, h, flags); break; case eFXSurfaceDim: //创建 Dim 类型的显示层 layer = createDimSurfaceLocked(client, d, id, w, h, flags); break; &#125; if(layer != 0) &#123; layer-&gt;setName(name); setTransactionFlags(eTransactionNeeded); //从显示层对象中取出一个 ISurface 对象赋值给 SurfaceHandle surfaceHandle = layer-&gt;getSurface(); if(surfaceHandle != 0) &#123; params-&gt;token = surfaceHandle-&gt;getToken(); params-&gt;identity = surfaceHandle-&gt;getIdentity(); params-&gt;width = w; params-&gt;height = h; params-&gt;format = format; &#125; &#125; return surfaceHandle;//ISurface 的 Bn 端就是这个对象&#125; 12345678910111213141516171819202122232425sp&lt;LayerBaseClient&gt;SurfaceFlinger::createNormalSurfaceLocked(const sp&lt;Client&gt;&amp; client, DisplayID display, int32_t id, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format) &#123; switch(format) &#123; //一些图像方面的参数设置，可以不去管它 case PIXEL_FORMAT_TRANSPARENT: case PIXEL_FORMAT_TRANSLUCENT: format = PIXEL_FORMAT_RGBA_8888; break; case PIXEL_FORMAT_OPAQUE: format = PIXEL_FORMAT_RGB_565; break; &#125; //创建一个 Layer 类型的对象 sp&lt;Layer&gt; layer = new Layer(this, display,client, id); //设置 Buffer status_t err = layer-&gt;setBuffers(w, h, format, flags); if (LIKELY(err == NO_ERROR)) &#123; //初始化这个新 layer 的一些状态 layer-&gt;initStates(w, h, flags); //下面这个函数把这个 layer 加入到 Z 轴集合中 addLayer_l(layer); &#125;...... return layer;&#125; createNormalSurfaceLocked 函数有三个关键点，它们是： 构造一个Layer对象。 调用Layer对象的setBuffers函数。 调用SF的addLayer_l函数。 当跨进程的 createSurface() 执行完返回一个 ISurface 对象，接下来会创建 SurfaceControl 对象：123456789101112SurfaceControl::SurfaceControl( const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;ISurface&gt;&amp; surface, const ISurfaceFlingerClient::surface_data_t&amp; data, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) //mClient 为 SurfaceComposerClient，而 mSurface 指向跨进程 createSurface() 调用返回的 ISurface 对象 :mClient(client), mSurface(surface), mToken(data.token), mIdentity(data.identity), mWidth(data.width), mHeight(data.height), mFormat(data.format), mFlags(flags)&#123; ......&#125; SurfaceControl 类可以看作是一个 wrapper 类，它封装了一些函数，通过这些函数可以方便地调用 mClient 或 ISurface 提供的函数。 最后会执行 copyFrom() 返回给 App 客户端：12345678910static void Surface_copyFrom(JNIEnv* env,jobject clazz, jobject other) &#123; //根据JNI函数的规则，clazz 是 copyFrom 的调用对象，而 other 是 copyFrom 的参数。 //目标对象此时还没有设置 SurfaceControl，而源对象在前面已经创建了 SurfaceControl constsp&lt;SurfaceControl&gt;&amp; surface = getSurfaceControl(env, clazz); constsp&lt;SurfaceControl&gt;&amp; rhs = getSurfaceControl(env, other); if (!SurfaceControl::isSameSurface(surface, rhs)) &#123; //把源 SurfaceControl 对象设置到目标 Surface 中 setSurfaceControl(env, clazz, rhs); &#125;&#125; copyFrom 期间一共有三个关键对象，它们分别是： SurfaceComposerClient SurfaceControl Surface，这个 Surface 对象属于 Native 层，和 Java 层的 Surface 相对应 其中转移到 ViewRoot 成员变量 mSurface 中的，就是最后这个 Surface 对象了。 在 SurfaceFlinger 进程中，Client 的一个 Layer 将使用 SharedBufferStack 数组中的一个成员，并通过 SharedBufferServer 结构来控制这个成员，我们知道 SurfaceFlinger 是消费者，所以可由 SharedBufferServer 来控制数据的读取。 与之相对应，客户端的进程也会有一个对象来使用这个 SharedBufferStack，可它是通过另外一个叫 SharedBufferClient 的结构来控制的。客户端为 SurfaceFlinger 提供数据，所以可由 SharedBufferClient 控制数据的写入。 Surface 显示过程 如图所示，在 App 进程中创建 PhoneWindow 后会创建 ViewRoot。ViewRoot 的创建会创建一个 Surface，这个 Surface 其实是空的，通过与 WindowManagerService 通信 copyFrom() 一个 NativeSurface。在与 SurfaceFlinger 通信时，会创建 SharedClient 一段共享内存，里面存放的是 SharedBufferStack 对应 SurfaceFlinger 中的 SurfaceLayer 每个 Layer 其实是一个 FrameBuffer，每个 FrameBuffer 中有两个 GraphicBuffer 记作 FrontBuffer 和 BackBuffer。 在 SurfaceFlinger 中 SharedBufferServer 来管理 FrameBuffer。同时在 App 端 copyFrom() 出来 NativeSurface 时会创建一个 SharedBufferClient 与 SharedClient 这块共享内存关联。当客户端 addView() 或者需要更新 View 时，会通过 SharedBufferClient 写入数据到 ShareClient 中，SurfaceFlinger 中的 SharedBufferServer 接收到通知会将 FrameBuffer 中的数据传输到屏幕上。 HWComposer 是基于硬件来产生 VSync 信号的，来通知 SurfaceFlinger 重绘控制显示的帧率。 以上理解属于个人观点，能力有限，若有错误欢迎指出，欢迎交流学习，共同进步。 参考资料 深入理解Surface系统 Android图形系统 SurfaceFlinger启动篇 SurfaceFlinger绘图篇 《深入理解 Android 内核设计思想》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
        <tag>Surface</tag>
        <tag>SurfaceFlinger</tag>
        <tag>视图显示原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章看明白 Activity 与 Window 与 View 之间的关系]]></title>
    <url>%2F2018%2F02%2F11%2Fandroid-activity-window-view%2F</url>
    <content type="text"><![CDATA[Android - Activity 与 Window 与 View 之间的关系概述我们知道 Activity 启动后就可以看到我们写的 Layout 布局界面，Activity 从 setContentView() 到显示中间做了什么呢？下面我们就来分析下这个过程。 如不了解 Activity 的启动过程请参阅：Activity 启动过程 本文主要对于以下问题进行分析： Window 是什么？ Activity 与 PhoneWindow 与 DecorView 之间什么关系？ onCreate() - Window 创建过程 在 Activity 创建过程中执行 scheduleLaunchActivity() 之后便调用到了 handleLaunchActivity() 方法。 ActivityThread.handleLaunchActivity()：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; handleConfigurationChanged(null, null); //初始化 WindowManagerService，主要是获取到 WindowManagerService 代理对象 WindowManagerGlobal.initialize(); //详情见下面分析 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); //详见下面分析 [onResume() - Window 显示过程] handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); ... &#125; ...&#125;...private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; //获取 ClassLoader java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //创建目标 Activity 对象 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; //创建 Application 对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); //详情见下面分析 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ... //回调 Activity.onCreate() if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... return activity;&#125;...final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123; attachBaseContext(context); mWindow = new PhoneWindow(this); //创建 PhoneWindow mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ... mApplication = application; //所属的 Application ... //设置并获取 WindowManagerImpl 对象 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config;&#125; 可看出 Activity 里新建一个 PhoneWindow 对象。在 Android 中，Window 是个抽象的概念， Android 中 Window 的具体实现类是 PhoneWindow，Activity 和 Dialog 中的 Window 对象都是 PhoneWindow。 同时得到一个 WindowManager 对象，WindowManager 是一个抽象类，这个 WindowManager 的具体实现是在 WindowManagerImpl 中，对比 Context 和 ContextImpl。 Window.setWindowManager()：12345public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; ... mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); ...&#125; 每个 Activity 会有一个 WindowManager 对象，这个 mWindowManager 就是和 WindowManagerService 进行通信，也是 WindowManagerService 识别 View 具体属于那个 Activity 的关键，创建时传入 IBinder 类型的 mToken。 1mWindow.setWindowManager(..., mToken, ..., ...) 这个 Activity 的 mToken，这个 mToken 是一个 IBinder，WindowManagerService 就是通过这个 IBinder 来管理 Activity 里的 View。 回调 Activity.onCreate() 后，会执行 setContentView() 方法将我们写的 Layout 布局页面设置给 Activity。 Activity.setContentView()：1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; PhoneWindow.setContentView()：12345public void setContentView(int layoutResID) &#123; ... installDecor(); ... &#125; PhoneWindow.installDecor()：123private void installDecor() &#123; //根据不同的 Theme，创建不同的 DecorView，DecorView 是一个 FrameLayout &#125; 这时只是创建了 PhoneWindow，和DecorView，但目前二者也没有任何关系，产生关系是在ActivityThread.performResumeActivity 中，再调用 r.activity.performResume()，调用 r.activity.makeVisible，将 DecorView 添加到当前的 Window 上。 onResume() - Window 显示过程Activity 与 PhoneWindow 与 DecorView 关系图： ActivityThread.handleResumeActivity()：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; //执行到 onResume() ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) &#123; final Activity a = r.activity; boolean willBeVisible = !a.mStartedActivity; ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; &#125; ... if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; ... mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; //添加视图，详见下面分析 r.activity.makeVisible(); &#125; &#125; //resume 完成 if (reallyResume) &#123; ActivityManagerNative.getDefault().activityResumed(token); &#125; &#125; else &#123; ... &#125;&#125;public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null &amp;&amp; !r.activity.mFinished) &#123; ... //回调 onResume() r.activity.performResume(); ... &#125; return r;&#125; Activity.makeVisible()：123456789void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); //详见下面分析 wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; WindowManager 的 addView 的具体实现在 WindowManagerImpl 中，而 WindowManagerImpl 的 addView 又会调用 WindowManagerGlobal.addView()。 WindowManagerGlobal.addView()：12345678910public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow) &#123; ... ViewRootImpl root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); root.setView(view, wparams, panelParentView); ...&#125; 这个过程创建一个 ViewRootImpl，并将之前创建的 DecoView 作为参数传入，以后 DecoView 的事件都由 ViewRootImpl 来管理了，比如，DecoView 上添加 View，删除 View。ViewRootImpl 实现了 ViewParent 这个接口，这个接口最常见的一个方法是 requestLayout()。 ViewRootImpl 是个 ViewParent，在 DecoView 添加的 View 时，就会将 View 中的 ViewParent 设为 DecoView 所在的 ViewRootImpl，View 的 ViewParent 相同时，理解为这些 View 在一个 View 链上。所以每当调用 View 的 requestLayout()时，其实是调用到 ViewRootImpl，ViewRootImpl 会控制整个事件的流程。可以看出一个 ViewRootImpl 对添加到 DecoView 的所有 View 进行事件管理。 ViewRootImpl：12345678910111213141516171819202122public ViewRootImpl(Context context, Display display) &#123; mContext = context; //获取 IWindowSession 的代理类 mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mThread = Thread.currentThread(); //主线程 mWindow = new W(this); mChoreographer = Choreographer.getInstance(); ...&#125;public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; ... //通过 Binder 调用，进入 system 进程的 Session res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); ... &#125;&#125; WindowManagerGlobal：12345678910111213141516171819public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; //获取 InputManagerService 的代理类 InputMethodManager imm = InputMethodManager.getInstance(); //获取 WindowManagerService 的代理类 IWindowManager windowManager = getWindowManagerService(); //经过 Binder 调用，最终调用 WindowManagerService sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123;...&#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; ... &#125; &#125; return sWindowSession &#125;&#125; 通过 binder 调用进入 system_server 进程。Session：12345678final class Session extends IWindowSession.Stub implements IBinder.DeathRecipient &#123; public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; //详情见下面 return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel); &#125;&#125; WindowManagerService：12345678910111213141516171819202122232425public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ... WindowToken token = mTokenMap.get(attrs.token); //创建 WindowState WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); ... //调整 WindowManager 的 LayoutParams 参数 mPolicy.adjustWindowParamsLw(win.mAttrs); res = mPolicy.prepareAddWindowLw(win, attrs); addWindowToListInOrderLocked(win, true); // 设置 input mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); // 创建 Surface 与 SurfaceFlinger 通信，详见下面[SurfaceFlinger 图形系统] win.attach(); mWindowMap.put(client.asBinder(), win); if (win.canReceiveKeys()) &#123; //当该窗口能接收按键事件，则更新聚焦窗口 focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false /*updateInputWindows*/); &#125; assignLayersLocked(displayContent.getWindowList()); ...&#125; 创建 Surface 的过程详见：SurfaceFlinger 图形系统 Activity 中 Window 创建过程： 总结 Window 是什么？ Window 是 Android 中窗口的宏观定义，主要是管理 View 的创建，以及与 ViewRootImpl 的交互，将 Activity 与 View 解耦。 Activity 与 PhoneWindow 与 DecorView 之间什么关系？ 一个 Activity 对应一个 Window 也就是 PhoneWindow，一个 PhoneWindow 持有一个 DecorView 的实例，DecorView 本身是一个 FrameLayout。 参考资料 以Window视角来看startActivity Android视图框架Activity,Window,View,ViewRootImpl理解 《深入理解 Android 内核设计思想》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>源码分析</tag>
        <tag>Window</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章看明白 Android 从点击应用图标到界面显示的过程]]></title>
    <url>%2F2018%2F01%2F04%2Fandroid-activity-start%2F</url>
    <content type="text"><![CDATA[Android - Activity 启动过程概述从点击桌面应用图标到应用显示的过程我们再熟悉不过了，下面我们来分析下这个过程都做了什么。 本文主要对以下问题分析： ActivityThread 是什么，它是一个线程吗，如何被启动的？ ActivityClientRecord 与 ActivityRecord 是什么？ Context 是什么，ContextImpl，ContextWapper 是什么？ Instrumentation 是什么？ Application 是什么，什么时候创建的，每个应用程序有几个 Application？ 点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？ Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？ Launcher如不了解 Android 是如何从开机到 Launcher 启动的过程，请先阅读Android - 系统启动过程。 我们知道 Android 系统启动后已经启动了 Zygote，ServiceManager，SystemServer 等系统进程；ServiceManager 进程中完成了 Binder 初始化；SystemServer 进程中 ActivityManagerService，WindowManagerService，PackageManagerService 等系统服务在 ServiceManager 中已经注册；最后启动了 Launcher 桌面应用。 其实 Launcher 本身就是一个应用程序，运行在自己的进程中，我们看到的桌面就是 Launcher 中的一个 Activity。 应用安装的时候，通过 PackageManagerService 解析 apk 的 AndroidManifest.xml 文件，提取出这个 apk 的信息写入到 packages.xml 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下/data/system/packages.xml。 同时桌面 Launcher 会为安装过的应用生成不同的应用入口，对应桌面上的应用图标，下面分析点击应用图标的到应用启动的过程。 点击 Launcher 中应用图标 点击 Launcher 中应用图标将会执行以下方法 1234567891011121314151617Launcher.startActivitySafely()Launcher.startActivity()//以上两个方法主要是检查将要打开的 Activity 是否存在Activity.startActivity()//这段代码大家已经很熟悉，经常打开 Activity 用的就是这个方法Activity.startActivityForResult()//默认 requestCode = -1，也可通过调用 startActivityForResult() 传入 requestCode。 //然后通过 MainThread 获取到 ApplicationThread 传入下面方法。Instrumentation.execStartActivity()//通过 ActivityManagerNative.getDefault() 获取到 ActivityManagerService 的代理为进程通讯作准备。ActivityManagerNative.getDefault().startActivity()ActivityManagerProxy.startActivity()//调用代理对象的 startActivity() 方法，发送 START_ACTIVITY_TRANSACTION 命令。 在 system_server 进程中的服务端 ActivityManagerService 收到 START_ACTIVITY_TRANSACTION 命令后进行处理，调用 startActivity() 方法。 12345678910111213141516171819202122232425262728ActivityManagerService.startActivity() -&gt; startActivityAsUser(intent, requestCode, userId)//通过 UserHandle.getCallingUserId() 获取到 userId 并调用 startActivityAsUser() 方法。ActivityStackSupervisor.startActivityMayWait() -&gt; resolveActivity()//通过 intent 创建新的 intent 对象，即使之前 intent 被修改也不受影响。 然后调用 resolveActivity()。//然后通过层层调用获取到 ApplicationPackageManager 对象。PackageManagerService.resolveIntent() -&gt; queryIntentActivities()//获取 intent 所指向的 Activity 信息，并保存到 Intent 对象。PackageManagerService.chooseBestActivity()//当存在多个满足条件的 Activity 则会弹框让用户来选择。ActivityStackSupervisor.startActivityLocked()//获取到调用者的进程信息。 通过 Intent.FLAG_ACTIVITY_FORWARD_RESULT 判断是否需要进行 startActivityForResult 处理。 //检查调用者是否有权限来调用指定的 Activity。 //创建 ActivityRecord 对象，并检查是否运行 App 切换。ActivityStackSupervisor.startActivityUncheckedLocked() -&gt; startActivityLocked()//进行对 launchMode 的处理[可参考 Activity 启动模式]，创建 Task 等操作。//启动 Activity 所在进程，已存在则直接 onResume()，不存在则创建 Activity 并处理是否触发 onNewIntent()。ActivityStack.resumeTopActivityInnerLocked()//找到 resume 状态的 Activity，执行 startPausingLocked() 暂停该 Activity，同时暂停所有处于后台栈的 Activity，找不到 resume 状态的 Activity 则回桌面。//如果需要启动的 Activity 进程已存在，直接设置 Activity 状态为 resumed。 调用下面方法。ActivityStackSupervisor.startSpecificActivityLocked()//进程存在调用 realStartActivityLocked() 启动 Activity，进程不存在则调用下面方法。 fork 新进程从 Launcher 点击图标，如果应用没有启动过，则会 fork 一个新进程。创建新进程的时候，ActivityManagerService 会保存一个 ProcessRecord 信息，Activity 应用程序中的AndroidManifest.xml 配置文件中，我们没有指定 Application 标签的 process 属性，系统就会默认使用 package 的名称。每一个应用程序都有自己的 uid，因此，这里 uid + process 的组合就可以为每一个应用程序创建一个 ProcessRecord。每次在新建新进程前的时候会先判断这个 ProcessRecord 是否已存在，如果已经存在就不会新建进程了，这就属于应用内打开 Activity 的过程了。 12ActivityManagerService.startProcessLocked()//进程不存在请求 Zygote 创建新进程。 创建成功后切换到新进程。 进程创建成功切换至 App 进程，进入 app 进程后将 ActivityThread 类加载到新进程，并调用 ActivityThread.main() 方法 12345678ActivityThread.main()//创建主线程的 Looper 对象，创建 ActivityThread 对象，ActivityThread.attach() 建立 Binder 通道，开启 Looper.loop() 消息循环。ActivityThread.attach()//开启虚拟机各项功能，创建 ActivityManagerProxy 对象，调用基于 IActivityManager 接口的 Binder 通道 ActivityManagerProxy.attachApplication()。ActivityManagerProxy.attachApplication()//发送 ATTACH_APPLICATION_TRANSACTION 命令 此时只创建了应用程序的 ActivityThread 和 ApplicationThread，和开启了 Handler 消息循环机制，其他的都还未创建， ActivityThread.attach(false) 又会最终到 ActivityMangerService 的 attachApplication，这个工程其实是将本地的 ApplicationThread 传递到 ActivityMangerService。然后 ActivityMangerService 就可以通过 ApplicationThread 的代理 ApplicationThreadProxy 来调用应用程序 ApplicationThread.bindApplication，通知应用程序的 ApplicationThread 已和 ActivityMangerService 绑定，可以不借助其他进程帮助直接通信了。此时 Launcher 的任务也算是完成了。 在 system_server 进程中的服务端 ActivityManagerService 收到 ATTACH_APPLICATION_TRANSACTION 命令后进行处理，调用 attachApplication()。 123ActivityMangerService.attachApplication() -&gt; attachApplicationLocked()//首先会获取到进程信息 ProcessRecord。 绑定死亡通知，移除进程启动超时消息。 获取到应用 ApplicationInfo 并绑定应用 IApplicationThread.bindApplication(appInfo)。//然后检查 App 所需组件。 Activity: 检查最顶层可见的 Activity 是否等待在该进程中运行，调用 ActivityStackSupervisor.attachApplicationLocked()。 Service：寻找所有需要在该进程中运行的服务，调用 ActiveServices.attachApplicationLocked()。 Broadcast：检查是否在这个进程中有下一个广播接收者，调用 sendPendingBroadcastsLocked()。 此处讨论 Activity 的启动过程，只讨论 ActivityStackSupervisor.attachApplicationLocked() 方法。 12345ActivityStackSupervisor.attachApplicationLocked() -&gt; realStartActivityLocked()//将该进程设置为前台进程 PROCESS_STATE_TOP，调用 ApplicationThreadProxy.scheduleLaunchActivity()。ApplicationThreadProxy.scheduleLaunchActivity()//发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令 发送送完 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，还会发送 BIND_APPLICATION_TRANSACTION 命令来创建 Application。 12ApplicationThreadProxy.bindApplication()//发送 BIND_APPLICATION_TRANSACTION 命令 App 进程初始化在 app 进程中，收到 BIND_APPLICATION_TRANSACTION 命令后调用 ActivityThread.bindApplication()。 12ActivityThread.bindApplication()//缓存 Service，初始化 AppBindData，发送消息 H.BIND_APPLICATION。 ApplicationThreadProxy.bindApplication(…) 会传来这个应用的一些信息，如ApplicationInfo，Configuration 等，在 ApplicationThread.bindApplication 里会待信息封装成A ppBindData，通过 1sendMessage(H.BIND_APPLICATION, data) 将信息放到应用里的消息队列里，通过 Handler 消息机制，在 ActivityThread.handleMeaasge 里处理 H.BIND_APPLICATION 的信息，调用 AplicationThread.handleBindApplication。 1234567891011121314151617181920212223242526272829303132333435handleBindApplication(AppBindData data) &#123; Process.setArgV0(data.processName);//设置进程名 ... //初始化 mInstrumentation if(data.mInstrumentation!=null) &#123; mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); &#125; else &#123; mInstrumentation = new Instrumentation(); &#125; //创建Application，data.info 是个 LoadedApk 对象。 Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; //调用 Application 的 onCreate()方法。 mInstrumentation.callApplicationOnCreate(app);&#125;public Application makeApplication(boolean forceDefaultAppClass,Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; String appClass = mApplicationInfo.className; java.lang.ClassLoader cl = getClassLoader(); //此时新建一个 Application 的 ContextImpl 对象， ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); //通过在 handleBindApplication 创建的 mInstrumentation 对象新建一个 Application 对象，同时进行 attach。 app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext); appContext.setOuterContext(app);&#125;//设置进程名，获取 LoadedApk 对象，创建 ContextImpl 上下文//LoadedApk.makeApplication() 创建 Application 对象，调用 Application.onCreate() 方法。 Instrumentation： 1234567891011121314151617public Application newApplication(ClassLoader cl, String className, Context context) &#123; return newApplication(cl.loadClass(className), context);&#125;Instrumentation类：static public Application newApplication(Class&lt;?&gt; clazz, Context context) &#123; //实例化 Application Application app = (Application)clazz.newInstance(); // Application 和 context绑定 app.attach(context); return app;&#125;//attach 就是将新建的 ContextImpl 赋值到 mBase，这个 ContextImpl 对象就是所有Application 内 Context 的具体实现，同时赋值一些其他的信息如 mLoadedApk。final void attach(Context context) &#123; mBase = base; mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 这时 Application 就创建好了，这点很重要，很多资料里说 Application 是在performLaunchActivity() 里创建的，因为 performLaunchActivity() 也有mInstrumentation.newApplication 这个调用，newApplication() 函数中可看出会先判断是否以及创建了 Application，如果之前已经创建，就返回已创建的 Application 对象。 Activity 启动上面 fork 进程时会发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，在 app 进程中，收到 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令后调用 ApplicationThread.scheduleLaunchActivity()。 1234567891011121314151617181920212223242526272829303132ApplicationThread.scheduleLaunchActivity()//发送消息 H.LAUNCH_ACTIVITY。sendMessage(H.LAUNCH_ACTIVITY, r);ActivityThread.handleLaunchActivity()//最终回调目标 Activity 的 onConfigurationChanged()，初始化 WindowManagerService。//调用 ActivityThread.performLaunchActivity()ActivityThread.performLaunchActivity() &#123; //类似 Application 的创建过程，通过 classLoader 加载到 activity. activity = mInstrumentation.newActivity(classLoader, component.getClassName(), r.intent); //因为 Activity 有界面，所以其 Context 是 ContextThemeWrapper 类型，但实现类仍是ContextImpl. Context appContext = createBaseContextForActivity(r, activity); activity.attach(context,mInstrumentation,application,...); //与 Window 进行关联 //attach 后调用 activity 的 onCreate()方法。 mInstrumentation.callActivityOnCreate(activity,...) &#125;//在ActivityThread.handleLaunchActivity里，接着调用Activity.performCreate() -&gt; onCreate()//最终回调目标 Activity 的 onCreate()。Activity.setContentView()//设置 layout 布局ActivityThread.performResumeActivity()//最终回调目标 Activity 的 onResume()。 与 Window 进行关联，具体过程详见：Activity，Window，View 之间的关系 总结Activity 的整体启动流程如图所示： ActivityThread 是什么，它是一个线程吗，如何被启动的？ 它不是一个线程，它是运行在 App 进程中的主线程中的一个方法中。当 App 进程创建时会执行 ActivityThread.main()，ActivityThread.main() 首先会创建 Looper 执行 Looper.prepareMainLooper()；然后创建 ActivityThread 并调用 ActivityThread.attach() 方法告诉 ActivityManagerService 我们创建了一个应用 并将 ApplicationThread 传给 ActivityManagerService；最后调用 Looper.loop()。 ActivityClientRecord 与 ActivityRecord 是什么？ 记录 Activity 相关信息，比如：Window，configuration，ActivityInfo 等。ActivityClientRecord 是客户端的，ActivityRecord 是 ActivityManagerService 服务端的。 Context 是什么，ContextImpl，ContextWapper 是什么？ Context 定义了 App 进程的相关环境，Context 是一个接口，ContextImpl 是子类，ContextWapper 是具体实现。 应用资源是在 Application 初始化的时候，也就是创建 Application，ContextImpl 的时候，ContextImpl 就包含这个路径，主要就是对就是 ResourcesManager 这个单例的引用。 可以看出每次创建 Application 和 Acitvity 以及 Service 时就会有一个 ContextImpl 实例，ContentProvider 和B roadcastReceiver 的 Context 是其他地方传入的。 所以 Context 数量 = Application 数量 + Activity 数量 + Service 数量，单进程情况下 Application 数量就是 1。 Instrumentation 是什么？ 管理着组件 Application，Activity，Service 等的创建，生命周期调用。 Application 是什么，什么时候创建的，每个应用程序有几个 Application？ Application 是在 ActivityThread.handleBindApplication() 中创建的，一个进程只会创建一个 Application，但是一个应用如果有多个进程就会创建多个 Application 对象。 点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？ 点击 Launcher 时会创建一个新进程来开启 Activity，而应用内打开 Activity，如果 Activity 不指定新进程，将在原来进程打开，是否开启新进程实在 ActivityManagerService 进行控制的，上面分析得到，每次开启新进程时会保存进程信息，默认为 应用包名 + 应用UID，打开 Activity 时会检查请求方的信息来判断是否需要新开进程。Launcher 打开 Activity 默认 ACTIVITY_NEW_TASK，新开一个 Activity 栈来保存 Activity 的信息。 Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？ Activity.onCreate() 完成了 App 进程，Application，Activity 的创建，调用 setContentView() 给 Activity 设置了 layout 布局。 Activity.onResume() 完成了 Activity 中 Window 与 WindowManager 的关联，并对所有子 View 进行渲染并显示。 参考资料 startActivity启动过程分析 Android应用程序的Activity启动过程简要介绍和学习计划 Android 应用点击图标到Activity界面显示的过程分析 《深入理解 Android 内核设计思想》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>启动过程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 项目架构探索]]></title>
    <url>%2F2017%2F12%2F12%2Fandroid-arch%2F</url>
    <content type="text"><![CDATA[Android Architecture概述该项目结合 MVP 与 Clean 架构思想，探索在 Android 项目上的最佳实践。 遵循 Clean Architecture 的原则。 数据层（Data Layer）：加入数据转换层（Mapper）将服务端数据模型（Entity）与本地数据模型（Model）解耦。 业务层（Domain Layer）：按模块划分业务，具体业务交给 Usecase 处理。 显示层（View Layer）： Presenter 不再与 Activity/Fragment 一一对应，Presenter 按照业务模块划分功能，大大提高 Presenter 的复用性。Activity/Fragment 中可以实现多个 View，持有多个 Presenter 来完成业务逻辑。 示例 分支 描述 master 演示了 Model-View-Presenter（MVP）+ Clean 架构，提供一些基类，状态栏沉浸适配等 develop 使用 butterknife develop-dagger 加入 dagger 的支持 develop-dagger-rxjava 加入 rxjava 的支持 数据层（Data Layer） 数据层（Data Layer）主要是数据获取与数据缓存策略的处理。 比如：第一次获取到数据，缓存到持久层（持久层可以放入数据库，SharedPreferences，文件或者其他形式）和内存中；第二次获取数据时应优先从内存中读取，其次是持久层，若本地缓存失效则直接从远程服务端获取，然后缓存到本地。 具体实现参见 UserRepository 业务层（Domain Layer） 业务层（Domain Layer）主要是根据业务需求来操作数据的逻辑。业务层将每条需求交个 Usecase 来处理，Usecase 通过 Repository 来获取数据。业务层与数据层解耦，方便扩展与测试。 具体实现参见 LoginRemoteTask 显示层（View Layer） 显示层（View Layer）主要是数据的展示与更新操作。显示层通过 Presenter 与业务层交互，Activity / Fragment 与 Presenter 解耦，将业务实现由 Presenter 组合而成。Presenter 与 View 对应，Activity / Fragment 由多个 View 管理。 具体实现参见 LoginActivity 项目结构 参考资料 Android 开发规范 android-architecture Android-CleanArchitecture 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Architecture</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 性能优化 内存优化]]></title>
    <url>%2F2017%2F11%2F05%2Fandroid-performance-optimization-memory%2F</url>
    <content type="text"><![CDATA[Android - 性能优化 内存优化概述JVM 内存分配机制 详见：JVM 内存分配机制 JVM 垃圾回收机制 详见：JVM 垃圾回收机制 DVM 与 JVM 的区别 虚拟机区别 Dalvik 虚拟机（DVM）是 Android 系统在 java虚拟机（JVM）基础上优化得到的，DVM 是基于寄存器的，而 JVM 是基于栈的，由于寄存器高效快速的特性，DVM 的性能相比 JVM 更好。 字节码区别 Dalvik 执行 .dex 格式的字节码文件，JVM 执行的是 .class 格式的字节码文件，Android 程序在编译之后产生的 .class 文件会被 aapt 工具处理生成 R.class 等文件，然后 dx 工具会把 .class 文件处理成 .dex 文件，最终资源文件和 .dex 文件等打包成 .apk 文件。 OOM 代码相关优化当应用程序申请的 java heap 空间超过 Dalvik VM HeapGrowthLimit 时溢出。 OOM 并不代表内存不足，只要申请的 heap 超过 Dalvik VM HeapGrowthLimit 时，即使内存充足也会溢出。 效果是能让较多进程常驻内存。 Bitmap Bitmap 非常消耗内存，而且在 Android 中，读取 bitmap 时， 一般分配给虚拟机的图片堆栈只有 8M，所以经常造成 OOM 问题。 所以有必要针对 Bitmap 的使用作出优化： 图片显示：加载合适尺寸的图片，比如显示缩略图的地方不要加载大图。 图片回收：使用完 bitmap，及时使用 Bitmap.recycle() 回收。 问题：Android 不是自身具备垃圾回收机制吗？此处为何要手动回收？ Bitmap 对象不是 new 生成的，而是通过 BitmapFactory 生产的。 而且通过源码可发现是通过调用 JNI 生成 Bitma p对象（nativeDecodeStream()等方法）。 所以，加载 bitmap 到内存里包括两部分，Dalvik 内存和 Linux kernel 内存。 前者会被虚拟机自动回收。 而后者必须通过 recycle() 方法，内部调用 nativeRecycle() 让 linux kernel 回收。 捕获 OOM 异常：程序中设定如果发生 OOM 的应急处理方式。 图片缓存：内存缓存、硬盘缓存等 图片压缩：直接使用 ImageView 显示 Bitmap 时会占很多资源，尤其当图片较大时容易发 生OOM。 可以使用 BitMapFactory.Options 对图片进行压缩。 图片像素：android 默认颜色模式为 ARGB_8888，显示质量最高，占用内存最大。 若要求不高时可采用 RGB_565 等模式。 图片大小：图片 长度×宽度×单位像素 所占据字节数。 我们知道 ARGB 指的是一种色彩模式，里面 A 代表 Alpha，R 表示 Red，G 表示 Green，B 表示 Blue。 所有的可见色都是由红绿蓝组成的，所以红绿蓝又称为三原色，每个原色都存储着所表示颜色的信息值,下表中对四种颜色模式的详细描述，以及每种色彩模式占用的字节数。 模式 描述 占用字节 ALPHA Alpha 由 8 位组成 1B ARGB_4444 4 个 4 位组成 16 位，每个色彩元素站 4 位 2B ARGB_8888 4 个 8 为组成 32 位，每个色彩元素站 8 位（默认） 4B RGB_565 R 为 5 位，G 为 6 位，B 为 5 位共 16 位，没有Alpha 2B 对象引用类型 强引用（Strong Reference）:JVM宁愿抛出OOM，也不会让GC回收的对象 软引用（Soft Reference） ：只有内存不足时，才会被GC回收。 弱引用（weak Reference）：在GC时，一旦发现弱引用，立即回收 虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。 可以用来作为 GC 回收 Object 的标志。 缓存池 对象池：如果某个对象在创建时，需要较大的资源开销，那么可以将其放入对象池，即将对象保存起来，下次需要时直接取出使用，而不用再次创建对象。当然，维护对象池也需要一定开销，故要衡量。 线程池：与对象池差不多，将线程对象放在池中供反复使用，减少反复创建线程的开销。 内存泄露相关优化当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。 单例造成的内存泄漏 单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 如下这个典例： 12345678910111213public class AppManager &#123; private static AppManager instance; private Context context; private AppManager(Context context) &#123; this.context = context; &#125; public static AppManager getInstance(Context context) &#123; if (instance != null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context，所以这个 Context 的生命周期的长短至关重要： 传入的是 Application 的 Context：这将没有任何问题，因为单例的生命周期和 Application 的一样长。 传入的是 Activity 的 Context：当这个 Context 所对应的 Activity 退出时，由于该 Context 和 Activity 的生命周期一样长（Activity 间接继承于 Context），所以当前 Activity 退出时它的内存并不会被回收，因为单例对象持有该 Activity 的引用。 所以正确的单例应该修改为下面这种方式： 12345678910111213public class AppManager &#123; private static AppManager instance; private Context context; private AppManager(Context context) &#123; this.context = context.getApplicationContext(); &#125; public static AppManager getInstance(Context context) &#123; if (instance != null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 这样不管传入什么 Context 最终将使用 Application 的 Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏。 非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法： 123456789101112131415public class MainActivity extends AppCompatActivity &#123; private static TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mResource == null)&#123; mResource = new TestResource(); &#125; //... &#125; class TestResource &#123; //... &#125;&#125; 这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。 正确的做法为： 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用 Context，请使用 ApplicationContext。 Handler 造成的内存泄漏 Handler 的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等 api 都应该会借助 Handler 来处理，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏，如下示例： 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; //... &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loadData(); &#125; private void loadData()&#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125;&#125; 这种创建 Handler 的方式会造成内存泄漏，由于 mHandler 是 Handler 的非静态匿名内部类的实例，所以它持有外部类 Activity 的引用，我们知道消息队列是在一个 Looper 线程中不断轮询处理消息，那么当这个 Activity 退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的 Message 持有 mHandler 实例的引用，mHandler 又持有 Activity 的引用，所以导致该 Activity 的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为： 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(""); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125;&#125; 创建一个静态 Handler 内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，这样虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列中的消息，更准确的做法如下： 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(""); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mHandler.removeCallbacksAndMessages(null); &#125;&#125; 使用 mHandler.removeCallbacksAndMessages(null); 是移除消息队列中所有消息和所有的 Runnable。 当然也可以使用 mHandler.removeCallbacks(); 或 mHandler.removeMessages(); 来移除指定的 Runnable 和 Message。 线程造成的内存泄漏 对于线程造成的内存泄漏，也是平时比较常见的，异步任务和 Runnable 都是一个匿名内部类，因此它们对当前 Activity 都有一个隐式引用。 如果 Activity 在销毁之前，任务还未完成，那么将导致 Activity 的内存资源无法回收，造成内存泄漏。 正确的做法还是使用静态内部类的方式，如下： 12345678910111213141516171819202122232425262728293031static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; private WeakReference&lt;Context&gt; weakReference; public MyAsyncTask(Context context) &#123; weakReference = new WeakReference&lt;&gt;(context); &#125; @Override protected Void doInBackground(Void... params) &#123; SystemClock.sleep(10000); return null; &#125; @Override protected void onPostExecute(Void aVoid) &#123; super.onPostExecute(aVoid); MainActivity activity = (MainActivity) weakReference.get(); if (activity != null) &#123; //... &#125; &#125;&#125;static class MyRunnable implements Runnable&#123; @Override public void run() &#123; SystemClock.sleep(10000); &#125;&#125;//——————new Thread(new MyRunnable()).start();new MyAsyncTask(this).execute(); 这样就避免了 Activity 的内存资源泄漏，当然在 Activity 销毁时候也应该取消相应的任务 AsyncTask::cancel()，避免任务在后台执行浪费资源。 资源使用完未关闭 BraodcastReceiver，ContentObserver，FileObserver，Cursor，Callback等在 Activity onDestroy 或者某类生命周期结束之后一定要 unregister 或者 close 掉，否则这个 Activity 类会被 system 强引用，不会被内存回收。 不要直接对 Activity 进行直接引用作为成员变量，如果不得不这么做，请用 private WeakReference mActivity 来做，相同的，对于Service 等其他有自己声明周期的对象来说，直接引用都需要谨慎考虑是否会存在内存泄露的可能。 其他优化 常用数据结构优化 ArrayMap 及 SparseArray 是 android 的系统 API，是专门为移动设备而定制的。 用于在一定情况下取代 HashMap 而达到节省内存的目的。 对于 key 为 int 的 HashMap 尽量使用 SparceArray 替代，大概可以省 30% 的内存，而对于其他类型，ArrayMap 对内存的节省实际并不明显，10% 左右，但是数据量在 1000 以上时，查找速度可能会变慢。 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用 StringBuilder 来替代频繁的 “+”。 枚举 Android 平台上枚举是比较争议的，在较早的 Android 版本，使用枚举会导致包过大，使用枚举甚至比直接使用 int 包的 size 大了 10 多倍。 在 stackoverflow 上也有很多的讨论, 大致意思是随着虚拟机的优化，目前枚举变量在 Android 平台性能问题已经不大，而目前 Android 官方建议，使用枚举变量还是需要谨慎，因为枚举变量可能比直接用 int 多使用 2 倍的内存。 View 复用 使用 ListView 时 getView 里尽量复用 conertView，同时因为 getView 会频繁调用，要避免频繁地生成对象。 优先考虑使用 RecyclerView 代替 ListView。 重复的布局优先使用 ，使用 减少 view 的层级，对于可以延迟初始化的页面，使用 。 谨慎使用多进程 现在很多 App 都不是单进程，为了保活，或者提高稳定性都会进行一些进程拆分，而实际上即使是空进程也会占用内存(1M 左右)，对于使用完的进程，服务都要及时进行回收。 系统资源 尽量使用系统组件，图片甚至控件的 id。 例如：@android:color/xxx，@android:style/xxx。 使用工具检查内存泄漏即使在编码时将上述情况都考虑了，往往会有疏忽的地方，更何况通常情况下是团队开发。 所以不仅仅要在编码时考虑内存优化的情况，当出现内存泄漏时，更有效更准确的定位问题才是最重要的方式。 内存泄漏不像 bug，排查起来相对复杂一些，下面介绍下常用的检查方式。 使用 Lint 代码静态检查Lint 是 Android Studio 自带的工具，使用很简单找到 Analyze -&gt; Inspect Code 然后选择想要扫面的区域即可。 选择 Lint 扫描区域。 对可能引起性能问题的代码，Lint 都会进行提示。 使用 Android Studio 自带的 Monitor Memory 检查一般在 Android Studio 的底部可以找到 Android Monitor。 可以看到当前 App的内存变动比较大，很有可能出现了内存泄漏。 点击 Dump Java Heap，等一段时间会自动生成 Heap Snapshot 文件。 在 Captures 中可以找到 hprof 文件。 在右侧找到 Analyzer Tasks 并打开，点击图中 Perform Analysis 按钮开始分析。 通过分析结果可以看到 TestActivity 泄漏了，从左侧 Reference Tree 中可以看到是 TestActivity 中的 context 泄露了。 我们来看下代码： 1234567891011121314public class TestActivity extends AppCompatActivity &#123; private static Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); context = this; &#125;&#125; 代码中 context 为静态的引用了当前 Activity 造成了当前 Activity 无法释放。 一般的通过 使用 Android Studio 自带的 Monitor Memory 可以定位到内存泄漏所在的类，更详细的信息需要借助 Memory Analyzer Tool（MAT）工具。 使用 Memory Analyzer Tool 检查首先下载 Memory Analyzer Tool 下载地址 在 Android Studio 中先将 hprof 文件导出为 MAT 可以识别的 hprof 文件。 打开刚才导出的文件。 经过分析后会显示如下，Leak Suspectss 是一个关于内存泄露猜想的饼图，Problem Suspect 1 是泄露猜想的描述。 Overview 是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在 Inspector 栏目显示这块区域的相关信息。 MAT 从多角度提供了内存分析，其中包括 Histogram、 Dominator Tree、 Leak Suspects 和 Top consumers 等。 这里我们使用 Histogram 进行分析，切换到 Histogram 页面。 这个页面主要有 4 个列，Class Name、 Objects、 Shallow Heap 和 Retained Heap。 其中 Class Name 是全类名，Objects 是这个类的对象实例个数。 Shallow Heap 是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。 Retained Heap 指当前对象大小和当前对象能直接或间接引用的对象大小的总和，这个栏目是分析重点。 内存分析是分析的整个系统的内存泄露，而我们只要查找我们 App 的内存泄露情况。 这无疑增加了很多工作，不过幸亏 Histogram 支持正则表达式查找，在 Regex 中输入我们的包名进行过滤，直奔和我们 App 有关的内存泄露。 过滤后就显示了我们 App 相关内存信息，按 Retained Heap 大小排列下，发现 MainActivity 和 TestActivity 这两个类问题比较大。 TestActivity 的问题更突出些，所以先从 TestActivity 下手。 首先看下是哪里的引用导致了 TestActivity 不能被 GC 回收。 右键使用 Merge Shortest Paths to GC Roots 显示距 GC Root 最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。 进入结果页查看。 可以看到 TestActivity 不能被 GC 回收是因为 context 没有释放的原因。 我们再来看下代码： 1234567891011121314public class TestActivity extends AppCompatActivity &#123; private static Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); context = this; &#125;&#125; 使用 LeakCanary 检查项目地址：https://github.com/square/leakcanary 使用方式很简单，参考项目里面的介绍即可。 ANR 什么是 ANR ANR:Application Not Responding，即应用无响应。 为用户在主线程长时间被阻塞是提供交互，提高用户体验。 Android 系统自身的一种检测机制。 ANR 的类型 ANR 一般有三种类型： KeyDispatchTimeout(5 seconds) : 主要类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) : BroadcastReceiver 在特定时间内无法处理完成 ServiceTimeout(20 seconds) : 小概率类型 Service 在特定的时间内无法处理完成 ANR 产生的原因 超时时间的计数一般是从按键分发给 app 开始。 超时的原因一般有两种： 当前的事件没有机会得到处理（即 UI 线程正在处理前一个事件，没有及时的完成或者 looper 被某种原因阻塞住了） 当前的事件正在处理，但没有及时完成。 ANR 出现流程分析 输入时间响应超时导致ANR流程 在系统输入管理服务进程（InputManagerService）中有一个线程（InputDispathcerThread）专门管理输入事件的分发，在该线程处理输入事件的过程中，回调用 InputDispatcher 对象方法不断的检测处理过程是否超时，一旦超时，则会通过一些列的回调调用 InputMethod 对象的 notifyANR 方法，其会最终出发 AMS 中 handler 对象的 SHOW_NOT_RESPONDING_MSG 这个事件，显示ANR对话框。 广播发生ANR流程 广播分为三类：普通的，有序的，异步的。 只有有序（ordered）的广播才会发生超时，而在 AndroidManifest 中注册的广播都会被当做有序广播来处理，会被放在广播的队列中串行处理。 AMS 在处理广播队列时，会设置一个超时时间，当处理一个广播达到超时时间的限制时，就会触发 BroadcastQueue 类对象的 processNextBroadcast 方法来判断是否超时，如果超时，就会终止该广播，触发ANR对话框。 UI线程 UI 线程主要包括如下： Activity : onCreate(), onResume(), onDestroy(), onKeyDown(), onClick(), etc 生命周期方法里。AsyncTask : onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel, etc 这些异步更改 UI 界面的方法里。Mainthread handler : handleMessage(), post*(runnable r), getMainLooper(), etc 通过 handler 发送消息到主线程的 looper，即占用主线程 looper 的。 ANR 执行流程 了解 ANR 执行流程有利于我们制定 ANR 监控策略和获取 ANR 的相关信息，ANR 的执行步骤如下： 系统捕获到 ANR 发生； Process 依次向本进程及其他正在运行的进程发送 Linux 信号量 3； 进程接收到 Linux 信号量，并向 /data/anr/traces.txt 中写入进程信息； Log 日志打印 ANR 信息； 进程进入 ANR 状态（此时可以获取到进程 ANR 信息); 弹出 ANR 提示框； 提示框消失，进程回归正常状态。 由于向 /data/anr/traces.txt 文件中写入信息耗时较长，从 Input ANR 触发到弹出 ANR 提示框一般在 10s 左右（不同 rom 时间不同）。 发生 ANR 如何定位 当 App 的进程发生 ANR 时，系统让活跃的 Top 进程都进行了一下 dump，进程中的各种 Thread 就都 dump 到这个 trace 文件里了，所以 trace 文件中包含了每一条线程的运行时状态。 traces.txt 的文件放在 /data/anr/ 下. 可以通过 adb 命令将其导出到本地: 1$ adb pull data/anr/traces.txt . 通过分析 traces.txt 文件，查找 App 包名关键信息来定位 ANR。 参考资料 Android Bitmap的内存大小是如何计算的？ Android性能优化之常见的内存泄漏 使用新版Android Studio检测内存泄露和性能 Android 应用内存泄漏的定位、分析与解决策略 Android 系统稳定性 - ANR 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存优化</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 性能优化 UI优化]]></title>
    <url>%2F2017%2F10%2F01%2Fandroid-performance-optimization-ui%2F</url>
    <content type="text"><![CDATA[Android - 性能优化 UI优化概述Android 应用的卡顿，丢帧等，这些影响用户体验的因素绝大部分都与 16ms 这个值有关。 下面我们来讨论下 UI 渲染方面影响应用流畅性的因素。 16ms 12 fps（帧/秒）：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约 10-12 fps 的时候，就会认为是连贯的。 早期的无声电影的帧率介于 16-24 fps 之间，虽然帧率足以让人感觉到运动，但往往被认为是在快放幻灯片。 在1920年代中后期，无声电影的帧率提高到 20-26 fps 之间。 24 fps：1926 年有声电影推出，人耳对音频的变化更敏感，反而削弱了人对电影帧率的关注。因为许多无声电影使用 20-26 fps 播放，所以选择了中间值 24 fps 作为有声电影的帧率。 之后 24 fps 成为35mm有声电影的标准。 30 fps：早期的高动态电子游戏，帧率少于每秒 30 fps 的话就会显得不连贯。这是因为没有动态模糊使流畅度降低。 （注:如果需要了解动态模糊技术相关知识，可以查阅 这里） 60 fps：在实际体验中，60 fps 相对于30 fps 有着更好的体验。 85 fps：一般而言，大脑处理视频的极限。 所以，总体而言，帧率越高体验越好。 一般的电影拍摄及播放帧率均为每秒 24 帧，但是据称《霍比特人：意外旅程》是第一部以每秒 48 帧拍摄及播放的电影，观众认为其逼真度得到了显著的提示。 目前，大多数显示器根据其设定按 30Hz、 60Hz、 120Hz 或者 144Hz 的频率进行刷新。 而其中最常见的刷新频率是 60Hz。 这样做是为了继承以前电视机刷新频率为 60Hz 的设定。 而 60Hz 是美国交流电的频率，电视机如果匹配交流电的刷新频率就可以有效的预防屏幕中出现滚动条，即互调失真。 正如上面所述目前大多数显示器的刷新率是 60Hz，Android 设备的刷新率也是 60Hz。只有当画面达到 60fps 时 App 应用才不会让用户感觉到卡顿。那么 60fps 也就意味着 1000ms/60Hz = 16ms。也就是说 16ms 渲染一次画面才不会卡顿。 V-Sync（垂直同步）玩游戏的同学，尤其是大型 FPS 游戏应该都见过“垂直同步”这个选项。因为 GPU 的生成图像的频率与显示器的刷新频率是相互独立的，所以就涉及到了一个配合的问题。 最理想的情况是两者之间的频率是相同且协同进行工作的，在这样的理想条件下，达到了最优解。但实际中 GPU 的生成图像的频率是变化的，如果没有有效的技术手段进行保证，两者之间很容易出现这样的情况：当 GPU 还在渲染下一帧图像时，显示器却已经开始进行绘制，这样就会导致屏幕撕裂（Tear）。这会使得屏幕的一部分显示的是前一帧的内容，而另一部分却在显示下一帧的内容。如下图所示： 屏幕撕裂（Tear）的问题，早在 PC 游戏时代就被发现， 并不停的在尝试进行解决。 其中最知名可能也是最古老的解决方案就是 V-Sync 技术。 V-Sync 的原理简单而直观：产生屏幕撕裂的原因是 GPU 在屏幕刷新时进行了渲染，而 V-Sync 通过同步渲染/刷新时间的方式来解决这个问题。显示器的刷新频率为 60Hz，若此时开启 V-Sync，将控制 GPU 渲染速度在 60Hz 以内以匹配显示器刷新频率。这也意味着，在 V-Sync 的限制下，GPU 显示性能的极限就限制为 60Hz 以内。这样就能很好的避免图像撕裂的问题。 Android 中的 GPU 渲染机制大多数的 App 界面卡顿（Jank）现象都与 GPU 渲染有关，尤其是存在多层次布局嵌套，存在不必要的绘制，或者在 onDraw() 方法中执行了耗时操作，动画执行次数过多的情况下很容易出现界面卡顿。 如上图所示，Android 系统每隔 16ms 就会发出一个 V-Sync 信号，触发对 UI 的渲染，如果每次渲染都能成功，这样就能保证画面的流畅帧率 60fps。 如果出现 16ms 内无法渲染的情况就无法响应 V-Sync 信号，就会出现丢帧现象。 如上图所示：如果某个操作耗时 24ms，系统就无法正常响应当前 V-Sync 信号，只能等待下次响应 V-Sync 信号，当前 V-Sync 信号就会丢失，也就是所谓丢帧。 Overdraw 过度绘制什么是过度绘制？过度绘制就是屏幕上的某个像素在同一帧的时间内被绘制了多次。 在多层次的UI结构里面，如果不可见的 UI 也在做绘制的操作，这就会导致某些像素区域被绘制了多次。 这就浪费大量的 CPU 以及 GPU 资源。 如何发现过度绘制？我们可以通过手机设置里面的 开发者选项 ，打开 显示过渡绘制区域（Show GPU Overdraw 的选项，可以观察 UI 上的 Overdraw 情况。 蓝色，淡绿，淡红，深红代表了 4 种不同程度的 Overdraw 情况，我们的目标就是尽量减少红色 Overdraw，看到更多的蓝色区域。 蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。 绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。 淡红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。 深红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。 Overdraw 有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。 例如：某个 Activity 有一个背景，然后里面的 Layout 又有自己的背景，同时子 View 又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色 Overdraw 区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。 使用 Hierarchy Viewer 分析 UI 性能首先打开 Hierarchy Viewer，依次找到：Android Studio -&gt; Tools -&gt; Android -&gt; Android Device Monitor 启动 Android Device Monitor 成功之后，在新的窗口中点击切换视图图标，选择 Hierarchy View，如下图： Hierarchy View 运行界面如下： 一个 Activity 的 View 树，通过这个树可以分析出 View 嵌套的冗余层级； 左下角可以输入 View 的 id 直接自动跳转到中间显示； Save as PNG 用来把左侧树保存为一张图片； Capture Layers 用来保存 psd 的 PhotoShop 分层素材； 右侧剧中显示选中 View 的当前属性状态； 右下角显示当前 View 在 Activity 中的位置等； Load View Hierarchy 用来手动刷新变化（不会自动刷新的）。 当我们选择一个 View 后会如下图所示： 类似上图可以很方便的查看到当前 View 的许多信息，上图最底那三个彩色原点代表了当前 View 的性能指标，从左到右依次代表测量、布局、绘制的渲染时间，红色和黄色的点代表速度渲染较慢的 View（当然了，有些时候较慢不代表有问题，比如 ViewGroup 子节点越多、结构越复杂，性能就越差）。 当然了，在自定义 View 的性能调试时，HierarchyViewer 上面的 invalidate Layout 和 requestLayout 按钮的功能更加强大，它可以帮助我们 debug 自定义 View 执行 invalidate() 和 requestLayout() 过程，我们只需要在代码的相关地方打上断点就行了，接下来通过它观察绘制即可。 可以发现，有了 Hierarchy View 调试工具，我们的 UI 性能分析变得十分容易，这个工具也是我们开发中调试 UI 的利器，在平时写代码时会时常伴随我们左右。 使用 GPU 呈现模式考核 UI 性能在 Android 手机上开启这个功能：打开 开发者选项 -&gt; GPU 呈现模式分析（Peofile GPU Rendering tool -&gt; 在屏幕上显示为条形图（On screen as bars 在 Android 系统中是以 60fps 为满帧，绿色横线为 16ms 分界线，低于绿线即为流畅。 屏幕下方的柱状图每一根代表一帧，其高度表示“渲染这一帧耗时”，随着手机屏幕界面的变化，柱状图会持续刷新每帧用时的具体情况（通过高度表示）。那么，当柱状图高于绿线，是不是就说明我卡了呢？其实这不完全正确，这里就要开始分析组成每一根柱状图不同颜色所代表的含义了。 红色，代表了“执行时间”，它指的是 Android 渲染引擎执行盒子中这些绘制命令的时间，假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如我们平时刷淘宝 App 时遇到出现多张缩略图需要加载时，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但其实这可能并不意味着你卡住了。 黄色，通常较短，它代表着 CPU 通知 GPU “你已经完成视图渲染了”，不过在这里 CPU 会等待 GPU 的回话，当 GPU 说“好的知道了”，才算完事儿。 假如橙色部分很高的话，说明当前 GPU 过于忙碌，有很多命令需要去处理，比如 Android 淘宝客户端，红色黄色通常会很高。 蓝色，假如想通过玄学曲线来判断流畅度的话，其实蓝色的参考意义是较大的。蓝色代表了视图绘制所花费的时间，表示视图在界面发生变化（更新）的用时情况。当它越短时，即便是体验上更接近“丝滑”，当他越长时，说明当前视图较复杂或者无效需要重绘，即我们通常说的“卡了”。 理解了玄学曲线不同颜色代表的意义，看懂玄学曲线就不难了。 一般情况下，当蓝色低于绿线时都不会出现卡顿，但是想要追求真正的丝般顺滑那当然还是三色全部处于绿线以下最为理想。 使用 TraceView 从代码层面分析性能问题生成 trace 文件有三种方法： 使用代码 使用 Android Studio 使用 DDMS 1. 使用代码生成 trace 文件123Debug.startMethodTracing("test_trace");//开始 trace，保存文件到 "/sdcard/test_trace.trace"// ...Debug.stopMethodTracing();//结束 代码很简单，当你调用开始代码的时候，系统会生产 trace 文件，并且产生追踪数据，当你调用结束代码时，会将追踪数据写入到 trace 文件中。 下一步使用 adb 命令将 trace 文件导出到电脑： 1adb pull /sdcard/test_trace.trace /tmp 使用代码生成 trace 方式的好处是容易控制追踪的开始和结束，缺点就是步骤稍微多了一点。 2. 使用 Android Studio 生成 trace 文件Android Studio 内置的 Android Monitor 可以很方便的生成 trace 文件到电脑。 在 CPU 监控的那栏会有一个闹钟似的的按钮，未启动应用时是灰色；启动应用后，这个按钮会变亮，点击后开始追踪，相当于代码调用 startMethodTracing； 当要结束追踪时再次点击这个按钮，就会生成 trace 文件了（文件可在 Caputures 中找到）。 生成 trace 后 Android Studio 自动加载的 traceview 图形如下： 从这个图可以大概了解一些方法的执行时间、次数以及调用关系，也可以搜索过滤特定的内容。 左上角可以切换不同的线程，这其实也是直接用 Android Studio 查看 trace 文件的缺点：无法直观地对比不同线程的执行时间。 鼠标悬浮到黄色的矩形上，会显示对应方法的开始、结束时间，以及自己占用和调用其他方法占用的时间比例： 3. 使用 DDMS 生成 trace 文件DDMS 即 Dalvik Debug Monitor Server ，是 Android 调试监控工具，它为我们提供了截图，查看 log，查看视图层级，查看内存使用等功能，可以说是如今 Android Studio 中内置的 Android Monitor 的前身。 打开 Android Device Monitor，找到 Device 选中需要测试的 app，点击 Start Method Profiling 后开始追踪，相当于代码调用 startMethodTracing； 当要结束追踪时再次点击这个按钮，就会生成 trace 文件； 停止追踪后，DDMS 会启动 TraceView 加载 trace 文件： 上图介绍了 TraceView 的大致内容 面板列名含义如下: 名称 说明 Incl Cpu Time CPU 执行该方法该方法及其子方法所花费的时间 Incl Cpu Time % CPU 执行该方法该方法及其子方法所花费占 CPU 总执行时间的百分比 Excl Cpu Time CPU 执行该方法所花费的时间 Excl Cpu Time % CPU 执行该方法所花费的时间占Cpu总时间的百分比 Incl Real Time 该方法及其子方法执行所花费的实际时间，从执行该方法到结束一共花了多少时间 Incl Real Time % 上述时间占总的运行时间的百分比 Excl Real Time 该方法自身的实际允许时间 Excl Real Time % 上述时间占总的允许时间的百分比 Calls+Recur 调用次数+递归次数，只在方法中显示，在子展开后的父类和子类方法这一栏被下面的数据代替 Calls/Total 调用次数和总次数的占比 Cpu Time/Call CPU 执行时间和调用次数的百分比，代表该函数消耗 CPU 的平均时间 Real Time/Call 实际时间于调用次数的百分比，该表该函数平均执行时间 点击下面的任意一个方法，可以看到它的详细信息： Parents：选中方法的调用处 Children：选中方法调用的方法 使用 Systrace 检测 App 的性能经过在上面的这些优化之后，如果你的界面还有卡顿，我们还有办法。 Systrace 工具也可以测量你 App 的性能。 甚至可以帮助你定位问题产生的位置。 这个工具是作为“Project Butter”一部分同 Jelly Bean 一同发布的，它能够从内核级检测你设备的运行状态。 Systrace 可配置的参数很多。我们这里重点关注 UI 是怎么渲染的，用 Systrace 检测卡顿问题。 Systrace 和之前的工具不同的是，它记录的是整个 Android 系统的状态，并不是针对某一个 App 的。所以最好是用运行 App 比较少的设备来做检测，这样就不会受到其他 App 的干扰了。 点击开始按钮会弹出窗口选择所需要的参数，这里主要研究屏幕的交互数据，主要收集 CPU，graphics 和 view 数据。 trace 数据记录在一个 html 文件里，可以用浏览器打开。 点击OK之后，Systrace 会马上开始采集设备上的数据（最好马上开始操作）。 因为采集的数据非常之多，所以最好一次只针对一个问题。 鼠标可以控制滑动，WASD 可以用来 zoom in/out（W，S）和左右滑动（A，D）。在刚跑的 trace 数据最上面，能看到 CPU 的详细数据， CPU 数据的下面是几个可折叠的区域，分别表示不同的活跃进程。每一个色条表示系统的一个行为，色条的长度表示该行为的耗时（放大可以看到更多细节）。 快捷键 作用 w 放大 s 缩小 a 左移 d 右移 f 返回选中区域，且放大选中区域 m 标记当前选定区域 v 高亮 VSync g 切换是否显示 60hz 的网格线 0(零) 恢复trace到初始态 h 切换是否显示详情 / 搜索关键字 enter 显示搜索结果，可通过← →定位搜索结果 ` 显示/隐藏脚本控制台 ? 显示帮助功能 Alerts 一栏标记了以下性能有问题的点，你可以点击该点查看详细信息,右边侧边栏还有一个 Alerts 框，点击可以查看每个类型的 Alerts 的数量。 在每个包下都有 Frame 一栏，该栏中都有一个一个的 F 代表每一个 Frame，用颜色来代表性能的好坏，依次为绿-黄-红(性能越来越差),点击某一个 F,会显示该 Frame 绘制过程中的一些 Alerts 信息，如果你想查看Frame的耗时，可以点击某个 F 标志，然后按 m 键:。 参考资料 脑洞大开：为啥帧率达到 60 fps 就流畅？ Android性能优化之渲染篇 Android性能专项测试-TraceView工具(Device Monitor) Android性能专项测试-Systrace工具 Analyzing UI Performance with Systrace 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
        <tag>UI优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章看明白 Android 系统启动时都干了什么]]></title>
    <url>%2F2017%2F09%2F09%2Fandroid-bootloader%2F</url>
    <content type="text"><![CDATA[Android - 系统启动过程计算机是如何启动的？首先熟悉一些概念，计算机的硬件包括：CPU，内存，硬盘，显卡，显示器，键盘鼠标等其他输入输出设备。 所有的软件（比如：操作系统）都是存放在硬盘上，程序执行时需要将程序从硬盘上读取到内存中然后加载到 CPU 中来运行。 当我们按下开机键时，此时内存中什么都没有，因此需要借助某种方式，将操作系统加载到内存中，而完成这项任务的就是 BIOS。 引导阶段 BIOS: Basic Input/Output System（基本输入输出系统），在 IBM PC 兼容系统上，是一种业界标准的固件接口（来自维基百科）。 BIOS 一般是主板芯片上的一个程序，计算机通电后，第一件事就是读取它。 BIOS 程序首先检查计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为 POST。 如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。 如果没有问题，屏幕就会显示出 CPU，内存，硬盘等信息。 硬件自检完成后，BIOS 把控制权转交给下一阶段的启动程序。 这时 BIOS 需要知道，下一阶段的启动程序到底存放在哪一个设备当中。 也就是说 BIOS 需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。 这种排序叫做启动排序，也就是我们平时进入 BIOS 界面时能看到的 Boot Sequence。 如果我们没有进行特殊操作的话，那么 BIOS 就会按照这个启动顺序将控制权交给下一个存储设备。 我们在使用 U 盘光盘之类的装系统时就是在这里将启动顺序改变了，将本来要移交给硬盘的控制权交给了 U 盘或者光盘。 第一存储设备被激活后，计算机读取该设备的第一个扇区，也就是读取最前面的 512 个字节。 如果这 512 个字节的最后两个字节是 0x55 和 0xAA ，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给“启动顺序”中的下一个设备。 这最前面的 512 个字节，就叫做”主引导记录”（Master boot record，缩写为 MBR）。 主引导记录 MBR 是位于磁盘最前边的一段引导代码。它负责磁盘操作系统对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统在对硬盘进行初始化时产生的。 硬盘的主引导记录 MBR 是不属于任何一个操作系统的，它先于所有的操作系统而被调入内存，并发挥作用，然后才将控制权交给主分区内的操作系统，并用主分区信息表来管理硬盘。 MBR 只有512个字节，放不了太多东西。 它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。 我们找到可用的 MBR 后，计算机从 MBR 中读取前面 446 字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。 加载内核阶段 选择完操作系统后，控制权转交给操作系统，操作系统的内核首先被载入内存。 以 Linux 系统为例，先载入 /boot 目录下面的 kernel。 内核加载成功后，第一个运行的程序是 /sbin/init。 它根据配置文件（Debian 系统是 /etc/initab ）产生 init 进程。 这是 Linux 启动后的第一个进程，pid 进程编号为 1，其他进程都是它的后代。 然后，init 线程加载系统的各个模块，比如：窗口程序和网络程序，直至执行 /bin/login 程序，跳出登录界面，等待用户输入用户名和密码。 至此，全部启动过程完成。 Android 手机的启动过程Android 系统虽然也是基于 Linux 系统的，但是由于 Android 属于嵌入式设备，并没有像 PC 那样的 BIOS 程序。 取而代之的是 Bootloader —— 系统启动加载器。 它类似于 BIOS，在系统加载前，用以初始化硬件设备，建立内存空间的映像图，为最终调用系统内核准备好环境。 在 Android 里没有硬盘，而是 ROM，它类似于硬盘存放操作系统，用户程序等。 ROM 跟硬盘一样也会划分为不同的区域，用于放置不同的程序，在 Android 中主要划分为一下几个分区： /boot：存放引导程序，包括内核和内存操作程序 /system：相当于电脑c盘，存放Android系统及系统应用 /recovery：恢复分区，可以进入该分区进行系统恢复 /data：用户数据区，包含了用户的数据：联系人、短信、设置、用户安装的程序 /cache：安卓系统缓存区，保存系统最常访问的数据和应用程序 /misc：包含一些杂项内容，如系统设置和系统功能启用禁用设置 /sdcard：用户自己的存储区，可以存放照片，音乐，视频等文件 那么 Bootloader 是如何被加载的呢？跟 PC 启动过程类似，当开机通电时首先会加载 Bootloader，Bootloader 会读取 ROM 找到操作系统并将 Linux 内核加载到 RAM 中。 当 Linux 内核启动后会初始化各种软硬件环境，加载驱动程序，挂载根文件系统，Linux 内核加载的最后阶段会启动执行第一个用户空间进程 init 进程。 init 进程 init 是 Linux 系统中用户空间的第一个进程(pid=1)，Kernel 启动后会调用 /system/core/init/Init.cpp 的 main() 方法。 Init.main() 首先初始化 Kernel log，创建一块共享的内存空间，加载 /default.prop 文件，解析 init.rc 文件。 init.rc 文件init.rc 文件是 Android 系统的重要配置文件，位于 /system/core/rootdir/ 目录中。 主要功能是定义了系统启动时需要执行的一系列 action 及执行特定动作、设置环境变量和属性和执行特定的 service。 init.rc 脚本文件配置了一些重要的服务，init 进程通过创建子进程启动这些服务，这里创建的 service 都属于 native 服务，运行在 Linux 空间，通过 socket 向上层提供特定的服务，并以守护进程的方式运行在后台。 通过 init.rc 脚本系统启动了以下几个重要的服务： service_manager：启动 binder IPC，管理所有的 Android 系统服务 mountd：设备安装 Daemon，负责设备安装及状态通知 debuggerd：启动 debug system，处理调试进程的请求 rild：启动 radio interface layer daemon 服务，处理电话相关的事件和请求 media_server：启动 AudioFlinger，MediaPlayerService 和 CameraService，负责多媒体播放相关的功能，包括音视频解码 surface_flinger：启动 SurfaceFlinger 负责显示输出 zygote：进程孵化器，启动 Android Java VMRuntime 和启动 systemserver，负责 Android 应用进程的孵化工作 在这个阶段你可以在设备的屏幕上看到 “Android” logo 了。 以上工作执行完，init 进程就会进入 loop 状态。 service_manager 进程ServiceManager 是 Binder IPC 通信过程中的守护进程，本身也是一个 Binder 服务。ServiceManager 进程主要是启动 Binder，提供服务的查询和注册。 具体过程详见 Binder：Android Binder 进程间通讯 surface_flinger 进程SurfaceFlinger 负责图像绘制，是应用 UI 的核心，其功能是合成所有 Surface 并渲染到显示设备。SurfaceFlinger 进程主要是启动 FrameBuffer，初始化显示系统。 media_server 进程MediaServer 进程主要是启动 AudioFlinger 音频服务，CameraService 相机服务。负责处理音频解析播放，相机相关的处理。 Zygote 进程fork 创建进程过程： Zygote 进程孵化了所有的 Android 应用进程，是 Android Framework 的基础，该进程的启动也标志着 Framework 框架初始化启动的开始。 Zygote 服务进程的主要功能： 注册底层功能的 JNI 函数到虚拟机 预加载 Java 类和资源 fork 并启动 system_server 核心进程 作为守护进程监听处理“孵化新进程”的请求 当 Zygote 进程启动后, 便会执行到 frameworks/base/cmds/app_process/App_main.cpp 文件的 main() 方法。 123App_main.main() //设置进程名，并启动 AppRuntime。AndroidRuntime::start() //创建 Java 虚拟机，注册 JNI 方法，调用 ZygoteInit.main() 方法。ZygoteInit.main() //为 Zygote 注册 socket，预加载类和资源，启动 system_server 进程。 然后 Zygote 进程会进入 loop 状态，等待下次 fork 进程。 system_server 进程system_server 进程 由 Zygote 进程 fork 而来。接下来看下 system_server 启动过程。 1234567891011121314151617181920212223242526//首先会调用 ZygoteInit.startSystemServer() 方法ZygoteInit.startSystemServer() //fork 子进程 system_server，进入 system_server 进程。ZygoteInit.handleSystemServerProcess() //设置当前进程名为“system_server”，创建 PathClassLoader 类加载器。RuntimeInit.zygoteInit() //重定向 log 输出，通用的初始化（设置默认异常捕捉方法，时区等），初始化 Zygote -&gt; nativeZygoteInit()。nativeZygoteInit() //方法经过层层调用，会进入 app_main.cpp 中的 onZygoteInit() 方法。app_main::onZygoteInit()// 启动新 Binder 线程。applicationInit() //方法经过层层调用，会抛出异常 ZygoteInit.MethodAndArgsCaller(m, argv), ZygoteInit.main() 会捕捉该异常。ZygoteInit.main() //开启 DDMS 功能，preload() 加载资源，预加载 OpenGL，调用 SystemServer.main() 方法。SystemServer.main() //先初始化 SystemServer 对象，再调用对象的 run() 方法。SystemServer.run() //准备主线程 looper，加载 android_servers.so 库，该库包含的源码在 frameworks/base/services/ 目录下。 system_server 进程启动后将初始化系统上下文（设置主题），创建系统服务管理 SystemServiceManager，然后启动各种系统服务： 12345678910111213141516171819startBootstrapServices(); // 启动引导服务//该方法主要启动服务 ActivityManagerService，PowerManagerService，LightsService，DisplayManagerService，PackageManagerService，UserManagerService。//设置 ActivityManagerService，启动传感器服务。startCoreServices(); // 启动核心服务//该方法主要//启动服务 BatteryService 用于统计电池电量，需要 LightService。//启动服务 UsageStatsService，用于统计应用使用情况。//启动服务 WebViewUpdateService。startOtherServices(); // 启动其他服务//该方法主要启动服务 InputManagerService，WindowManagerService。//等待 ServiceManager，SurfaceFlinger启动完成，然后显示启动界面。//启动服务 StatusBarManagerService，//准备好 window, power, package, display 服务：// - WindowManagerService.systemReady()// - PowerManagerService.systemReady()// - PackageManagerService.systemReady()// - DisplayManagerService.systemReady() 所有的服务启动完成后会注册到 ServiceManager。ActivityManagerService 服务启动完成后，会进入 ActivityManagerService.systemReady()，然后启动 SystemUI，WebViewFactory，Watchdog，最后启动桌面 Launcher App。 最后会进入循环 Looper.loop()。 ActivityManagerService 启动启动桌面 Launcher App 需要等待 ActivityManagerService 启动完成。我们来看下 ActivityManagerService 启动过程。 12345678910111213141516ActivityManagerService(Context) //创建名为“ActivityManager”的前台线程，并获取mHandler。//通过 UiThread 类，创建名为“android.ui”的线程。//创建前台广播和后台广播接收器。//创建目录 /data/system。//创建服务 BatteryStatsService。ActivityManagerService.start() //启动电池统计服务，创建 LocalService，并添加到 LocalServices。ActivityManagerService.startOtherServices() -&gt; installSystemProviders()//安装所有的系统 Provider。ActivityManagerService.systemReady()//恢复最近任务栏的 task。//启动 WebView，SystemUI，开启 Watchdog，启动桌面 Launcher App。//发送系统广播。 启动桌面 Launcher App，首先会通过 Zygote 进程 fork 一个新进程作为 App 进程，然后创建 Application，创建启动 Activity，最后用户才会看到桌面。 完整启动过程 参考资料 计算机是如何启动的？ 按下电源键之后，电脑又默默干了很多事 Android系统启动-概述 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
        <tag>Bootloader</tag>
        <tag>开机过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章了解相见恨晚的 Android Binder 进程间通讯]]></title>
    <url>%2F2017%2F08%2F08%2Fandroid-binder%2F</url>
    <content type="text"><![CDATA[Android - Binder 进程间通讯概述最近在学习 Binder 机制，在网上查阅了大量的资料，也看了老罗的 Binder 系列的博客和 Innost 的深入理解 Binder 系列的博客，都是从底层开始讲的，全是 C 代码，虽然之前学过 C 和 C++，然而各种函数之间花式跳转，看的我都怀疑人生。 毫不夸张的讲每看一遍都是新的内容，跟没看过一样。 后来又看到了 Gityuan 的博客看到了一些图解仿佛发现了新大陆。 下面就以图解的方式介绍下 Binder 机制，相信你看这篇文章，一定有所收获。 什么是 Binder？Binder 是 Android 系统中进程间通讯（IPC）的一种方式，也是 Android 系统中最重要的特性之一。 Android 中的四大组件 Activity，Service，Broadcast，ContentProvider，不同的 App 等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 理解 Binder 对于理解整个 Android 系统有着非常重要的作用，如果对 Binder 不了解，就很难对 Android 系统机制有更深入的理解。 1. Binder 架构 Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。 Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。 2. Binder 机制 首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。 有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码： 12//获取WindowManager服务引用WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); 获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。 有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。 怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。 3. Binder 驱动我们先来了解下用户空间与内核空间是怎么交互的。 先了解一些概念 用户空间/内核空间详细解释可以参考 Kernel Space Definition； 简单理解如下： Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 系统调用/内核态/用户态虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？ Kernel space can be accessed by user processes only through the use of system calls. 用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。 内核模块/驱动通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。 在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动; 驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作； 驱动就是操作硬件的接口，为了支持 Binder 通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。 熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。 4. Binder 进程与线程 对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。 Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。 5. ServiceManager 启动了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。 ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。 ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。 ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。 6. ServiceManager 注册服务 注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。 事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。 7. ServiceManager 获取服务 获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。 8. 进行一次完整通讯 我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。 首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。 ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。 总结好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。 努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。 网上资料很多，个人觉得比较好的如下： Bander设计与实现 老罗的 Android进程间通信（IPC）机制Binder简要介绍和学习计划 系列 Innost的 深入理解Binder 系列 Gityuan的 Binder系列 (基于 Android 6.0) Binder学习指南 参考资料 Binder系列 Binder学习指南 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
        <tag>Binder</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 多渠道打包最佳实践]]></title>
    <url>%2F2017%2F07%2F07%2Fandroid-flavors%2F</url>
    <content type="text"><![CDATA[Android - Flavors概述该项目演示了在 Android Studio 中使用 gradle 构建渠道包。已更新支持 Android Studio 3.x，Gradle 4.x。 渠道号以友盟 SDK 为例，打包多渠道：GooglePlay，小米，友盟，360，豌豆荚，应用宝。 在 AndroidManifest.xml 中加入渠道区分标识。 123&lt;meta-data android:name="UMENG_CHANNEL" android:value="$&#123;UMENG_CHANNEL_VALUE&#125;" /&gt; 然后在 build.gradle(Module: app) 中加入渠道打包替换对应的 UMENG_CHANNEL_VALUE 代码。 123456789101112131415// 渠道Flavors，配置不同的渠道productFlavors &#123; GooglePlay &#123;&#125; xiaomi &#123;&#125; umeng &#123;&#125; qihu360 &#123;&#125; wandoujia &#123;&#125; yingyongbao &#123;&#125; //其他...&#125;// 批量配置渠道productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]&#125; 自定义 apk 名字我们可以指定不同渠道号生成的 apk 的名字，这样方便打包出来区别哪个 apk 是对应哪个渠道的。 如下命名格式为：渠道名-v版本号-打包时间.apk 123456789101112//打包重命名applicationVariants.all &#123; variant -&gt; if (variant.buildType.name == "release") &#123; variant.outputs.all &#123; output -&gt; def fileName = output.outputFile.name if (fileName.endsWith(".apk")) &#123; def apkName = "$&#123;variant.productFlavors[0].name&#125;-v$&#123;variant.versionName&#125;-$&#123;releaseTime()&#125;.apk"; outputFileName = apkName &#125; &#125; &#125; &#125; 渠道自定义不同的渠道定义不同的 applicationId, versionCode, versionName 123456789101112131415161718192021222324252627282930flavorDimensions "test","test1","test2"//定义渠道productFlavors &#123; main_test &#123; applicationId "com.jeanboy.app.flavors" versionCode rootProject.ext.mainTestVersionCode versionName rootProject.ext.mainTestVersionName //定义manifest中替换值，如：渠道号 resValue("string", "test_app_id", "2017-8-14 12:09:35") //定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), './src/main_test/proguard-rules.pro' dimension "test" &#125; main_test1 &#123; applicationId "com.jeanboy.app.flavorstest1" versionCode rootProject.ext.mainTest1VersionCode versionName rootProject.ext.mainTest1VersionName resValue("string", "test_app_id", "2017-8-14 12:09:35") proguardFiles getDefaultProguardFile('proguard-android.txt'), './src/main_test1/proguard-rules.pro' dimension "test1" &#125; main_test2 &#123; applicationId "com.jeanboy.app.flavorstest2" versionCode rootProject.ext.mainTest2VersionCode versionName rootProject.ext.mainTest2VersionName resValue("string", "test_app_id", "2017-8-14 12:09:35") proguardFiles getDefaultProguardFile('proguard-android.txt'), './src/main_test2/proguard-rules.pro' dimension "test2" &#125;&#125; 不同渠道不同签名文件定义渠道包签名文件 1234567891011121314151617181920signingConfigs &#123; test &#123; storeFile file('../resources/test.jks')//密钥文件位置 storePassword 'test123'//密钥密码 keyAlias 'test'//密钥别名 keyPassword 'test123'//别名密码 &#125; test1 &#123; storeFile file('../resources/test1.jks') storePassword 'test123' keyAlias 'test' keyPassword 'test123' &#125; test2 &#123; storeFile file('../resources/test2.jks') storePassword 'test123' keyAlias 'test' keyPassword 'test123' &#125;&#125; 指定不同渠道使用的签名文件 12345678910111213141516171819202122232425buildTypes &#123; debug &#123; minifyEnabled false shrinkResources false zipAlignEnabled true versionNameSuffix "-debug"//版本命名后缀 buildConfigField "boolean", "LOG_DEBUG", "true" //定义debug时使用的签名文件 signingConfig signingConfigs.test signingConfig signingConfigs.test1 signingConfig signingConfigs.test2 &#125; release &#123; minifyEnabled true//是否开启代码混淆 shrinkResources true//移除无用的资源文件，依赖于minifyEnabled必须一起用 multiDexEnabled true//解决65535 zipAlignEnabled true//对齐zip debuggable false // 是否debug buildConfigField "boolean", "LOG_DEBUG", "false" signingConfig signingConfigs.test signingConfig signingConfigs.test1 signingConfig signingConfigs.test2 &#125;&#125; 不同渠道不同资源文件例如：不同渠道需要不同的应用名 12345678910111213141516171819202122|-app |-src |-main | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors&lt;/string&gt; |-main_test | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors-test&lt;/string&gt; |-main_test1 | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors-test1&lt;/string&gt; |-main_test2 | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors-test2&lt;/string&gt; 在 src 下创建与 main 同级的渠道目录，里面可创建与 main 目录下对应的目录或文件，打包时会以增量或覆盖的方式替换。 res 目录下的文件可以同名覆盖，java 或其他代码目录中类名不允许重复。 编译某个渠道包的时候遵循以下4条准则： 所有的源码(src/*/java)会用来共同编译生成一个 Apk，不允许覆盖，会提示 duplicate class found 所有的 Manifests 都将会合并，这样一来就允许渠道包中可以定义不同的组件与权限，具体可参考官方 Manifest Merger 渠道中的资源会以覆盖或增量的形式与 main 合并，优先级为 Build Type &gt; Product Flavor &gt; Main sourceSet 每个 Build Variant 都会生成自己的 R 文件 第三方 SDK例如：test1 渠道中需要使用某个 SDK，而其他渠道不需要使用。1234567891011android &#123; productFlavors &#123; test1 &#123; &#125; &#125;&#125;...dependencies &#123; provided 'com.xxx.sdk:xxx:1.0'//提供 sdk test1Compile 'com.xxx.sdk:xxx:1.0'//指定 test1 渠道编译&#125; 接下来，需要在代码中使用反射技术判断应用程序是否添加了该SDK，从而决定是否要使用 SDK。部分代码如下： 12345678910111213class MyActivity extends Activity &#123; private boolean useSdk; @override public void onCreate(Bundle savedInstanceState) &#123; try &#123; Class.forName("com.xxx.sdk.XXX"); useSdk = true; &#125; catch (ClassNotFoundException ignored) &#123; &#125; &#125;&#125; 项目地址https://github.com/jeanboydev/Android-Flavors 参考资料美团Android自动化之旅—适配渠道包 Gradle App项目的多渠道打包实现 多渠道打包 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flavors</tag>
        <tag>多渠道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.0 升级指南]]></title>
    <url>%2F2017%2F06%2F15%2Fandroid-update-to-sutdio-3%2F</url>
    <content type="text"><![CDATA[Android Studio 3.0 升级指南Gradle 版本升级 Gradle Plugin 升级到 3.0.0 及以上，修改 project/build.gradle 文件： 123456789101112131415161718buildscript &#123; repositories &#123; ... google()//*增加 &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.1'//*修改 ... &#125;&#125;allprojects &#123; repositories &#123; jcenter() google()//*增加 &#125;&#125; Gradle 升级到 4.1 及以上，修改 project/gradle/gradle-wrapper.properties 文件： 123...//*修改distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip 多渠道 Error:All flavors must now belong to a named flavor dimension.The flavor ‘flavor_name’ is not assigned to a flavor dimension. 3.0 后 Gradle 添加了 flavorDimensions 属性，用来控制多个版本的代码和资源，缺失就会报错。在项目 app 下 build.gradle 文件中，添加 flavorDimensions： 1234567891011121314android &#123; ... flavorDimensions "tier","minApi" productFlavors&#123; fees&#123; dimension "tier" ... &#125; minApi23&#123; dimension "minApi" ... &#125; &#125;&#125; 如果不需要多版本控制只需添加：flavorDimensions “code”： 12345678android &#123; ... defaultConfig &#123; ... flavorDimensions "code" &#125; ...&#125; Gradle 自定义 apk 名称 Error:(88, 0) Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=appDebug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. 之前改 Apk 名字的代码类似： 1234567applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def file = output.outputFile def apkName = 'xxx-xxx-xxx-signed.apk' output.outputFile = new File(file.parent, apkName) &#125;&#125; 由于 outputFile 属性变为只读，需要进行如下修改，直接对 outputFileName 属性赋值即可： 123456applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123;//each 改为 each def apkName = 'xxx-xxx-xxx-signed.apk' outputFileName = apkName//output.outputFile 改为 outputFileName &#125;&#125; 依赖关键字变化 compile： 1234567891011dependencies &#123; ... //3.0 之前 compile 'com.android.support:appcompat-v7:26.1.0' compile fileTree(include: ['*.jar'], dir: 'libs') compile files('libs/gson-2.3.1.jar') //3.0 之后 implementation 'com.android.support:appcompat-v7:26.1.0' implementation fileTree(include: ['*.jar'], dir: 'libs') implementation files('libs/gson-2.3.1.jar')&#125; api: 对应之前的 compile 关键字，功能一模一样。会传递依赖，导致 gradle 编译的时候遍历整颗依赖树 implementation: 对应之前的 compile ，与 api 类似，关键区别是不会有依赖传递 compileOnly: 对应之前的 provided，依赖仅用于编译期不会打包进最终的 apk 中 runtimeOnly: 对应之前的 apk，与上面的 compileOnly 相反 关于 implementation 与 api 的区别，主要在依赖是否会传递上。如：A 依赖 B，B 依赖 C，若使用api则 A 可以引用 C，而 implementation 则不能引用。 这里更推荐用 implementation，一是不会间接的暴露引用，清晰知道目前项目的依赖情况；二是可以提高编译时依赖树的查找速度，进而提升编译速度。 Java 8 支持Gradle 带来了新的 Java 8 兼容方案 desugar，启用方式十分简单，只要在 gradle android 层次之下加入如下代码即可： 1234567android &#123; ... compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 停用 desugar，在 gradle.properties 文件中加入以下代码： 1android.enableDesugar=false 官方文档 - 使用 Java 8 语言功能 AAPT2AAPT2 将默认启用，如果遇到离奇的问题，可以尝试禁用，只要在 gradle.properties 中加入： 1android.enableAapt2=false 参考资料 官方文档 - 迁移到 Android Plugin for Gradle 3.0.0 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 环境下载 Android 源码]]></title>
    <url>%2F2017%2F06%2F06%2Fdownload-android-sources-code-for-windows%2F</url>
    <content type="text"><![CDATA[Windows 环境下载 Android 源码前言Android 官网（该方式不适合 Windows 平台）：https://source.android.com/source/downloading.html 可是我就想在 Windows 中使用 Source Insight 看看源代码，当然可以！ 准备环境 安装 git 安装 Python 自备梯子 硬盘剩余容量最好大于 100G 1. 安装 git官网：https://git-scm.com/downloads/ 图形化工具：https://tortoisegit.org/ 什么？不会安装 git，那还看什么源码！自行百度！ 2. 安装 Python官网：https://www.python.org/downloads/ 安装参考：http://jingyan.baidu.com/article/c910274be14d64cd361d2dd8.html 只需要安装好运行环境即可 3. 自备梯子没有梯子？那就使用清华源：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 下载源码1. 打开 Git Bash，用 git 克隆源代码仓库123git clone https://android.googlesource.com/platform/manifest.git//没有梯子使用清华源git clone https://aosp.tuna.tsinghua.edu.cn/platform/manifest.git 这时 D:/android_source_code/ 目录下会出现一个 manifest 目录，进入此目录，里面除了 git 的配置目录外，clone 下来了一个 default.xml 文件。 2. 切换到想要的源码版本分支去这里 https://source.android.com/source/build-numbers.html#source-code-tags-and-builds 找到想要的版本分支，并复制。 1234cd manifest//没有梯子，使用 git branch -a 查看所有分支，找到想要的分支git branch -agit checkout android-6.0.1_r79 //这里以 6.0 最后一个版本下载 3. 使用 Python 执行脚本进行源代码下载将下面的代码复制，创建文件 python_download.py，并保存。 123456789101112131415161718192021222324252627282930313233import xml.dom.minidomimport osfrom subprocess import call # 1. 修改为源码要保存的路径rootdir = "D:/android_source_code/Android_6_0_1" # 2. 设置 git 安装的路径git = "C:/Develop/Git/bin/git.exe"# 3. 修改为第一步中 manifest 中 default.xml 保存的路径dom = xml.dom.minidom.parse("D:/android_source_code/manifest/default.xml")root = dom.documentElement #prefix = git + " clone https://android.googlesource.com/"# 4. 没有梯子使用清华源下载prefix = git + " clone https://aosp.tuna.tsinghua.edu.cn/"suffix = ".git" if not os.path.exists(rootdir): os.mkdir(rootdir) for node in root.getElementsByTagName("project"): os.chdir(rootdir) d = node.getAttribute("path") last = d.rfind("/") if last != -1: d = rootdir + "/" + d[:last] if not os.path.exists(d): os.makedirs(d) os.chdir(d) cmd = prefix + node.getAttribute("name") + suffix call(cmd) 4. 执行 Python 脚本开始下载打开 Python 客户端 打开上一步保存的 python_download.py 脚本文件 点击 Run-&gt;Run Module 来运行脚本，或直接按F5运行。 静静地等待下载完成吧。 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Source Code</tag>
        <tag>Download</tag>
        <tag>源码下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Handler 消息机制]]></title>
    <url>%2F2017%2F05%2F15%2Fandroid-handler%2F</url>
    <content type="text"><![CDATA[Android - Handler 消息机制概述Android 的消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。 Handler 的主要作用是将某个任务切换到 Handler 所在的线程中去执行。 Handler机制Handler工作流程 Looper 每个线程中最多只能有一个 Looper 对象，由 Looper 来管理此线程里的 MessageQueue (消息队列)。 可以通过 Looper.myLooper() 获取当前线程的 Looper 实例，通过 Looper.getMainLooper() 获取主（UI）线程的 Looper 实例。 Lopper 会以无限循环的形式去查找是否有新消息，如果有就处理消息，否则就一直等待着。 Handler 你可以构造 Handler 对象来与 Looper 沟通，通过 push 发送新消息到 MessageQueue 里；或者通过 handleMessage 接收 Looper 从 MessageQueue 取出来消息。 MessageQueue MessageQueue是一个消息队列，内部存储了一组消息，以队列的形式对外提供插入和删除的工作，内部采用单链表的数据结构来存储消息列表。 ActivityThread 我们经常提到的主线程，也叫UI线程，它就是 ActivityThread，主线程启动会默认初始化一个 Looper 并创建 Handler。 一个线程中只有一个 Looper 实例，一个 MessageQueue 实例，可以有多个 Handler 实例。 ThreadLocal 一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获得数据。 对于 Handler 来说，它需要获取当前线程的 Looper ,而 Looper 的作用于就是线程并且不同的线程具有不同的 Looper ，通过 ThreadLocal 可以轻松实现线程中的存取。 ThreadLocal原理：不同线程访问同一个ThreadLoacl的get方法，ThreadLocal的get方法会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找对应的Value值。 源码分析通过上面分析我们知道使用 Handler 之前必须先调用 Looper.prepare(); 进行初始化，我们先看下 Looper 的源码。 1. Looper 工作原理先看一下 Looper 工作流程 Looper 源码最上面的注释里有一个使用示例如下，可以清晰的看出 Looper 的使用方法。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare();//先初始化 Looper mHandler = new Handler() &#123;//创建 Handler public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop();//启用 Looper 的 loop 方法开启消息轮询 &#125;&#125; 接续看一下 Looper 的完整源码，分析下工作过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public final class Looper &#123; static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //每个线程都会有一个ThreadLocal 用来保存 Looper对象（里面包含了主线程和 MessageQueue） private static Looper sMainLooper; // 主线程的 Looper final MessageQueue mQueue;//保存消息队列 final Thread mThread;//保存主线程 public static void prepare() &#123;//为当前线程创建 Looper prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; //一个线程只能有一个 Looper， 否则抛出异常 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//将创建的 Looper 放入 ThreadLocal &#125; //初始化主线程的 Looper public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; //获取主线程的 Looper public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125; &#125; //在当前线程中开启轮询 public static void loop() &#123; final Looper me = myLooper();//从 ThreadLocal 中取出当前线程的 Looper 对象 if (me == null) &#123; //Looper 没有调用 Looper.prepare() 初始化，抛出异常 throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue;//从 Looper 对象中取出消息队列 for (;;) &#123;//死循环 Message msg = queue.next(); // 不断的取出消息 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); //取出消息的 target (也就是 Handler)，执行分发消息的操作 &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked();//消息已经分发，进行回收操作 &#125; &#125; public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();//从 ThreadLocal 中取出当前线程的 Looper 对象 &#125; private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//创建消息队列 mThread = Thread.currentThread();//保存当前线程 &#125; public void quit() &#123; mQueue.quit(false);//直接退出消息循环，不管是否还有消息 &#125; public void quitSafely() &#123; mQueue.quit(true);//执行完所有的消息，退出消息循环 &#125; ...&#125; 2. MessageQueue 工作原理在 Looper 中创建了 MessageQueue，我们接着看下 MessageQueue 是怎么工作的。 MessageQueue 工作流程 MessageQueue的构造方法。 123456MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //构造函数，quitAllowed 用来标识是否允许退出。 //主线程是不允许退出的（不然会退出整个程序），子线程可以退出。 mPtr = nativeInit();&#125; 然后我们再看一下 MessageQueue.enqueueMessage() 的源码，分析下是怎么添加消息的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 如果消息队列里面没有消息，或者消息的执行时间比里面的消息早，就把这条消息设置成第一条消息。 //一般不会出现这种情况，因为系统一定会有很多消息。 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123;//如果消息队列里面有消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123;//找到消息队列里面的最后一条消息 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;//把消息添加到最后 &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 知道了怎么添加消息，我们再看下 MessageQueue.next() 方法是怎么取出消息的，也就是 Looper.loop() 方法中不断取消息的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages;//拿到当前的消息队列 if (msg != null &amp;&amp; msg.target == null) &#123; //处理异步的消息，暂不讨论 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; //取出一条消息，消息队列往后移动一个 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse();//标记为已使用 return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ... &#125;&#125; 我们知道 MessageQueue 是个链表结构，里面保存的是 Message，我们再看下 Message 是什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class Message implements Parcelable &#123; public int what;//消息类型，标识消息的作用 public int arg1;//整型参数1 public int arg2;//整型参数2 public Object obj;//复杂对象参数 public Messenger replyTo; public int sendingUid = -1; /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;//标记消息已使用 /** If set message is asynchronous */ /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;//标记消息是否异步 /** Flags to clear in the copyFrom method */ /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; /*package*/ int flags;//消息当前标记 /*package*/ long when;//消息执行时间 /*package*/ Bundle data; /*package*/ Handler target;//Handler 用于执行 handleMessage(); /*package*/ Runnable callback;//消息是一个Runnable // sometimes we store linked lists of these things /*package*/ Message next;//下一个消息 private static final Object sPoolSync = new Object();//控制并发访问 private static Message sPool;//消息池 private static int sPoolSize = 0;//消息池数量 private static final int MAX_POOL_SIZE = 50;//消息最大数量 ...&#125; 3. Handler 工作原理在 Message 中我们看到了 target 是一个 Handler，我们看下 Handler 是怎么与 Looper 和 MessageQueue 一起搭配工作的。 看一下 Handler 的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class Handler &#123; public interface Callback &#123; public boolean handleMessage(Message msg); &#125; public void handleMessage(Message msg) &#123;&#125; /** * 消息处理 */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123;//如果消息体是 Runnable 就执行 run() handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //如果创建 Handler 时传入了 Callback，就执行 Callback 里面的逻辑 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg);//如果上述两种都没有实现，就执行 handleMessage 的逻辑 &#125; &#125; public Handler() &#123; this(null, false); &#125; public Handler(Callback callback) &#123; this(callback, false); &#125; public Handler(Looper looper) &#123;//可以指定关联哪个线程的 Looper this(looper, null, false); &#125; public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false); &#125; public Handler(boolean async) &#123; this(null, async); &#125; /** * 主线程调用的构造方法，主线程已经调用了 Looper.prepareMainLooper(); * * @hide */ public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//取出主线程的 Looper if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//把 Handler 的 mQueue 指向 Looper 中的 mQueue mCallback = callback; mAsynchronous = async; &#125; /** * 第二种构造方法，专门给子线程中创建 Handler 时使用的 * * @hide */ public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; //发送 Runnable 消息 public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; //一般更新 UI 时发送的消息，延时时间为0 public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; //发送延时消息 public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; //发送指定时间发送的消息 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; //把字节传入 Message 中一起发送 //Looper 中需要使用 Handler 来执行 dispatchMessage 方法 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125;&#125; 4. ActivityThread 创建默认的 Handler上面说过，ActivityThread 主线程默认是有一个 Handler 的，我们来看一下主线程是怎么创建默认的 Handler 的。 我们看一下 ActivityThread 类中的 main 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser();//准备一些相关环境，给我们的组件启动 // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper();//初始化主线程 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//开启消息轮询，不断取出消息 throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 在 Activity 可以直接用 runOnUiThread() 来使用默认的 Handler 发送消息，我们来看下它是怎么实现的。 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123;//非主线程，发送 Runnable 消息 mHandler.post(action); &#125; else &#123;//在主线程中直接执行 run() action.run(); &#125;&#125; 5. HandlerThread 异步消息处理机制 HandlerThread 继承了 Thread，是一种可以使用 Handler 的 Thread； 在 run 方法中通过 looper.prepare() 来开启消息循环，这样就可以在 HandlerThread 中创建Handler了； 外界可以通过一个 Handler 的消息方式来通知 HandlerThread 来执行具体任务；确定不使用之后，可以通过 quit 或 quitSafely 方法来终止线程执行。 先分析一下 HandlerThread 的源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class HandlerThread extends Thread &#123; //线程的优先级 int mPriority; //线程的id int mTid = -1; //一个与Handler关联的Looper对象 Looper mLooper; public HandlerThread(String name) &#123; super(name); //设置优先级为默认线程 mPriority = android.os.Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; //可重写方法，Looper.loop之前在线程中需要处理的其他逻辑在这里实现 protected void onLooperPrepared() &#123; &#125; //HandlerThread线程的run方法 @Override public void run() &#123; //获取当前线程的id mTid = Process.myTid(); //创建Looper对象 //这就是为什么我们要在调用线程的start()方法后才能得到Looper(Looper.myLooper不为Null) Looper.prepare(); //同步代码块，当获得mLooper对象后，唤醒所有线程 synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; //设置线程优先级 Process.setThreadPriority(mPriority); //Looper.loop之前在线程中需要处理的其他逻辑 onLooperPrepared(); //建立了消息循环 Looper.loop(); //一般执行不到这句，除非quit消息队列 mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; //线程死了 return null; &#125; //同步代码块，正好和上面run方法中同步块对应 //只要线程活着并且mLooper为null，则一直等待 // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; //返回线程id return mTid; &#125;&#125; HandlerThread 使用代码示例 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private HandlerThread mHandlerThread = null; private Handler mThreadHandler = null; private Handler mUiHandler = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandlerThread = new HandlerThread("HandlerWorkThread"); //必须在实例化mThreadHandler之前调运start方法，原因上面源码已经分析了 mHandlerThread.start(); //将当前mHandlerThread子线程的Looper传入mThreadHandler，使得 //mThreadHandler的消息队列依赖于子线程（在子线程中执行） mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, "在子线程中处理！id="+Thread.currentThread().getId()); //从子线程往主线程发送消息 mUiHandler.sendEmptyMessage(0); &#125; &#125;; mUiHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, "在UI主线程中处理！id="+Thread.currentThread().getId()); &#125; &#125;; //从主线程往子线程发送消息 mThreadHandler.sendEmptyMessage(1); &#125;&#125; 总结到此 Handler 消息机制的源码已经分析完了，相信你一定明白了 Handler 消息机制。一句话，每个线程可以创建一个 Looper ，每个 Looper 轮询着一个 MessageQueue 不断取出消息，有消息则回调给 Handler，Handler 负责向 MessageQueue 中发送消息和处理回调的消息来完成线程之间的转换。 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - IPC 多进程]]></title>
    <url>%2F2017%2F05%2F08%2Fandroid-ipc%2F</url>
    <content type="text"><![CDATA[Android - IPC 多进程概述IPC 即 Inter-Process Communication，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。 线程是 CPU 调度的最小单元，是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上是指一个程序或者应用。进程与线程是包含与被包含的关系。一个进程可以包含多个线程。最简单的情况下一个进程只有一个线程，即主线程（例如 Android 的 UI 线程）。 任何操作系统都需要有相应的 IPC 机制。在 Android 中，IPC 的使用场景大概有以下： 有些模块由于特殊原因需要运行在单独的进程中。 通过多进程来获取多份内存空间。 当前应用需要向其他应用获取数据。 1. 开启多进程模式给四大组件在Manifest中指定 android:process 属性。这个属性的值就是进程名。1234&lt;service android:name=".service.RemoteService" android:process=":remote"&gt;&lt;/service&gt; tips：使用 adb shell ps 或 adb shell ps|grep 包名 查看当前所存在的进程信息。 2. 多线程模式的运行机制Android 为每个进程都分配了一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，导致不同的虚拟机访问同一个类的对象会产生多份副本。例如不同进程的 Activity 对静态变量的修改，对其他进程不会造成任何影响。所有运行在不同进程的四大组件，只要它们之间需要通过内存在共享数据，都会共享失败。四大组件之间不可能不通过中间层来共享数据。 多进程会带来以下问题： 静态成员和单例模式完全失效。 线程同步锁机制完全失效。这两点都是因为不同进程不在同一个内存空间下，锁的对象也不是同一个对象。 SharedPreferences 的可靠性下降。SharedPreferences 底层是 通过读/写 XML 文件实现的，并发读/写会导致一定几率的数据丢失。 Application 会多次创建。 由于系统创建新的进程的同时分配独立虚拟机，其实这就是启动一个应用的过程。在多进程模式中，不同进程的组件拥有独立的虚拟机、Application以及内存空间。实现跨进程的方式有很多： Intent传递数据。 共享文件和SharedPreferences。 基于Binder的Messenger和AIDL。 Socket。 3. BinderAndroid 中进程间通讯的核心就是 Binder 机制，强烈建议了解一下 Binder 机制。 Android Binder 进程间通讯 4. Android 中的 IPC 方式主要有以下方式： Intent 中附加 extras 来传递消息 共享文件 Binder 方式 四大组件之一的 ContentProvider Socket 1. 使用Bundle四大组件中的三大组件（Activity、Service、Receiver）都支持在 Intent 中传递 Bundle 数据。Bundle 实现了 Parcelable 接口，**当我们在一个进程中启动了另一个进程的 Activity、Service、Receiver，可以再 Bundle 中附加我们需要传输给远程进程的消息并通过 Intent 发送出去。被传输的数据必须能够被序列化。 2. 使用文件共享一些概念： 两个进程通过读写同一个文件来交换数据。还可以通过 ObjectOutputStream / ObjectInputStream 序列化一个对象到文件中，或者在另一个进程从文件中反序列这个对象。 注意：反序列化得到的对象只是内容上和序列化之前的对象一样，本质是两个对象。 文件并发读写会导致读出的对象可能不是最新的，并发写的话那就更严重了。所以文件共享方式适合对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写问题。 SharedPreferences 底层实现采用XML文件来存储键值对。系统对它的读/写有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对它的读/写变得不可靠，面对高并发读/写时 SharedPreferences 有很大几率丢失数据，因此不建议在IPC中使用 SharedPreferences 。 3. 使用 MessengerMessenger 可以在不同进程间传递 Message 对象。是一种轻量级的 IPC 方案，底层实现是 AIDL。 具体使用时，分为服务端和客户端： 服务端：创建一个 Service 来处理客户端请求，同时创建一个 Handler 并通过它来创建一个Messenger，然后再 Service 的 onBind 中返回 Messenger 对象底层的 Binder 即可。 1private final Messenger mMessenger = new Messenger (new xxxHandler()); 客户端：绑定服务端的 Sevice，利用服务端返回的 IBinder 对象来创建一个 Messenger，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。 总而言之，就是客户端和服务端 拿到对方的 Messenger 来发送 Message 。只不过客户端通过 bindService 而服务端通过 message.replyTo 来获得对方的Messenger。 Messenger中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。 4. 使用 AIDL如果有大量的并发请求，使用 Messenger 就不太适合，同时如果需要跨进程调用服务端的方法，Messenger 就无法做到了。这时我们可以使用AIDL。 流程如下： 服务端需要创建 Service来监听客户端请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在AIDL文件中声明，最后在Service中实现这个AIDL接口即可。 客户端首先绑定服务端的 Service，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，接着就可以调用 AIDL 中的方法了。 注意事项： AIDL 支持的数据类型： 基本数据类型、String、CharSequence List：只支持 ArrayList，里面的每个元素必须被AIDL支持 Map：只支持 HashMap，里面的每个元素必须被AIDL支持 Parcelable 所有的AIDL接口本身也可以在AIDL文件中使用 自定义的 Parcelable 对象和 AIDL 对象，不管它们与当前的 AIDL 文件是否位于同一个包，都必须显式 import 进来。 如果 AIDL 文件中使用了自定义的 Parcelable 对象，就必须新建一个和它同名的 AIDL 文件，并在其中声明它为 Parcelable 类型。 12package com.ryg.chapter_2.aidl;parcelable Book; AIDL接口中的参数除了基本类型以外都必须表明方向in/out。AIDL接口文件中只支持方法，不支持声明静态常量。建议把所有和AIDL相关的类和文件放在同一个包中，方便管理。 1void addBook(in Book book); AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接时，管理数据的集合直接采用 CopyOnWriteArrayList 来进行自动线程同步。类似的还有 ConcurrentHashMap 。 因为客户端的 listener 和服务端的 listener 不是同一个对象，所以 RecmoteCallbackList 是系统专门提供用于删除跨进程 listener 的接口，支持管理任意的 AIDL 接口，因为所有 AIDL 接口都继承自 IInterface 接口。 1public class RemoteCallbackList&lt;E extends IInterface&gt; 它内部通过一个Map接口来保存所有的 AIDL 回调，这个Map的key是 IBinder 类型，value是 Callback 类型。当客户端解除注册时，遍历服务端所有listener，找到和客户端 listener 具有相同 Binder 对象的服务端 listenr 并把它删掉。 客户端 RPC 的时候线程会被挂起，由于被调用的方法运行在服务端的 Binder 线程池中，可能很耗时，不能在主线程中去调用服务端的方法。 5. 使用ContentProvider ContentProvider 是四大组件之一，其底层实现和 Messenger 一样是 Binder。ContentProvider 天生就是用来进程间通信，只需要实现一个自定义或者系统预设置的 ContentProvider，通过 ContentResolver 的 query、update、insert 和 delete 方法即可。 创建 ContentProvider，只需继承 ContentProvider 实现 onCreate 、 query 、 update 、 insert 、 getType 六个抽象方法即可。除了 onCreate 由系统回调并运行在主线程，其他五个方法都由外界调用并运行在Binder线程池中。 6. 使用SocketSocket 可以实现计算机网络中的两个进程间的通信，当然也可以在本地实现进程间的通信。服务端 Service 监听本地端口，客户端连接指定的端口，建立连接成功后，拿到 Socket 对象就可以向服务端发送消息或者接受服务端发送的消息。 5. 具体实现参考代码： https://github.com/jeanboydev/Android-AIDLTest 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Activity LaunchMode 启动模式 & IntentFilter 匹配规则]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid-launch-mode-and-intent-filter%2F</url>
    <content type="text"><![CDATA[Android - Activity LaunchMode 启动模式 &amp; IntentFilter 匹配规则概述每个应用都会有多个 Activity，Android 中使用栈来管理 Activity。 Activity 的启动模式目前有四种：standard、singleTop、singleTask、singleIntance。 Activity 启动模式1. standard 标准模式，也就是系统的默认模式。 每次启动都会重新创建一个实例，不管这个 Activity 在栈中是否已经存在。 谁启动了这个 Activity，那么 Activity 就运行在启动它的那个 Activity 所在的栈中。 用 Application 去启动 Activity 时会报错，提示非 Activity 的 Context没有所谓的任务栈。解决办法是为需要启动的 Activity 指定 FLAG_ACTIVITY_NEW_TASK 标志位，这样就会为它创建一个新的任务栈。 2. singleTop 栈顶复用模式，在这种模式下，如果新 Activity 位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时回调 onNewIntent 方法。 如果新 Activity 已经存在但不是位于栈顶，那么新 Activity 仍然会被创建。 3. singleTask &amp; singleIntance singleTask 栈内复用模式，这是一种单实例模式，在这种模式下，只要 Activity 在栈中存在，那么多次启动这个 Activity 都不会重新创建实例，同时也会回调 onNewIntent 方法。 同时会导致在 Activity 之上的栈内 Activity 出栈。 如果 Activity 不存在重新创建。 singleIntance 单实例模式，这是一种加强的 singleTask 模式。 具有 singleTask 模式的所有特性外，同时具有此模式的 Activity 只能单独的位于一个任务栈中。 4. 其他情况假设目前有2个任务栈，前台任务栈的情况为 AB，而后台任务栈的情况为 CD，这里假设 CD 的启动模式为 singleTask。 现在请求启动 D，那么整个后台的任务栈都会被切换到前台，这个时候整个后退列表变成了 ABCD。 当用户按 back 键的时候，列表中的 Activity 会一一出栈。 5. TaskAffinity 属性TaskAffinity 参数标识了一个 Activity 所需要的任务栈的名字。 为字符串，且中间必须包含包名分隔符“.”。默认情况下，所有 Activity 所需的任务栈名字为应用包名。 TashAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用，其他情况下没有意义。 应用 A 启动了应用 B 的某个 Activity 后，如果 Activity 的 allowTaskReparenting 属性为 true 的话，那么当应用 B 被启动后，此 Activity 会直接从应用 A 的任务栈转移到应用 B 的任务栈中。 打个比方就是，应用 A 启动了应用 B 的 ActivityX，然后按 Home 回到桌面，单击应用 B 的图标，这时并不会启动 B 的主 Activity，而是重新显示已经被应用 A 启动的 ActivityX。 这是因为 ActivityX 的 TaskAffinity 值肯定不和应用 A 的任务栈相同（因为包名不同）。 所以当应用 B被启动以后，发现 ActivityX 原本所需的任务栈已经被创建了，所以把 ActivityX 从 A 的任务栈中转移过来了。 6. 设置启动模式 manifest中 设置下的 android:launchMode 属性。 启动 Activity 的 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 。 两种同时存在时，以第二种为准。 第一种方式无法直接为 Activity 添加 FLAG_ACTIVITY_CLEAR_TOP 标识，第二种方式无法指定 singleInstance 模式。 可以通过命令行 adb shell dumpsys activity 命令查看栈中的 Activity 信息。 Activity 的 Flags这些FLAG可以设定启动模式、可以影响Activity的运行状态。 FLAG_ACTIVITY_CLEAR_TOP具有此标记位的 Activity 启动时，同一个任务栈中位于它上面的 Activity 都要出栈，一般和 FLAG_ACTIVITY_NEW_TASK 配合使用。效果和 singleTask 一样。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS如果设置，新的 Activity 不会在最近启动的 Activity 的列表（就是安卓手机里显示最近打开的 Activity 那个系统级的UI）中保存。 IntentFilter 匹配规则启动Activity分为两种： 显示调用明确指定被启动对象的组件信息，包括包名和类名。 隐式调用不需要明确指定组件信息，需要 Intent 能够匹配目标组件中的 IntentFilter 中所设置的过滤信息。 IntentFilter 中的过滤信息有 action、 category、 data。 只有一个 Intent 同时匹配 action类别、 category类别、 data类别才能成功启动目标 Activity。 一个 Activity 可以有多个 intent-filter ，一个 Intent 只要能匹配任何一组 intent-filter 即可成功启动对应的 Activity。 12345678910111213141516171819202122232425&lt;activity android:name="MainActivity"&gt; &lt;!-- This activity is the main entry, should appear in app launcher --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name="ShareActivity"&gt; &lt;!-- This activity handles "SEND" actions with text data --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; &lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&gt; &lt;data android:mimeType="image/*"/&gt; &lt;data android:mimeType="video/*"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开： ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。 CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。 如果 元素未使用 icon 指定图标，则系统将使用 元素中的图标。 这两个元素必须配对使用，Activity 才会显示在应用启动器中。 第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。 尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent 过滤器之一匹配）的另一应用中直接进入 ShareActivity。 1. action action 是一个字符串。 系统预定义了一些，也可自己定义，区分大小写，例如 android.intent.action.SEND。 一个 intent-filter 可以有多个 aciton，只要 Intent 中的 action 能够和任何一个 action 相同即可成功匹配。匹配是指与 action 的字符串完全一样。 Intent 中如果没有指定 action，那么匹配失败。 2. category category 是一个字符串。 Intent 可以没有 category，但是如果你一旦有 category，不管有几个，每个都能够与 intent-filter 中的其中一个 category 相同。 系统在 startActivity 和 startActivityForResult 的时候，会默认为 Intent 加上 android.intent.category.DEFAULT 这个 category，所以为了我们的 activity能够接收隐式调用，就必须在intent-filter 中加上 android.intent.category.DEFAULT 这个 category。 3. data data 的匹配规则与 action一样，如果 intent-filter 中定义了 data，那么 Intent 中必须要定义可匹配的 data。 intent-filter 中 data 的语法： 1234567 &lt;data android:scheme="string"android:host="string"android:port="string"android:path="string"android:pathPattern="string"android:pathPrefix="string"android:mimeType="string"/&gt; Intent中 的 data 有两部分组成： mimeType 和 URI。 mimeType 是指媒体类型，比如 image/jpeg、audio/mpeg4-generic 和 video/* 等，可以表示图片、文本、视频等不同的媒体格式。 URI 的结构： ://:/[||] ```1234```Java//实际例子content://com.example.project:200/folder/subfolder/etchttp://www.baidu.com:80/search/info scheme：URI 的模式，比如 http、 file、 content 等，默认值是 file 。 host：URI 的主机名 port：URI 的端口号 path、 pathPattern 和 pathPrefix：这三个参数描述路径信息。 path、 pathPattern 可以表示完整的路径信息，其中 pathPattern 可以包含通配符 * ，表示0个或者多个任意字符。 pathPrefix 只表示路径的前缀信息。 Intent 指定 data 时，必须调用 setDataAndType 方法， setData 和 setType 会清除另一方的值。 4. 隐式调用需注意 当通过隐式调用启动 Activity 时，没找到对应的 Activity 系统就会抛出 android.content.ActivityNotFoundException 异常，所以需要判断是否有 Activity 能够匹配我们的隐式 Intent。 采用 PackageManager 的 resloveActivity 方法 12public abstract List&lt;ResolveInfo&gt; queryIntentActivityies(Intent intent, int flags);public abstract ResolveInfo resloveActivity(Intent intent, int flags); 以上的第二个参数使用 MATCH_DEFAULT_ONLY ，这个标志位的含义是仅仅匹配那些在 intent-filter 中声明了 android.intent.category.DEFAULT 这个 category 的 Activity。 因为如果把不含这个 category 的 Activity 匹配出来了，由于不含 DEFAULT 这个 category 的 Activity 是无法接受隐式 Intent 的从而导致 startActivity 失败。 采用 Intent 的 resloveActivity 方法 下面的 action 和 category 用来表明这是一个入口 Activity 并且会出现在系统的应用列表中，二者缺一不可。 12&lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt; 参考资料Google官方开发文档-任务和返回栈Google官方开发文档-Intent 和 Intent 过滤器《Android 开发艺术探索》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>LaunchMode</tag>
        <tag>启动模式</tag>
        <tag>IntentFilter</tag>
        <tag>匹配规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Activity 生命周期]]></title>
    <url>%2F2017%2F04%2F30%2Fandroid-life-cycle%2F</url>
    <content type="text"><![CDATA[Android - Activity 生命周期概述作为四大组件中我们使用最频繁的 Activity，它的生命周期大家都了解。 然而面试中经常问到可见它的重要性。下面从两个方面来分析一下 Activity 的生命周期和一些需要注意的细节。 Activity 生命周期图 典型情况下生命周期分析 一般情况下，当当前 Activity 从不可见重新变为可见状态时，onRestart 方法就会被调用。 当用户打开新的 Activity 或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新 Activity 采用了透明主题，那么 onStop 方法不会被回调。当用户再次回到原来的 Activity 时，回调如下：onRestart -&gt; onStart -&gt; onResume。 onStart 和 onStop 对应，它们是从 Activity 是否可见这个角度来回调的；onPause 和 onResume 方法对应，它们是从 Activity 是否位于前台这个角度来回调的。 从 Activity A 进入到 Activity B ，回调顺序是 onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在 onPause 方法中做重量级的操作。 异常情况下生命周期分析 onSaveInstanceState 方法只会出现在 Activity 被异常终止的情况下，它的调用时机是在 onStop 之前，它和 onPause 方法没有既定的时序关系，可能在它之前，也可能在它之后。 当 Activity 被重新创建的时候，onRestoreInstanceState 会被回调，它的调用时机是 onStart 之后。系统只会在 Activity 即将被销毁并且有机会重新显示的情况下才会去调用 onSaveInstanceState 方法。 当 Activity 在异常情况下需要重新创建时，系统会默认为我们保存当前 Activity 的视图结构，并且在 Activity 重启后为我们恢复这些数据。 比如：文本框中用户输入的数据、 listview 滚动的位置等，这些 view 相关的状态系统都会默认为我们恢复。 具体针对某一个 view 系统能为我们恢复哪些数据可以查看 view 的源码中的 onSaveInstanceState 和 onRestoreInstanceState 方法。 Activity按优先级的分类 前台 Activity &gt; 可见但非前台 Activity &gt; 后台 Activity android:configChanges=”xxx” 属性，常用的主要有下面三个选项： local：设备的本地位置发生了变化，一般指切换了系统语言； keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘； orientation：屏幕方向发生了变化，比如旋转了手机屏幕。 配置了 android:configChanges=”xxx” 属性之后，Activity就不会在对应变化发生时重新创建，而是调用 Activity 的 onConfigurationChanged 方法。 参考资料Google官方开发文档-Activity《Android 开发艺术探索》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>LifeCycle</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 反编译指南]]></title>
    <url>%2F2017%2F04%2F28%2Fdecompile%2F</url>
    <content type="text"><![CDATA[Android - 反编译指南反编译源码1. 使用 dex2jar作用：将 apk 反编译成 java 源码（classes.dex 转化成 jar 文件） dex2jar 下载：https://sourceforge.net/projects/dex2jar 下载最新的 dex2jar 并解压 2. 解压 apk 安装包，将 classes.dex 复制 dex2jar 目录下，执行下面命令1d2j-dex2jar classes.dex Win10 最新 PowerShell 窗口尝试下面命令： 1.\d2j-dex2jar.bat .\classes.dex 3. 得到 classes-dex2jar.jar 使用 jd-gui.exe 打开作用：查看 APK 中 classes.dex 转化成出的 jar 文件，即源码文件 dex2jar 下载：http://jd.benow.ca/ 反编译资源文件1. 使用 apktool作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看 apktool 下载：https://bitbucket.org/iBotPeaches/apktool/downloads/ 下载最新的 apktool 并解压 2. 将 apk 安装包复制到 apktool 目录下，执行命令1java -jar apktool.jar d -f xxx.apk -o res 注意：apktool.bat 与 apktool.jar 文件名为 apktool 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>逆向</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 屏幕适配全攻略]]></title>
    <url>%2F2017%2F04%2F26%2Fmulti-screen-support%2F</url>
    <content type="text"><![CDATA[Android - 屏幕适配全攻略一、Android 屏幕碎片化由于 Android 系统的开发性，任何用户、开发者、OEM厂商、运营商都可以对 Android 进行定制，修改成他们想要的样子。各大厂商、开发者的标准不统一，所以就造成了 Android 系统碎片化。 但是这种“碎片化”到底到达什么程度呢？ 下面这张图片所显示的内容足以充分说明当今 Android 系统碎片化问题的严重性，因为该图片中的每一个矩形都代表着一种 Android 设备。 而随着支持 Android 系统的设备(手机、平板、电视、手表)的增多，设备碎片化、品牌碎片化、系统碎片化、传感器碎片化和屏幕碎片化的程度也在不断地加深。而我们今天要探讨的，则是对我们开发影响比较大的——屏幕的碎片化。 下面这张图是 Android 屏幕尺寸的示意图，在这张图里面，蓝色矩形的大小代表不同尺寸，颜色深浅则代表所占百分比的大小。 而与之相对应的，则是下面这张图。这张图显示了 IOS 设备所需要进行适配的屏幕尺寸和占比。 当然，这张图片只是 4, 4s, 5, 5c, 5s 和平板的尺寸，现在还应该加上新推出的 iphone6 和 plus，但是和 Android 的屏幕碎片化程度相比而言，还是差的太远。 Android屏幕的碎片化如此严重，所以我们不得不进行屏幕的适配，如何面对如此多的屏幕进行适配？下面结合Google官方开发文档讨论下最优的解决方案。 二、术语和概念1. 什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？屏幕尺寸 按屏幕对角测量的实际物理尺寸。单位是英寸(inch)，1英寸 = 2.54厘米。 屏幕分辨率 屏幕上物理像素的总数。单位是 px，1px = 1像素点，一般是纵向像素×横向像素，如1280×720。 每英寸点数 是指每英寸多少点。单位是 dpi，即 “dot per inch” 的缩写，是打印机、鼠标等设备分辨率的单位。 屏幕像素密度 所表示的是每英寸所拥有的像素数量。单位是ppi，即 “Pixel per inch“ 的缩写，每英寸像素点数。针对显示器的设计时，dpi = ppi。 例如：计算Nexus5的屏幕像素密度：屏幕尺寸：4.95 inch、分辨率：1920×1080，屏幕像素密度(ppi)：445 2. 什么是 dp、dip、dpi、sp、px？之间的关系是什么？dip/dp 在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。 Density Independent Pixels(密度无关像素)的缩写。以160dpi为基准，1dp = 1px。单位转换： px = dp * (dpi / 160)。 dpi 屏幕像素密度的单位，“dot per inch” 的缩写 px 像素，物理上的绝对单位 sp Scale-Independent Pixels 的缩写，可以根据文字大小首选项自动进行缩放。 Google 推荐我们使用 12s p以上的大小，通常可以使用 12sp，14sp，18sp，22sp，最好不要使用奇数和小数。 3. 什么是 mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？ 名称 像素密度范围 图片大小 mdpi(中) 120dp~160dp 48×48px hdpi(高) 160dp~240dp 72×72px xhdpi(超高) 240dp~320dp 96×96px xxhdpi(超超高) 320dp~480dp 144×144px xxxhdpi(超超超高) 480dp~640dp 192×192px 在Google官方开发文档中，说明了 mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi = 2：3：4：6：8 的尺寸比例进行缩放。例如，一个图标的大小为 48×48dp，表示在mdpi上，实际大小为 48×48px，在 hdpi 像素密度上，实际尺寸为 mdpi 上的1.5倍，即 72×72px，以此类推。 4. 支持的屏幕范围四种通用尺寸：小、正常、 大 和超大。 六种通用的密度： ldpi（低）~120dpi mdpi（中）~160dpi hdpi（高）~240dpi xhdpi（超高）~320dpi xxhdpi（超超高）~480dpi xxxhdpi（超超超高）~640dpi 屏幕尺寸与屏幕密度对比： 超大屏幕至少为 960dp x 720dp 大屏幕至少为 640dp x 480dp 正常屏幕至少为 470dp x 320dp 小屏幕至少为 426dp x 320dp 三、解决方案 - 支持各种屏幕尺寸1. 使用配置限定符 这里只是展示了常用的一些配置限定符，具体用法和详情请参阅：Google官方开发文档-使用配置限定符 2. 使用 NinePatch(.9) 图片什么是.9图？ NinePatch 是一种 PNG 图像，在其中可定义当视图中的内容超出正常图像边界时 Android 缩放的可拉伸区域。 后缀以 .9.png 结尾，命名格式为：xxx.9.png。如：普通图：ic_launcher.png .9图 为：ic_launcher.9.png 文件位置： res/drawable/filename.9.png 文件名用作资源 ID。 怎么制作.9图？ 使用 Photoshop（不推荐）使用 Android SDK 自带工具，在 …\Android\SDK\tools\ 下名字为 draw9patch 的文件。使用 Android Studio 同上。 draw9patch如图 ： 拉伸区域 红色框区域：表示纵向拉伸的区域，也就是说，当图片需要纵向拉伸的时候它会只指定拉伸红色区域，其他区域在纵向是不会拉伸的。 绿色框区域：表示横向拉伸的区域，也就是说，当图片需要横向拉伸的时候它会只指定拉伸绿色区域，其他区域在横向是不会拉伸的。 显然红色和绿色相交的部分是既会进行横向拉伸也会进行纵向拉伸的。 前景的显示区域 蓝色区域：表示前景能显示的纵向范围。即前景的最上面可以显示到什么地方，最下面可以显示的什么地方。 黄色区域：表示前景能显示的横向范围。即前景的最左边可以显示到什么地方，最右边可以显示的什么地方。 蓝色和黄色相交部分：表示整个前景能显示的区域。一个区域是矩形的，蓝色规定了上下边界，黄色规定了左右边界，两者共同当然也就规定了一个矩形区域。 3.可绘制的资源文件 Drawable 请参考：Google官方开发文档-可绘制对象资源 4. 最佳做法 在 XML 布局文件中指定尺寸时使用 wrap_content、 match_parent 或 dp 单位 。 不要在应用代码中使用硬编码的像素值 。 不要使用 AbsoluteLayout（已弃用） 。 为不同屏幕密度提供替代位图可绘制对象 。 5. 总结 表格里面列出了目前主流的 Android 手机设备分辨率对应的 dpi 缩放级别。一般设计师会以 1920 x 1080 来设计效果图，那么只需要将效果图测量出来的 px值 填入 第6行-px列 中即可自动计算出所需的 dp/sp 的值。通常情况下以 1280 x 720 的效果图来写布局是比较好的方式，因为测量出来的 px值是 dp/sp 的两倍，方便计算。表格下载：Android屏幕适配单位转换.xls 参考资料 https://developer.android.com/guide/practices/screens_support.html?hl=zh-cn#DeclaringTabletLayouts http://blog.jeswang.org/blog/2013/08/07/ppi-vs-dpi-you-shi-yao-qu-bie/ http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023 http://www.cnblogs.com/vanezkw/archive/2012/07/19/2599092.html 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
</search>
