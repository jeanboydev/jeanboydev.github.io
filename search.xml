<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一篇文章看明白 Android PackageManagerService 工作流程</title>
      <link href="/2018/07/17/android-pkms/"/>
      <url>/2018/07/17/android-pkms/</url>
      <content type="html"><![CDATA[<h1 id="Android-PackageMangerService-分析"><a href="#Android-PackageMangerService-分析" class="headerlink" title="Android - PackageMangerService 分析"></a>Android - PackageMangerService 分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PackageManagerService（简称 PKMS），是 Android 系统中核心服务之一，管理着所有跟 package 相关的工作，常见的比如安装、卸载应用。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/android-bootloader.png?raw=true" alt=""></p><p>PackageManagerService 是在 SystemServer 进程中启动的。如不了解 Android 是如何从开机到 Launcher 启动的过程，请先阅读：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-系统启动过程.md" target="_blank" rel="noopener">Android - 系统启动过程</a>。</p><h2 id="PackageManagerService-启动"><a href="#PackageManagerService-启动" class="headerlink" title="PackageManagerService 启动"></a>PackageManagerService 启动</h2><p>SystemServer 启动过程中涉及到的 PKMS 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//启动installer服务</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处于加密状态则仅仅解析核心应用</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>; <span class="comment">// ENCRYPTING_STATE = "trigger_restart_min_framework"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>; <span class="comment">// ENCRYPTED_STATE = "1"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 PKMS 对象【1】</span></span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    <span class="comment">//PKMS是否首次启动</span></span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】</span></span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//启动 MountService，后续 PackageManager 会需要使用</span></span><br><span class="line">    mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);</span><br><span class="line">    <span class="comment">//【3】做 dex 优化。dex 是 Android 上针对 Java 字节码的一种优化技术，可提高运行效率</span></span><br><span class="line">    mPackageManagerService.performBootDexOpt();</span><br><span class="line">    /...  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// phase 500</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】</span></span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个 system_server 进程启动过程，涉及 PKMS 服务的主要几个动作如下，接下来分别讲解每个过程：</p><ul><li>PKMS.main()</li><li>PKMS.performBootDexOpt()</li><li>PKMS.systemReady()</li></ul><h3 id="PKMS-main"><a href="#PKMS-main" class="headerlink" title="PKMS.main()"></a>PKMS.main()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化 PKMS 对象</span></span><br><span class="line">    PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore);</span><br><span class="line">    <span class="comment">//将 package 服务注册到 ServiceManager，这是 binder 服务的常规注册流程</span></span><br><span class="line">    ServiceManager.addService(<span class="string">"package"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的主要功能创建 PKMS 对象，并将其注册到 <code>ServiceManager</code> 中，内部是一个 HashMap 的集合，存储了很多相关的 <code>binder</code> 服务，缓存起来，我们在使用的时候， 会通过 <code>getService(key)</code> 的方式去 <code>map</code>中获取，ServiceManger 工作流程详见：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Binder%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF.md" target="_blank" rel="noopener">Android - Binder 机制</a>。</p><p>关于 PKMS 对象的构造方法很长，分为以下几个阶段，每个阶段会输出相应的 EventLog。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PackageManagerService 启动开始</span></span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());</span><br><span class="line">    <span class="comment">//SDK 版本检查</span></span><br><span class="line">    <span class="keyword">if</span> (mSdkVersion &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"**** ro.build.version.sdk not set!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取开机启动模式</span></span><br><span class="line">    String mode = SystemProperties.get(<span class="string">"ro.bootmode"</span>, <span class="string">"mode"</span>);</span><br><span class="line">    engModeEnable = <span class="string">"engtest"</span>.equals(mode) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    Slog.i(TAG, <span class="string">"engModeEnable: "</span> + engModeEnable + <span class="string">" ,mode:"</span> + mode);</span><br><span class="line">    mContext = context;</span><br><span class="line">    mFactoryTest = factoryTest;<span class="comment">//开机模式</span></span><br><span class="line">    mOnlyCore = onlyCore;<span class="comment">//是否对包做 dex 优化</span></span><br><span class="line">    <span class="comment">//如果编译版本为 eng，则不需要 dex 优化</span></span><br><span class="line">    mNoDexOpt = <span class="string">"eng"</span>.equals(SystemProperties.get(<span class="string">"ro.build.type"</span>));</span><br><span class="line">    <span class="comment">//创建显示尺寸信息</span></span><br><span class="line">    mMetrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">    <span class="comment">//存储系统运行过程中的设置信息</span></span><br><span class="line">    mSettings = <span class="keyword">new</span> Settings();<span class="comment">//【1】</span></span><br><span class="line">    <span class="comment">/*创建 SharedUserSetting 对象并添加到 Settings 的成员变量 mSharedUsers 中，</span></span><br><span class="line"><span class="comment">        在 Android 系统中，多个 package 通过设置 sharedUserId 属性可以运行在同一个进程，共享同一个 UID */</span></span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.system"</span>, Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.phone"</span>, RADIO_UID, ApplicationInfo.FLAG_SYSTEM);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.log"</span>, LOG_UID, ApplicationInfo.FLAG_SYSTEM);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.nfc"</span>, NFC_UID, ApplicationInfo.FLAG_SYSTEM);</span><br><span class="line">    String separateProcesses = SystemProperties.get(<span class="string">"debug.separate_processes"</span>);</span><br><span class="line">    <span class="keyword">if</span> (separateProcesses != <span class="keyword">null</span> &amp;&amp; separateProcesses.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"*"</span>.equals(separateProcesses)) &#123;</span><br><span class="line">            mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</span><br><span class="line">            mSeparateProcesses = <span class="keyword">null</span>;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Running with debug.separate_processes: * (ALL)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mDefParseFlags = <span class="number">0</span>;</span><br><span class="line">            mSeparateProcesses = separateProcesses.split(<span class="string">","</span>);</span><br><span class="line">            Slog.w(TAG, <span class="string">"Running with debug.separate_processes: "</span></span><br><span class="line">                   + separateProcesses);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDefParseFlags = <span class="number">0</span>;</span><br><span class="line">        mSeparateProcesses = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPreInstallDir = <span class="keyword">new</span> File(<span class="string">"/system/preloadapp"</span>);</span><br><span class="line">    <span class="comment">//创建应用安装器</span></span><br><span class="line">    mInstaller = <span class="keyword">new</span> Installer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取屏幕尺寸大小</span></span><br><span class="line">    WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    Display d = wm.getDefaultDisplay();</span><br><span class="line">    d.getMetrics(mMetrics);</span><br><span class="line">    <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">        <span class="comment">// writer</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            <span class="comment">//启动消息处理线程</span></span><br><span class="line">            mHandlerThread.start();</span><br><span class="line">            <span class="comment">//为消息处理线程创建一个消息分发handler</span></span><br><span class="line">            mHandler = <span class="keyword">new</span> PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">            <span class="comment">// dataDir =/data/</span></span><br><span class="line">            File dataDir = Environment.getDataDirectory();</span><br><span class="line">            <span class="comment">// mAppDataDir = /data/data</span></span><br><span class="line">            mAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"data"</span>);</span><br><span class="line">            <span class="comment">// mAsecInternalPath = /data/app-asec</span></span><br><span class="line">            mAsecInternalPath = <span class="keyword">new</span> File(dataDir, <span class="string">"app-asec"</span>).getPath();</span><br><span class="line">            <span class="comment">// mUserAppDataDir = /data/user</span></span><br><span class="line">            mUserAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"user"</span>);</span><br><span class="line">            <span class="comment">// mDrmAppPrivateInstallDir = /data/app-private</span></span><br><span class="line">            mDrmAppPrivateInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app-private"</span>);</span><br><span class="line">            sUserManager = <span class="keyword">new</span> UserManager(mInstaller, mUserAppDataDir);</span><br><span class="line">            <span class="comment">//读取并解析/etc/permissions下的XML文件</span></span><br><span class="line">            readPermissions();</span><br><span class="line">            mRestoredSettings = mSettings.readLPw();</span><br><span class="line">           <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();<span class="comment">//【2】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">    <span class="comment">//暴露私有服务，用于系统组件的使用</span></span><br><span class="line">    LocalServices.addService(PackageManagerInternal.class, </span><br><span class="line"><span class="keyword">new</span> PackageManagerInternalImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚进入构造函数，就会遇到第一个较为复杂的数据结构 <code>Settings</code> 及它的 <code>addSharedUserLPw()</code> 函数。Settings 的作用是管理 Android 系统运行过程中的一些设置信息。到底是哪些信息呢？来看下面的分析。</p><h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><p>先分析 addSharedUserLPw 函数。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mSettings.addSharedUserLPw(<span class="string">"android.uid.system"</span>,<span class="comment">//字符串</span></span><br><span class="line">    Process.SYSTEM_UID, <span class="comment">//系统进程使用的用户id，值为1000</span></span><br><span class="line">    ApplicationInfo.FLAG_SYSTEM<span class="comment">//标志系统 Package</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在进入对addSharedUserLPw 函数的分析前，先介绍一下 SYSTEM_UID 及相关知识。</p><p>Android 系统中 UID/GID 介绍：</p><p>UID 为用户 ID 的缩写，GID 为用户组 ID 的缩写，这两个概念均与 Linux 系统中进程的权限管理有关。一般说来，每一个进程都会有一个对应的 UID（即表示该进程属于哪个 user，不同 user 有不同权限）。一个进程也可分属不同的用户组（每个用户组都有对应的权限）。</p><blockquote><p>提示 Linux 的 UID/GID 还可细分为几种类型，此处我们仅考虑普适意义的 UID/GID。</p></blockquote><p>下面分析 addSharedUserLPw 函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SharedUserSetting <span class="title">addSharedUserLPw</span><span class="params">(String name, <span class="keyword">int</span> uid, <span class="keyword">int</span> pkgFlags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注意这里的参数：name 为字符串”android.uid.system”，uid 为 1000，pkgFlags 为</span></span><br><span class="line"><span class="comment">        ApplicationInfo.FLAG_SYSETM (以后简写为FLAG_SYSTEM)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">//mSharedUsers 是一个 HashMap，key 为字符串，值为 SharedUserSetting 对象</span></span><br><span class="line">    SharedUserSetting s = mSharedUsers.get(name);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.userId == uid) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个新的 SharedUserSettings 对象，并设置的 userId 为 uid</span></span><br><span class="line">    s = <span class="keyword">new</span> SharedUserSetting(name, pkgFlags);</span><br><span class="line">    s.userId = uid;</span><br><span class="line">    <span class="keyword">if</span> (addUserIdLPw(uid, s, name)) &#123;</span><br><span class="line">        mSharedUsers.put(name, s);<span class="comment">//将name与s键值对添加到mSharedUsers中保存</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可知，Settings 中有一个 mSharedUsers 成员，该成员存储的是字符串与 SharedUserSetting 键值对，也就是说以字符串为 key 得到对应的 SharedUserSetting 对象。</p><p>那么 SharedUserSettings 是什么？它的目的是什么？来看一个例子。</p><p>该例子来源于 SystemUI 的 AndroidManifest.xml，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifestxmlns:android="http:</span>//<span class="attr">schemas.android.com</span>/<span class="attr">apk</span>/<span class="attr">res</span>/<span class="attr">android</span>"</span></span><br><span class="line"><span class="tag">       <span class="attr">package</span>=<span class="string">"com.android.systemui"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">coreApp</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:sharedUserId</span>=<span class="string">"android.uid.system"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:process</span>=<span class="string">"system"</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 xml 中，声明了一个名为 <code>android:sharedUserId</code> 的属性，其值为 <code>android.uid.system</code>。 sharedUserId 看起来和 UID 有关，确实如此，它有两个作用：</p><ul><li>两个或多个声明了同一种 sharedUserIds 的 APK 可共享彼此的数据，并且可运行在同一进程中。</li><li>更重要的是，通过声明特定的 sharedUserId，该 APK 所在进程将被赋予指定的 UID。例如，本例中的 SystemUI 声明了 system 的 uid，运行 SystemUI 的进程就可享有 system 用户所对应的权限（实际上就是将该进程的 uid 设置为 system 的 uid）了。</li></ul><blockquote><p>提示：除了在 AndroidManifest.xml 中声明 sharedUserId 外，Apk 在编译时还必须使用对应的证书进行签名。例如，本例的 SystemUI，在其 Android.mk 中需要额外声明 LOCAL_CERTIFICATE := platform，如此，才可获得指定的 UID。</p></blockquote><p>通过以上介绍，我们能了解到如何组织一种数据结构来包括上面的内容。此处有三个关键点需注意：</p><ul><li>XML 中 sharedUserId 属性指定了一个字符串，它是 UID 的字符串描述，故对应数据结构中也应该有这样一个字符串，这样就把代码和 XML 中的属性联系起来了。</li><li>在 Linux 系统中，真正的 UID 是一个整数，所以该数据结构中必然有一个整型变量。</li><li>多个 Package 可声明同一个 sharedUserId，因此该数据结构必然会保存那些声明了相同 sharedUserId的 Package 的某些信息。</li></ul><p>了解了上面三个关键点，再来看 Android 是如何设计相应数据结构的，如图所示。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_pkms/01.png?raw=true" alt=""></p><p>由上图可知：</p><ul><li>Settings 类定义了一个 mSharedUsers 成员，它是一个 HashMap，以字符串（如“android.uid.system”）为Key，对应的 Value 是一个 SharedUserSettings 对象。</li><li>SharedUserSetting 派生自 GrantedPermissions 类，从 GrantedPermissions 类的命名可知，它和权限有关。SharedUserSetting 定义了一个成员变量 packages，类型为 HashSet，用于保存声明了相同 sharedUserId 的 Package 的权限设置信息。</li><li>每个 Package 有自己的权限设置。权限的概念由 PackageSetting 类表达。该类继承自 PackagesettingBase，而 PackageSettingBase 又继承自 GrantedPermissions。</li><li>Settings 中还有两个成员，一个是 mUserIds，另一个是 mOtherUserIds，这两位成员的类型分别是 ArrayList 和 SparseArray。其目的是以 UID 为索引，得到对应的 SharedUserSettings 对象。在一般情况下，以索引获取数组元素的速度，比以 key 获取 HashMap 中元素的速度要快很多。</li></ul><blockquote><p>提示：根据以上对 mUserIds 和 mOtherUserIds 的描述，可知这是典型的以空间换时间的做法。</p></blockquote><p>下边来分析 addUserIdLPw 函数，它的功能就是将 SharedUserSettings 对象保存到对应的数组中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addUserIdLPw</span><span class="params">(<span class="keyword">int</span> uid, Object obj, Objectname)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//uid 不能超出限制。Android 对 UID 进行了分类，应用 APK 所在进程的 UID 从 10000 开始，</span></span><br><span class="line">    <span class="comment">//而系统 APK 所在进程小于 10000</span></span><br><span class="line">    <span class="keyword">if</span> (uid &gt;= PackageManagerService.FIRST_APPLICATION_UID + PackageManagerService.MAX_APPLICATION_UIDS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uid &gt;= PackageManagerService.FIRST_APPLICATION_UID) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = mUserIds.size();</span><br><span class="line">        <span class="comment">//计算索引，其值是 uid 和 FIRST_APPLICATION_UID 的差</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = uid - PackageManagerService.FIRST_APPLICATION_UID;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= N) &#123;</span><br><span class="line">            mUserIds.add(<span class="keyword">null</span>);</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//判断该索引位置的内容是否为空，为空才保存</span></span><br><span class="line">        mUserIds.set(index, obj);<span class="comment">//mUserIds 保存应用 Package 的 UID</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        mOtherUserIds.put(uid, obj);<span class="comment">//系统 Package 的 UID 由 mOtherUserIds 保存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readPermissions"><a href="#readPermissions" class="headerlink" title="readPermissions()"></a>readPermissions()</h3><p>先来分析 readPermissions 函数，从其函数名可猜测到它和权限有关，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readPermissions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向 /system/etc/permission 目录，该目录中存储了和设备相关的一些权限信息</span></span><br><span class="line">    FilelibraryDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"etc/permissions"</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (File f : libraryDir.listFiles()) &#123;</span><br><span class="line">        <span class="comment">//先处理该目录下的非platform.xml文件</span></span><br><span class="line">        <span class="keyword">if</span> (f.getPath().endsWith(<span class="string">"etc/permissions/platform.xml"</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 调用 readPermissionFromXml 解析此 XML 文件</span></span><br><span class="line">        readPermissionsFromXml(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finalFile permFile = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"etc/permissions/platform.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析 platform.xml 文件，看来该文件优先级最高</span></span><br><span class="line">    readPermissionsFromXml(permFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>etc/permissions</code> 目录下保存了一下配置文件：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_pkms/02.png?raw=true" alt=""></p><p>函数 readPermissionsFromXml 使用 PULL 方式解析这些 XML 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readPermissionsFromXml</span><span class="params">(File permFile)</span> </span>&#123;</span><br><span class="line">    FileReader permReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        permReader = <span class="keyword">new</span> FileReader(permFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">        parser.setInput(permReader);</span><br><span class="line">        XmlUtils.beginDocument(parser, <span class="string">"permissions"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            String name = parser.getName();</span><br><span class="line">            <span class="comment">//解析 group 标签，前面介绍的 XML 文件中没有单独使用该标签的地方</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"group"</span>.equals(name)) &#123;</span><br><span class="line">                String gidStr = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"gid"</span>);</span><br><span class="line">                <span class="keyword">if</span> (gidStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> gid = Integer.parseInt(gidStr);</span><br><span class="line">                    <span class="comment">//转换 XML 中的 gi d字符串为整型，并保存到 mGlobalGids 中</span></span><br><span class="line">                    mGlobalGids = appendInt(mGlobalGids, gid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"permission"</span>.equals(name)) &#123;<span class="comment">//解析 permission 标签</span></span><br><span class="line">                String perm = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                perm = perm.intern();</span><br><span class="line">                <span class="comment">//调用 readPermission 处理</span></span><br><span class="line">                readPermission(parser, perm);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"assign-permission"</span>.equals(name)) &#123;<span class="comment">//下面解析的是assign-permission标签</span></span><br><span class="line">                String perm = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                String uidStr = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"uid"</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//如果是 assign-permission，则取出 uid 字符串，然后获得 Linux 平台上</span></span><br><span class="line">                <span class="comment">//的整型 uid 值</span></span><br><span class="line">                <span class="keyword">int</span> uid = Process.getUidForName(uidStr);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                perm = perm.intern();</span><br><span class="line">                <span class="comment">//和 assign 相关的信息保存在 mSystemPermissions 中</span></span><br><span class="line">                HashSet&lt;String&gt; perms = mSystemPermissions.get(uid);</span><br><span class="line">                <span class="keyword">if</span> (perms == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    perms = newHashSet &lt; String &gt; ();</span><br><span class="line">                    mSystemPermissions.put(uid, perms);</span><br><span class="line">                &#125;</span><br><span class="line">                perms.add(perm);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"library"</span>.equals(name)) &#123;<span class="comment">//解析 library 标签</span></span><br><span class="line">                String lname = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">                String lfile = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"file"</span>);</span><br><span class="line">                <span class="keyword">if</span> (lname == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lfile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//将 XML 中的 name 和 library 属性值存储到 mSharedLibraries 中</span></span><br><span class="line">                    mSharedLibraries.put(lname, lfile);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"feature"</span>.equals(name)) &#123;<span class="comment">//解析 feature 标签</span></span><br><span class="line">                String fname = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//在 XML 中定义的 feature 由 FeatureInfo 表达</span></span><br><span class="line">                    FeatureInfo fi = newFeatureInfo();</span><br><span class="line">                    fi.name = fname;</span><br><span class="line">                    <span class="comment">//存储 feature 名和对应的 FeatureInfo 到 mAvailableFeatures 中</span></span><br><span class="line">                    mAvailableFeatures.put(fname, fi);</span><br><span class="line">                &#125;<span class="comment">//...</span></span><br><span class="line">            &#125; <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readPermissions 函数就是将 XML 中的标签转换成对应的数据结构。</p><h3 id="readLPw"><a href="#readLPw" class="headerlink" title="readLPw()"></a>readLPw()</h3><p>readLPw 函数的功能也是解析文件，不过这些文件的内容却是在 PKMS 正常启动后生成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Settings() &#123;</span><br><span class="line">    FiledataDir = Environment.getDataDirectory();</span><br><span class="line">    FilesystemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);<span class="comment">//指向/data/system目录</span></span><br><span class="line">    systemDir.mkdirs();<span class="comment">//创建该目录</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        一共有 5 个文件，packages.xml 和 packages-backup.xml 为一组，用于描述系统中</span></span><br><span class="line"><span class="comment">        所安装的 Package 的信息，其中 backup 是临时文件。PKMS 先把数据写到 backup 中，</span></span><br><span class="line"><span class="comment">        信息都写成功后再改名成非 backup 的文件。其目的是防止在写文件过程中出错，导致信息丢失。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        packages-stopped.xml 和 packages-stopped-backup.xml 为一组，用于描述系统中</span></span><br><span class="line"><span class="comment">        强制停止运行的 pakcage 的信息，backup 也是临时文件。如果此处存在该临时文件，表明</span></span><br><span class="line"><span class="comment">        此前系统因为某种原因中断了正常流程 packages.list 列出当前系统中应用级（即UID大于10000）Package 的信息</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    mSettingsFilename = <span class="keyword">new</span> File(systemDir, <span class="string">"packages.xml"</span>);</span><br><span class="line">    mBackupSettingsFilename = <span class="keyword">new</span> File(systemDir, <span class="string">"packages-backup.xml"</span>);</span><br><span class="line">    mPackageListFilename = <span class="keyword">new</span> File(systemDir, <span class="string">"packages.list"</span>);</span><br><span class="line">    mStoppedPackagesFilename = <span class="keyword">new</span> File(systemDir, <span class="string">"packages-stopped.xml"</span>);</span><br><span class="line">    mBackupStoppedPackagesFilename = <span class="keyword">new</span> File(systemDir, <span class="string">"packages-stopped-backup.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 5 个文件共分为三组，这里简单介绍一下这些文件的来历（不考虑临时的 backup 文件）。</p><ul><li>packages.xml： PKMS 扫描完目标文件夹后会创建该文件。当系统进行程序安装、卸载和更新等操作时，均会更新该文件。该文件保存了系统中与 package 相关的一些信息。</li><li>packages.list：描述系统中存在的所有非系统自带的 APK 的信息。当这些程序有变动时，PKMS 就会更新该文件。</li><li>packages-stopped.xml：从系统自带的设置程序中进入应用程序页面，然后在选择强制停止（ForceStop）某个应用时，系统会将该应用的相关信息记录到此文件中。也就是该文件保存系统中被用户强制停止的 Package 的信息。</li></ul><p>readLPw 的函数功能就是解析其中的 XML 文件的内容，然后建立并更新对应的数据结构。例如，停止的 package 重启之后依然是 stopped 状态。</p><h3 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h3><p>PKMS 构造函数在第一阶段的工作，主要是扫描并解析 XML 文件，将其中的信息保存到特定的数据结构中。</p><p>第一阶段扫描的 XML 文件与权限及上一次扫描得到的 Package 信息有关，它为 PKMS 下一阶段的工作提供了重要的参考信息。</p><h3 id="扫描-Package"><a href="#扫描-Package" class="headerlink" title="扫描 Package"></a>扫描 Package</h3><p>PKMS 构造函数第二阶段的工作就是扫描系统中的 APK 了。由于需要逐个扫描文件，因此手机上装的程序越多，PKMS 的工作量越大，系统启动速度也就越慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">mRestoredSettings = mSettings.readLPw();<span class="comment">//接第一段的结尾</span></span><br><span class="line">longstartTime = SystemClock.uptimeMillis();<span class="comment">//记录扫描开始的时间</span></span><br><span class="line"><span class="comment">//定义扫描参数</span></span><br><span class="line">intscanMode = SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX;</span><br><span class="line"><span class="keyword">if</span> (mNoDexOpt) &#123;</span><br><span class="line">    scanMode |= SCAN_NO_DEX; <span class="comment">//在控制扫描过程中是否对 APK 文件进行 dex 优化</span></span><br><span class="line">&#125;</span><br><span class="line">finalHashSet&lt;String&gt; libFiles = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="comment">// mFrameworkDir指向/system/frameworks目录</span></span><br><span class="line">mFrameworkDir = newFile(Environment.getRootDirectory(), <span class="string">"framework"</span>);</span><br><span class="line"><span class="comment">// mDalvikCacheDir指向/data/dalvik-cache目录</span></span><br><span class="line">mDalvikCacheDir = <span class="keyword">new</span> File(dataDir, <span class="string">"dalvik-cache"</span>);</span><br><span class="line">booleandidDexOpt = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  获取 Java 启动类库的路径，在 init.rc 文件中通过 BOOTCLASSPATH 环境变量输出，该值如下</span></span><br><span class="line"><span class="comment">  /system/framework/core.jar:/system/frameworks/core-junit.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/bouncycastle.jar:/system/frameworks/ext.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/framework.jar:/system/frameworks/android.policy.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/services.jar:/system/frameworks/apache-xml.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/filterfw.jar</span></span><br><span class="line"><span class="comment">  该变量指明了 framework 所有核心库及文件位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StringbootClassPath = System.getProperty(<span class="string">"java.boot.class.path"</span>);</span><br><span class="line"><span class="keyword">if</span> (bootClassPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String[] paths = splitString(bootClassPath, <span class="string">':'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">//判断该 jar 包是否需要重新做 dex 优化</span></span><br><span class="line">            <span class="keyword">if</span> (dalvik.system.DexFile.isDexOptNeeded(paths[i])) &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               将该 jar 包文件路径保存到 libFiles 中，然后通过 mInstall 对象发送</span></span><br><span class="line"><span class="comment">               命令给 installd，让其对该 jar 包进行 dex 优化</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                libFiles.add(paths[i]);</span><br><span class="line">                mInstaller.dexopt(paths[i], Process.SYSTEM_UID, <span class="keyword">true</span>);</span><br><span class="line">                didDexOpt = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">还记得 mSharedLibrarires 的作用吗？它保存的是 platform.xml 中声明的系统库的信息。</span></span><br><span class="line"><span class="comment">这里也要判断系统库是否需要做 dex 优化。处理方式同上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (mSharedLibraries.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将 framework-res.apk 添加到 libFiles 中。framework-res.apk 定义了系统常用的</span></span><br><span class="line"><span class="comment">//资源，还有几个重要的 Activity，如长按 Power 键后弹出的选择框</span></span><br><span class="line">libFiles.add(mFrameworkDir.getPath() + <span class="string">"/framework-res.apk"</span>);</span><br><span class="line"><span class="comment">//列举 /system/frameworks 目录中的文件</span></span><br><span class="line">String[] frameworkFiles = mFrameworkDir.list();</span><br><span class="line"><span class="keyword">if</span> (frameworkFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 判断该目录下的 apk 或 jar 文件是否需要做 dex 优化。处理方式同上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码对系统库（BOOTCLASSPATH 指定，或 platform.xml 定义，或</span></span><br><span class="line"><span class="comment">/system/frameworks目录下的 jar 包与 apk 文件）进行一次仔细检查，该优化的一定要优化。</span></span><br><span class="line"><span class="comment">如果发现期间对任何一个文件进行了优化，则设置 didDexOpt 为 true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (didDexOpt) &#123;</span><br><span class="line">    String[] files = mDalvikCacheDir.list();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果前面对任意一个系统库重新做过 dex 优化，就需要删除 cache 文件。原因和</span></span><br><span class="line"><span class="comment">        dalvik 虚拟机的运行机制有关。暂不探讨 dex 及 cache 文件的作用。</span></span><br><span class="line"><span class="comment">        从删除 cache 文件这个操作来看，这些 cache 文件应该使用了 dex 优化后的系统库</span></span><br><span class="line"><span class="comment">        所以当系统库重新做 dex 优化后，就需要删除旧的 cache 文件。可简单理解为缓存失效</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            String fn = files[i];</span><br><span class="line">            <span class="keyword">if</span> (fn.startsWith(<span class="string">"data@app@"</span>) || fn.startsWith(<span class="string">"data@app-private@"</span>)) &#123;</span><br><span class="line">                (newFile(mDalvikCacheDir, fn)).delete();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空 cache 文件后，PKMS 终于进入重点段了。接下来看 PKMS 第二阶段工作的核心内容，即扫描 Package。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件夹监控对象，监视 /system/frameworks 目录。利用了 Linux 平台的 notify 机制</span></span><br><span class="line">mFrameworkInstallObserver = <span class="keyword">new</span> AppDirObserver(mFrameworkDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</span><br><span class="line">mFrameworkInstallObserver.startWatching();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 调用 scanDirLI 函数扫描 /system/frameworks 目录，这个函数很重要，稍后会再分析。</span></span><br><span class="line"><span class="comment"> 注意，在第三个参数中设置了SCAN_NO_DEX标志，因为该目录下的package在前面的流程</span></span><br><span class="line"><span class="comment"> 中已经过判断并根据需要做过dex优化了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode | SCAN_NO_DEX, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建文件夹监控对象，监视 /system/app 目录</span></span><br><span class="line">mSystemAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"app"</span>);</span><br><span class="line">mSystemInstallObserver = <span class="keyword">new</span> AppDirObserver(mSystemAppDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</span><br><span class="line">mSystemInstallObserver.startWatching();</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描 /system/app 下的 package</span></span><br><span class="line">scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监视并扫描 /vendor/app 目录</span></span><br><span class="line">mVendorAppDir = <span class="keyword">new</span> File(<span class="string">"/vendor/app"</span>);</span><br><span class="line">mVendorInstallObserver = <span class="keyword">new</span> AppDirObserver(mVendorAppDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</span><br><span class="line">mVendorInstallObserver.startWatching();</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描 /vendor/app 下的 package</span></span><br><span class="line">scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//和 installd 交互。以后单独分析 installd</span></span><br><span class="line">mInstaller.moveFiles();</span><br></pre></td></tr></table></figure><p>由以上代码可知，PKMS 将扫描以下几个目录。</p><ul><li>/system/frameworks：该目录中的文件都是系统库，例如：framework.jar、services.jar、framework-res.apk。不过 scanDirLI 只扫描APK文件，所以 framework-res.apk 是该目录中唯一“受宠”的文件。</li><li>/system/app：该目录下全是默认的系统应用，例如：Browser.apk、SettingsProvider.apk 等。</li><li>/vendor/app：该目录中的文件由厂商提供，即厂商特定的 APK 文件，不过目前市面上的厂商都把自己的应用放在 /system/app 目录下。</li></ul><p>PKMS 调用 scanDirLI 函数进行扫描，下面来分析此函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File dir, <span class="keyword">int</span> flags, <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    String[] files = dir.list();<span class="comment">//列举该目录下的文件</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(dir, files[i]);</span><br><span class="line">        <span class="keyword">if</span> (!isPackageFilename(files[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//根据文件名后缀，判断是否为APK 文件。这里只扫描APK 文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            调用scanPackageLI函数扫描一个特定的文件，返回值是PackageParser的内部类</span></span><br><span class="line"><span class="comment">            Package，该类的实例代表一个APK文件，所以它就是和APK文件对应的数据结构</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        PackageParser.Package pkg = scanPackageLI(file,</span><br><span class="line">                                                  flags | PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime);</span><br><span class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span> &amp;&amp; (flags &amp; PackageParser.PARSE_IS_SYSTEM) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line">            <span class="comment">//注意此处flags的作用，只有非系统Package扫描失败，才会删除该文件</span></span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来分析 scanPackageLI 函数。PKMS 中有两个同名的 scanPackageLI 函数，后面会一一见到。先来看第一个也是最先碰到的 scanPackageLI 函数。</p><h3 id="scanPackageLI"><a href="#scanPackageLI" class="headerlink" title="scanPackageLI()"></a>scanPackageLI()</h3><p>首次相遇的 scanPackageLI 函数的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(FilescanFile, <span class="keyword">int</span> parseFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    mLastScanError = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">    StringscanPath = scanFile.getPath();</span><br><span class="line">    parseFlags |= mDefParseFlags;<span class="comment">//默认的扫描标志，正常情况下为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个 PackageParser 对象</span></span><br><span class="line">    PackageParser pp = <span class="keyword">new</span> PackageParser(scanPath);</span><br><span class="line">    pp.setSeparateProcesses(mSeparateProcesses);<span class="comment">// mSeparateProcesses 为空</span></span><br><span class="line">    pp.setOnlyCoreApps(mOnlyCore);<span class="comment">// mOnlyCore 为 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">           调用 PackageParser 的 parsePackage 函数解析APK文件。注意，这里把代表屏幕</span></span><br><span class="line"><span class="comment">           信息的 mMetrics 对象也传了进去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    finalPackageParser.Package pkg = pp.parsePackage(scanFile,</span><br><span class="line">                                                     scanPath, mMetrics, parseFlags);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PackageSetting ps = <span class="keyword">null</span>;</span><br><span class="line">    PackageSetting updatedPkg;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里略去一大段代码，主要是关于 Package 升级方面的工作。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//收集签名信息，这部分内容涉及 signature。</span></span><br><span class="line">    <span class="keyword">if</span> (!collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要设置 PARSE_FORWARD_LOCK 标志，这个标志针对资源文件和 Class 文件</span></span><br><span class="line">    <span class="comment">//不在同一个目录的情况。目前只有 /vendor/app 目录下的扫描会使用该标志。这里不讨论</span></span><br><span class="line">    <span class="comment">//这种情况。</span></span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span> &amp;&amp; !ps.codePath.equals(ps.resourcePath))</span><br><span class="line">        parseFlags |= PackageParser.PARSE_FORWARD_LOCK;</span><br><span class="line"></span><br><span class="line">    String codePath = <span class="keyword">null</span>;</span><br><span class="line">    String resPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//...//这里不考虑 PARSE_FORWARD_LOCK的情况。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resPath = pkg.mScanPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codePath = pkg.mScanPath;<span class="comment">//mScanPath 指向该 APK 文件所在位置</span></span><br><span class="line">    <span class="comment">//设置文件路径信息，codePath 和 resPath 都指向 APK 文件所在位置</span></span><br><span class="line">    setApplicationInfoPaths(pkg, codePath, resPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用第二个 scanPackageLI 函数</span></span><br><span class="line">    <span class="keyword">return</span> scanPackageLI(pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE,</span><br><span class="line">                         currentTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanPackageLI 函数首先调用 PackageParser 对 APK 文件进行解析。根据前面的介绍可知，PackageParser 完成了从物理文件到对应数据结构的转换。下面来分析这个 PackageParser。</p><h3 id="PackageParser"><a href="#PackageParser" class="headerlink" title="PackageParser"></a>PackageParser</h3><p>PackageParser 主要负责 APK 文件的解析，即解析 APK 文件中的 AndroidManifest.xml 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parsePackage</span><span class="params">(File sourceFile, String destCodePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                DisplayMetrics metrics, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    mParseError = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">    mArchiveSourcePath = sourceFile.getPath();</span><br><span class="line">    <span class="comment">//...//检查是否为 APK 文件</span></span><br><span class="line">    XmlResourceParser parser = <span class="keyword">null</span>;</span><br><span class="line">    AssetManager assmgr = <span class="keyword">null</span>;</span><br><span class="line">    Resources res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> assetError = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assmgr = <span class="keyword">new</span> AssetManager();</span><br><span class="line">        <span class="keyword">int</span> cookie = assmgr.addAssetPath(mArchiveSourcePath);</span><br><span class="line">        <span class="keyword">if</span> (cookie != <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="keyword">new</span> Resources(assmgr, metrics, <span class="keyword">null</span>);</span><br><span class="line">            assmgr.setConfiguration(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, Build.VERSION.RESOURCES_SDK_INT);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              获得一个 XML 资源解析对象，该对象解析的是 APK 中的 AndroidManifest.xml 文件。</span></span><br><span class="line"><span class="comment">              以后再讨论 AssetManager、Resource 及相关的知识</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            parser = assmgr.openXmlResourceParser(cookie,</span><br><span class="line">                                                  ANDROID_MANIFEST_FILENAME);</span><br><span class="line">            assetError = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="comment">//...//出错处理</span></span><br><span class="line">        String[] errorText = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">        Package pkg = <span class="keyword">null</span>;</span><br><span class="line">        Exception errorException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用另外一个 parsePackage 函数</span></span><br><span class="line">            pkg = parsePackage(res, parser, flags, errorText);</span><br><span class="line">        &#125;<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//...//错误处理</span></span><br><span class="line">        parser.close();</span><br><span class="line">        assmgr.close();</span><br><span class="line">        <span class="comment">//保存文件路径，都指向 APK 文件所在的路径</span></span><br><span class="line">        pkg.mPath = destCodePath;</span><br><span class="line">        pkg.mScanPath = mArchiveSourcePath;</span><br><span class="line">        pkg.mSignatures = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pkg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中调用了另一个同名的 parsePackage 函数，此函数内容较长，但功能单一，就是解析 AndroidManifest.xml 中的各种标签，这里只提取其中相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parsePackage</span><span class="params">(Resources res, XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    AttributeSet attrs = parser;</span><br><span class="line">    mParseInstrumentationArgs = <span class="keyword">null</span>;</span><br><span class="line">    mParseActivityArgs = <span class="keyword">null</span>;</span><br><span class="line">    mParseServiceArgs = <span class="keyword">null</span>;</span><br><span class="line">    mParseProviderArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//得到 Package 的名字，其实就是得到 AndroidManifest.xml 中 package 属性的值，</span></span><br><span class="line">    <span class="comment">//每个 APK 都必须定义该属性</span></span><br><span class="line">    String pkgName = parsePackageName(parser, attrs, flags, outError);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//以 pkgName 名字为参数，创建一个 Package 对象。后面的工作就是解析 XML 并填充</span></span><br><span class="line">    <span class="comment">//该 Package 信息</span></span><br><span class="line">    <span class="keyword">final</span> Package pkg = <span class="keyword">new</span> Package(pkgName);</span><br><span class="line">    <span class="keyword">boolean</span> foundApp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//...//下面开始解析该文件中的标签，由于这段代码功能简单，所以这里仅列举相关函数</span></span><br><span class="line">    <span class="keyword">while</span> (如果解析未完成) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        StringtagName = parser.getName(); <span class="comment">//得到标签名</span></span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">"application"</span>)) &#123;</span><br><span class="line">            <span class="comment">//...//解析 application 标签</span></span><br><span class="line">            parseApplication(pkg, res, parser, attrs, flags, outError);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"permission-group"</span>)) &#123;</span><br><span class="line">            <span class="comment">//...//解析 permission-group 标签</span></span><br><span class="line">            parsePermissionGroup(pkg, res, parser, attrs, outError);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"permission"</span>)) &#123;</span><br><span class="line">            <span class="comment">//...//解析 permission 标签</span></span><br><span class="line">            parsePermission(pkg, res, parser, attrs, outError);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"uses-permission"</span>)) &#123;</span><br><span class="line">            <span class="comment">//从 XML 文件中获取 uses-permission 标签的属性</span></span><br><span class="line">            sa = res.obtainAttributes(attrs,</span><br><span class="line">                    com.android.internal.R.styleable.AndroidManifestUsesPermission);</span><br><span class="line">            <span class="comment">//取出属性值，也就是对应的权限使用声明</span></span><br><span class="line">            String name = sa.getNonResourceString(com.android.internal.</span><br><span class="line">                    R.styleable.AndroidManifestUsesPermission_name);</span><br><span class="line">            <span class="comment">//添加到 Package 的 requestedPermissions 数组</span></span><br><span class="line">            <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; !pkg.requestedPermissions.contains(name)) &#123;</span><br><span class="line">                pkg.requestedPermissions.add(name.intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"uses-configuration"</span>)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                该标签用于指明本 package 对硬件的一些设置参数，目前主要针对输入设备（触摸屏、键盘</span></span><br><span class="line"><span class="comment">                等）。游戏类的应用可能对此有特殊要求。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            ConfigurationInfocPref = <span class="keyword">new</span> ConfigurationInfo();</span><br><span class="line">            <span class="comment">//...//解析该标签所支持的各种属性</span></span><br><span class="line">            pkg.configPreferences.add(cPref);<span class="comment">//保存到 Package 的 configPreferences 数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...//对其他标签解析和处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码展示了 AndroidManifest.xml 解析的流程，其中比较重要的函数是 parserApplication，它用于解析 application 标签及其子标签（Android 的四大组件在 application 标签中已声明）。</p><p>PackageParser 及其内部重要成员的信息。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_pkms/03.png?raw=true" alt=""></p><ul><li>PackageParser 定了相当多的内部类，这些内部类的作用就是保存对应的信息。解析 AndroidManifest.xml 文件得到的信息由 Package 保存。从该类的成员变量可看出，和 Android 四大组件相关的信息分别由 activites、receivers、providers、services 保存。由于一个 APK 可声明多个组件，因此 activites 和 receiver s等均声明为 ArrayList。</li><li>以 PackageParser.Activity 为例，它从 Component<activityintentinfo> 派生。Component 是一个模板类，元素类型是 ActivityIntentInfo，此类的顶层基类是 IntentFilter。PackageParser.Activity 内部有一个 ActivityInfo 类型的成员变量，该变量保存的就是四大组件中 Activity 的信息。细心的读者可能会有疑问，为什么不直接使用 ActivityInfo，而是通过 IntentFilter 构造出一个使用模板的复杂类型 PackageParser.Activity 呢？原来，Package 除了保存信息外，还需要支持 Intent 匹配查询。例如，设置 Intent 的 Action 为某个特定值，然后查找匹配该 Intent 的 Activity。由于 ActivityIntentInfo 是从 IntentFilter 派生的，因此它它能判断自己是否满足该 Intent 的要求，如果满足，则返回对应的 ActivityInfo。</activityintentinfo></li><li>PackageParser 定了一个轻量级的数据结构 PackageLite，该类仅存储 Package 的一些简单信息。我们在介绍 Package 安装的时候，会遇到  PackageLite。</li></ul><p>在 PackageParser 扫描完一个 APK 后，此时系统已经根据该 APK 中 AndroidManifest.xml，创建了一个完整的 Package 对象，下一步就是将该 Package 加入到系统中。此时调用的函数就是另外一个 scanPackageLI，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.PackagescanPackageLI(</span><br><span class="line">    PackageParser.Package pkg, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime) &#123;</span><br><span class="line">    FilescanFile = <span class="keyword">new</span> File(pkg.mScanPath);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mScanningPath = scanFile;</span><br><span class="line">    <span class="comment">//设置 package 对象中 applicationInfo 的 flags 标签，用于标示该 Package 为系统</span></span><br><span class="line">    <span class="comment">//Package</span></span><br><span class="line">    <span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面这句 if 判断极为重要，见下面的解释</span></span><br><span class="line">    <span class="keyword">if</span> (pkg.packageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAndroidApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">                mPlatformPackage = pkg;</span><br><span class="line">                pkg.mVersionCode = mSdkVersion;</span><br><span class="line">                mAndroidApplication = pkg.applicationInfo;</span><br><span class="line">                mResolveActivity.applicationInfo = mAndroidApplication;</span><br><span class="line">                mResolveActivity.name = ResolverActivity.class.getName();</span><br><span class="line">                mResolveActivity.packageName = mAndroidApplication.packageName;</span><br><span class="line">                mResolveActivity.processName = mAndroidApplication.processName;</span><br><span class="line">                mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;</span><br><span class="line">                mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;</span><br><span class="line">                mResolveActivity.theme = com.android.internal.R.style.Theme_Holo_Dialog_Alert;</span><br><span class="line">                mResolveActivity.exported = <span class="keyword">true</span>;</span><br><span class="line">                mResolveActivity.enabled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//mResoveInfo 的 activityInfo 成员指向 mResolveActivity</span></span><br><span class="line">                mResolveInfo.activityInfo = mResolveActivity;</span><br><span class="line">                mResolveInfo.priority = <span class="number">0</span>;</span><br><span class="line">                mResolveInfo.preferredOrder = <span class="number">0</span>;</span><br><span class="line">                mResolveInfo.match = <span class="number">0</span>;</span><br><span class="line">                mResolveComponentName = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                        mAndroidApplication.packageName, mResolveActivity.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚进入 scanPackageLI 函数，我们就发现了一个极为重要的内容，即单独判断并处理 packageName 为 <code>android</code> 的 Package。和该 Package 对应的APK是 framework-res.apk，有图为证。</p><p>framework-res.apk 的 AndroidManifest.xml：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_pkms/04.png?raw=true" alt=""></p><p>实际上，framework-res.apk 还包含了以下几个常用的 Activity。</p><ul><li>ChooserActivity：当多个 Activity 符合某个 Intent 的时候，系统会弹出此 Activity，由用户选择合适的应用来处理。</li><li>RingtonePickerActivity：铃声选择 Activity。</li><li>ShutdownActivity：关机前弹出的选择对话框。</li></ul><p>由前述知识可知，该 Package 和系统息息相关，因此它得到了 PKMS 的特别青睐，主要体现在以下几点。</p><ul><li>mPlatformPackage 成员用于保存该 Package 信息。</li><li>mAndroidApplication 用于保存此 Package 中的 ApplicationInfo。</li><li>mResolveActivity 指向用于表示 ChooserActivity 信息的 ActivityInfo。</li><li>mResolveInfo 为 ResolveInfo 类型，它用于存储系统解析 Intent（经 IntentFilter 的过滤）后得到的结果信息，例如：满足某个 Intent 的 Activity 的信息。由前面的代码可知，mResolveInfo 的 activityInfo 其实指向的就是 mResolveActivity。</li></ul><blockquote><p>注意：在从 PKMS 中查询满足某个 Intent 的 Activity 时，返回的就是 ResolveInfo，再根据 ResolveInfo 的信息得到具体的 Activity。</p></blockquote><p>此处保存这些信息，主要是为了提高运行过程中的效率。Goolge工 程师可能觉得 ChooserActivity 使用的地方比较多，所以这里单独保存了此 Activity 的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...//mPackages 用于保存系统内的所有 Package，以 packageName 为 key</span></span><br><span class="line"><span class="keyword">if</span> (mPackages.containsKey(pkg.packageName)</span><br><span class="line">        || mSharedLibraries.containsKey(pkg.packageName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File destCodeFile = newFile(pkg.applicationInfo.sourceDir);</span><br><span class="line">FiledestResourceFile = <span class="keyword">new</span> File(pkg.applicationInfo.publicSourceDir);</span><br><span class="line">SharedUserSettingsuid = <span class="keyword">null</span>;<span class="comment">//代表该 Package 的 SharedUserSetting 对象</span></span><br><span class="line">PackageSetting pkgSetting = <span class="keyword">null</span>;<span class="comment">//代表该 Package 的 PackageSetting 对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">    <span class="comment">//...//此段代码大约有300行左右，主要做了以下几方面工作</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. 如果该 Package 声明了”uses-libraries” 话，那么系统要判断该 library 是否在 mSharedLibraries 中</span></span><br><span class="line"><span class="comment">      2. 如果 package 声明了 SharedUser，则需要处理 SharedUserSettings 相关内容，由 Settings 的 getSharedUserLPw 函数处理</span></span><br><span class="line"><span class="comment">      3. 处理 pkgSetting，通过调用 Settings 的 getPackageLPw 函数完成</span></span><br><span class="line"><span class="comment">      4. 调用 verifySignaturesLP 函数，检查该 Package 的 signature</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> scanFileTime = scanFile.lastModified();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> forceDex = (scanMode &amp; SCAN_FORCE_DEX) != <span class="number">0</span>;</span><br><span class="line"><span class="comment">//确定运行该 package 的进程的进程名，一般用 packageName 作为进程名</span></span><br><span class="line">pkg.applicationInfo.processName = fixProcessName(</span><br><span class="line">        pkg.applicationInfo.packageName,</span><br><span class="line">        pkg.applicationInfo.processName,</span><br><span class="line">        pkg.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mPlatformPackage == pkg) &#123;</span><br><span class="line">    dataPath = <span class="keyword">new</span> File(Environment.getDataDirectory(), <span class="string">"system"</span>);</span><br><span class="line">    pkg.applicationInfo.dataDir = dataPath.getPath();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     getDataPathForPackage 函数返回该 package 的目录，一般是 /data/data/packageName/</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    dataPath = getDataPathForPackage(pkg.packageName, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (dataPath.exists()) &#123;</span><br><span class="line">        <span class="comment">//...//如果该目录已经存在，则要处理 uid 的问题</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...//向 installd 发送 install 命令，实际上就是在 /data/data 下</span></span><br><span class="line">        <span class="comment">//建立 packageName 目录。后续将分析 installd 相关知识</span></span><br><span class="line">        <span class="keyword">int</span> ret = mInstaller.install(pkgName, pkg.applicationInfo.uid,</span><br><span class="line">                pkg.applicationInfo.uid);</span><br><span class="line">        <span class="comment">//为系统所有 user 安装此程序</span></span><br><span class="line">        mUserManager.installPackageForAllUsers(pkgName,</span><br><span class="line">                pkg.applicationInfo.uid);</span><br><span class="line">        <span class="keyword">if</span> (dataPath.exists()) &#123;</span><br><span class="line">            pkg.applicationInfo.dataDir = dataPath.getPath();</span><br><span class="line">        &#125; <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkg.applicationInfo.nativeLibraryDir == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                pkg.applicationInfo.dataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...//为该 Package 确定 native library 所在目录</span></span><br><span class="line">            <span class="comment">//一般是 /data/data/packagename/lib</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该 APK 包含了 native 动态库，则需要将它们从 APK 文件中解压并复制到对应目录中</span></span><br><span class="line">    <span class="keyword">if</span> (pkg.applicationInfo.nativeLibraryDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> File nativeLibraryDir = <span class="keyword">new</span></span><br><span class="line">                    File(pkg.applicationInfo.nativeLibraryDir);</span><br><span class="line">            <span class="keyword">final</span> String dataPathString = dataPath.getCanonicalPath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从 2.3 开始，系统 package 的 native 库统一放在 /system/lib 下。所以</span></span><br><span class="line">            <span class="comment">//系统不会提取系统 Package 目录下 APK 包中的 native 库</span></span><br><span class="line">            <span class="keyword">if</span> (isSystemApp(pkg) &amp;&amp; !isUpdatedSystemApp(pkg)) &#123;</span><br><span class="line">                NativeLibraryHelper.removeNativeBinariesFromDirLI(</span><br><span class="line">                        nativeLibraryDir))&#123;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nativeLibraryDir.getParentFile().getCanonicalPath()</span><br><span class="line">                        .equals(dataPathString)) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> isSymLink;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        isSymLink = S_ISLNK(Libcore.os.lstat(</span><br><span class="line">                                nativeLibraryDir.getPath()).st_mode);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="comment">//...//判断是否为链接，如果是，需要删除该链接</span></span><br><span class="line">                    <span class="keyword">if</span> (isSymLink) &#123;</span><br><span class="line">                        mInstaller.unlinkNativeLibraryDirectory(dataPathString);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//在 lib 下建立和 CPU 类型对应的目录，例如 ARM 平台的是 arm/，MIPS 平台的是 mips/</span></span><br><span class="line">                    NativeLibraryHelper.copyNativeBinariesIfNeededLI(scanFile,</span><br><span class="line">                            nativeLibraryDir);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstaller.linkNativeLibraryDirectory(dataPathString,</span><br><span class="line">                            pkg.applicationInfo.nativeLibraryDir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        pkg.mScanPath = path;</span><br><span class="line">        <span class="keyword">if</span> ((scanMode &amp; SCAN_NO_DEX) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//...//对该 APK 做 dex 优化</span></span><br><span class="line">            performDexOptLI(pkg, forceDex, (scanMode &amp; SCAN_DEFER_DEX);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该 APK 已经存在，要先杀掉运行该 APK 的进程</span></span><br><span class="line">        <span class="keyword">if</span> ((parseFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != <span class="number">0</span>) &#123;</span><br><span class="line">            killApplication(pkg.applicationInfo.packageName,</span><br><span class="line">                    pkg.applicationInfo.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         在此之前，四大组件信息都属于 Package 的私有财产，现在需要把它们登记注册到 PKMS 内部的</span></span><br><span class="line"><span class="comment">         财产管理对象中。这样，PKMS 就可对外提供统一的组件信息，而不必拘泥于具体的 Package</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((scanMode &amp; SCAN_MONITOR) != <span class="number">0</span>) &#123;</span><br><span class="line">                mAppDirs.put(pkg.mPath, pkg);</span><br><span class="line">            &#125;</span><br><span class="line">            mSettings.insertPackageSettingLPw(pkgSetting, pkg);</span><br><span class="line">            mPackages.put(pkg.applicationInfo.packageName, pkg);</span><br><span class="line">            <span class="comment">//处理该 Package 中的 Provider 信息</span></span><br><span class="line">            <span class="keyword">int</span> N = pkg.providers.size();</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                PackageParser.Providerp = pkg.providers.get(i);</span><br><span class="line">                p.info.processName = fixProcessName(</span><br><span class="line">                        pkg.applicationInfo.processName,</span><br><span class="line">                        p.info.processName, pkg.applicationInfo.uid);</span><br><span class="line">                <span class="comment">//mProvidersByComponent 提供基于 ComponentName 的 Provider 信息查询</span></span><br><span class="line">                mProvidersByComponent.put(<span class="keyword">new</span> ComponentName(</span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理该 Package 中的 Service 信息</span></span><br><span class="line">            N = pkg.services.size();</span><br><span class="line">            r = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                PackageParser.Service s = pkg.services.get(i);</span><br><span class="line">                mServices.addService(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理该 Package 中的 BroadcastReceiver 信息</span></span><br><span class="line">            N = pkg.receivers.size();</span><br><span class="line">            r = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                PackageParser.Activity a = pkg.receivers.get(i);</span><br><span class="line">                mReceivers.addActivity(a, <span class="string">"receiver"</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理该 Package 中的 Activity 信息</span></span><br><span class="line">            N = pkg.activities.size();</span><br><span class="line">            r = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                PackageParser.Activity a = pkg.activities.get(i);</span><br><span class="line">                mActivities.addActivity(a, <span class="string">"activity"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理该 Package 中的 PermissionGroups 信息</span></span><br><span class="line">            N = pkg.permissionGroups.size();</span><br><span class="line">            <span class="comment">//...//permissionGroups 处理</span></span><br><span class="line">            N = pkg.permissions.size();</span><br><span class="line">            <span class="comment">//...//permissions 处理</span></span><br><span class="line">            N = pkg.instrumentation.size();</span><br><span class="line">            <span class="comment">//...//instrumentation 处理</span></span><br><span class="line">            <span class="keyword">if</span> (pkg.protectedBroadcasts != <span class="keyword">null</span>) &#123;</span><br><span class="line">                N = pkg.protectedBroadcasts.size();</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                    mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...//Package 的私有财产终于完成了公有化改造</span></span><br><span class="line">            <span class="keyword">return</span> pkg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanPackageLI() 总结</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_pkms/05.png?raw=true" alt=""></p><p>扫描非系统 Package，非系统 Package 就是指那些不存储在系统目录下的 APK 文件，这部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mOnlyCore) &#123;<span class="comment">//mOnlyCore 用于控制是否扫描非系统 Package</span></span><br><span class="line">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (psit.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//...//删除系统package中那些不存在的APK</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAppInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app"</span>);</span><br><span class="line">    <span class="comment">//...//删除安装不成功的文件及临时文件</span></span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        <span class="comment">//在普通模式下，还需要扫描 /data/app 以及 /data/app_private 目录</span></span><br><span class="line">        mAppInstallObserver = <span class="keyword">new</span> AppDirObserver(</span><br><span class="line">                mAppInstallDir.getPath(), OBSERVER_EVENTS, <span class="keyword">false</span>);</span><br><span class="line">        mAppInstallObserver.startWatching();</span><br><span class="line">        scanDirLI(mAppInstallDir, <span class="number">0</span>, scanMode, <span class="number">0</span>);</span><br><span class="line">        mDrmAppInstallObserver = newAppDirObserver(</span><br><span class="line">                mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, <span class="keyword">false</span>);</span><br><span class="line">        mDrmAppInstallObserver.startWatching();</span><br><span class="line">        scanDirLI(mDrmAppPrivateInstallDir,</span><br><span class="line">                PackageParser.PARSE_FORWARD_LOCK, scanMode, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAppInstallObserver = <span class="keyword">null</span>;</span><br><span class="line">        mDrmAppInstallObserver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合前述代码，这里总结几个存放APK文件的目录。</p><ul><li>系统 Package 目录包括：/system/frameworks、/system/app 和 /vendor/app。</li><li>非系统 Package 目录包括：/data/app、/data/app-private。</li></ul><h3 id="第二阶段总结"><a href="#第二阶段总结" class="headerlink" title="第二阶段总结"></a>第二阶段总结</h3><p>PKMS 构造函数第二阶段的工作任务非常繁重，要创建比较多的对象，所以它是一个耗时耗内存的操作。在工作中，我们一直想优化该流程以加快启动速度，例如：延时扫描不重要的 APK，或者保存 Package 信息到文件中，然后在启动时从文件中恢复这些信息以减少 APK 文件读取并解析 XML 的工作量。但是一直没有一个比较完满的解决方案，原因有很多。比如：APK 之间有着比较微妙的依赖关系，因此到底延时扫描哪些 APK，尚不能确定。</p><h3 id="构造函数扫尾工作"><a href="#构造函数扫尾工作" class="headerlink" title="构造函数扫尾工作"></a>构造函数扫尾工作</h3><p>下面分析 PKMS 第三阶段的工作，这部分任务比较简单，就是将第二阶段收集的信息再集中整理一次，比如将有些信息保存到文件中，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mSettings.mInternalSdkPlatform= mSdkVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汇总并更新和 Permission 相关的信息</span></span><br><span class="line">    updatePermissionsLPw(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>, regrantPermissions,regrantPermissions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将信息写到 package.xml、package.list 及 package-stopped.xml 文件中</span></span><br><span class="line">    mSettings.writeLPr();</span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">    mRequiredVerifierPackage= getRequiredVerifierLPr();</span><br><span class="line">    <span class="comment">//...//PKMS 构造函数返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从流程角度看，PKMS 构造函数的功能还算清晰，无非是扫描 XML 或 APK 文件，但是其中涉及的数据结构及它们之间的关系却较为复杂。这里有一些建议供读者参考：</p><ul><li>理解 PKMS 构造函数工作的三个阶段及其各阶段的工作职责。</li><li>了解 PKMS 第二阶段工作中解析 APK 文件的几个关键步骤。</li><li>了解重点数据结构的名字和大体功能。</li></ul><h3 id="获取-PackageManager-服务"><a href="#获取-PackageManager-服务" class="headerlink" title="获取 PackageManager 服务"></a>获取 PackageManager 服务</h3><p>ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//见下面分析</span></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建 ApplicationPackageManager 对象</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 PKMS 服务，并创建 ApplicationPackageManager 对象。</p><p>ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 ServiceManager 通讯获取到 PKMS 的代理对象。</p><h3 id="PKMS-performBootDexOpt"><a href="#PKMS-performBootDexOpt" class="headerlink" title="PKMS.performBootDexOpt()"></a>PKMS.performBootDexOpt()</h3><p>PackageManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performBootDexOpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 确保只有 system 或者 root uid 有权限执行该方法</span></span><br><span class="line">   enforceSystemOrRoot(<span class="string">"Only the system can request dexopt be performed"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//运行在同一个进程,此处拿到的 MountService 的服务端</span></span><br><span class="line">   IMountService ms = PackageHelper.getMountService();</span><br><span class="line">   <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> isUpgrade = isUpgrade(); <span class="comment">//处于更新状态，则执行fstrim</span></span><br><span class="line">       <span class="keyword">boolean</span> doTrim = isUpgrade;</span><br><span class="line">       <span class="keyword">if</span> (doTrim) &#123;</span><br><span class="line">           Slog.w(TAG, <span class="string">"Running disk maintenance immediately due to system update"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//interval 默认值为 3 天</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> interval = android.provider.Settings.Global.getLong(</span><br><span class="line">                   mContext.getContentResolver(),</span><br><span class="line">                   android.provider.Settings.Global.FSTRIM_MANDATORY_INTERVAL,</span><br><span class="line">                   DEFAULT_MANDATORY_FSTRIM_INTERVAL);</span><br><span class="line">           <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLast = System.currentTimeMillis() - ms.lastMaintenance();</span><br><span class="line">               <span class="keyword">if</span> (timeSinceLast &gt; interval) &#123;</span><br><span class="line">                   doTrim = <span class="keyword">true</span>; <span class="comment">//距离上次 fstrim 时间超过 3 天，则执行 fstrim</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//此处 ms 是指 MountService，该过程发送消息 H_FSTRIM 给 handler，然后再向 vold 发送 fstrim 命令</span></span><br><span class="line">       <span class="keyword">if</span> (doTrim) &#123;</span><br><span class="line">           ms.runMaintenance();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> ArraySet&lt;PackageParser.Package&gt; pkgs;</span><br><span class="line">   <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">       <span class="comment">//清空延迟执行 dexopt 操作的 app，获取 dexopt 操作的 app 集合</span></span><br><span class="line">       pkgs = mPackageDexOptimizer.clearDeferredDexOptPackages();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pkgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ArrayList&lt;PackageParser.Package&gt; sortedPkgs = <span class="keyword">new</span> ArrayList&lt;PackageParser.Package&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Iterator&lt;PackageParser.Package&gt; it = pkgs.iterator(); it.hasNext();) &#123;</span><br><span class="line">           PackageParser.Package pkg = it.next();</span><br><span class="line">           <span class="comment">//将 pkgs 中的核心 app 添加到 sortedPkgs</span></span><br><span class="line">           <span class="keyword">if</span> (pkg.coreApp) &#123;</span><br><span class="line">               sortedPkgs.add(pkg);</span><br><span class="line">               it.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取监听 PRE_BOOT_COMPLETE 的系统 app 集合</span></span><br><span class="line">       Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_PRE_BOOT_COMPLETED);</span><br><span class="line">       ArraySet&lt;String&gt; pkgNames = getPackageNamesForIntent(intent);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Iterator&lt;PackageParser.Package&gt; it = pkgs.iterator(); it.hasNext();) &#123;</span><br><span class="line">           PackageParser.Package pkg = it.next();</span><br><span class="line">           <span class="comment">//将 pkg 中监听 PRE_BOOT_COMPLETE 的 app 添加到 sortedPkgs</span></span><br><span class="line">           <span class="keyword">if</span> (pkgNames.contains(pkg.packageName)) &#123;</span><br><span class="line">               sortedPkgs.add(pkg);</span><br><span class="line">               it.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取 pkgs 中最近一周使用过的 app，详见下面</span></span><br><span class="line">       filterRecentlyUsedApps(pkgs);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将最近一周的 app 添加到 sortedPkgs</span></span><br><span class="line">       <span class="keyword">for</span> (PackageParser.Package pkg : pkgs) &#123;</span><br><span class="line">           sortedPkgs.add(pkg);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mLazyDexOpt) &#123;</span><br><span class="line">           filterRecentlyUsedApps(sortedPkgs);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> total = sortedPkgs.size();</span><br><span class="line">       File dataDir = Environment.getDataDirectory();</span><br><span class="line">       <span class="keyword">long</span> lowThreshold = StorageManager.from(mContext).getStorageLowBytes(dataDir);</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (PackageParser.Package pkg : sortedPkgs) &#123;</span><br><span class="line">           <span class="keyword">long</span> usableSpace = dataDir.getUsableSpace();</span><br><span class="line">           <span class="keyword">if</span> (usableSpace &lt; lowThreshold) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//详见下面</span></span><br><span class="line">           performBootDexOpt(pkg, ++i, total);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterRecentlyUsedApps</span><span class="params">(Collection&lt;PackageParser.Package&gt; pkgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (mLazyDexOpt || (!isFirstBoot() &amp;&amp; mPackageUsage.isHistoricalPackageUsageAvailable())) &#123;</span><br><span class="line">         <span class="keyword">int</span> total = pkgs.size();</span><br><span class="line">         <span class="keyword">int</span> skipped = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;PackageParser.Package&gt; i = pkgs.iterator(); i.hasNext();) &#123;</span><br><span class="line">             PackageParser.Package pkg = i.next();</span><br><span class="line">             <span class="comment">// 过滤出最近使用过的 app</span></span><br><span class="line">             <span class="keyword">long</span> then = pkg.mLastPackageUsageTimeInMills;</span><br><span class="line">             <span class="keyword">if</span> (then + mDexOptLRUThresholdInMills &lt; now) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 skipped++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performBootDexOpt</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> curr, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFirstBoot()) &#123;</span><br><span class="line">        ActivityManagerNative.getDefault().showBootMessage(</span><br><span class="line">              mContext.getResources().getString(R.string.android_upgrading_apk,</span><br><span class="line">                  curr, total), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PackageParser.Package p = pkg;</span><br><span class="line">    <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">        mPackageDexOptimizer.performDexOpt(p, <span class="keyword">null</span> <span class="comment">/* instruction sets */</span>,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* force dex */</span>, <span class="keyword">false</span> <span class="comment">/* defer */</span>, <span class="keyword">true</span> <span class="comment">/* include dependencies */</span>,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* boot complete */</span>, <span class="keyword">false</span> <span class="comment">/*useJit*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PKMS-systemReady"><a href="#PKMS-systemReady" class="headerlink" title="PKMS.systemReady()"></a>PKMS.systemReady()</h3><p>PackageManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSystemReady = <span class="keyword">true</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        ArrayList&lt;PreferredActivity&gt; removed = <span class="keyword">new</span> ArrayList&lt;PreferredActivity&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mSettings.mPreferredActivities.size(); i++) &#123;</span><br><span class="line">            PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);</span><br><span class="line">            removed.clear();</span><br><span class="line">            <span class="keyword">for</span> (PreferredActivity pa : pir.filterSet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mActivities.mActivities.get(pa.mPref.mComponent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    removed.add(pa);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (removed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;removed.size(); r++) &#123;</span><br><span class="line">                    PreferredActivity pa = removed.get(r);</span><br><span class="line">                    pir.removeFilter(pa);</span><br><span class="line">                &#125;</span><br><span class="line">                mSettings.writePackageRestrictionsLPr(</span><br><span class="line">                        mSettings.mPreferredActivities.keyAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> userId : UserManagerService.getInstance().getUserIds()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) &#123;</span><br><span class="line">                grantPermissionsUserIds = ArrayUtils.appendInt(</span><br><span class="line">                        grantPermissionsUserIds, userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sUserManager.systemReady(); <span class="comment">//多用户服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//升级所有已获取的默认权限</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> userId : grantPermissionsUserIds) &#123;</span><br><span class="line">        mDefaultPermissionPolicy.grantDefaultPermissions(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理所有等待系统准备就绪的消息</span></span><br><span class="line">    <span class="keyword">if</span> (mPostSystemReadyMessages != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Message msg : mPostSystemReadyMessages) &#123;</span><br><span class="line">            msg.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">        mPostSystemReadyMessages = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察外部存储设备</span></span><br><span class="line">    <span class="keyword">final</span> StorageManager storage = mContext.getSystemService(StorageManager.class);</span><br><span class="line">    storage.registerListener(mStorageListener);</span><br><span class="line"></span><br><span class="line">    mInstallerService.systemReady();</span><br><span class="line">    mPackageDexOptimizer.systemReady();</span><br><span class="line"></span><br><span class="line">    MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);</span><br><span class="line">    mountServiceInternal.addExternalStoragePolicy(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PackageManagerService 启动完整流程图：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_pkms/07.png?raw=true" alt=""></p><h2 id="installd"><a href="#installd" class="headerlink" title="installd"></a>installd</h2><p>PackageManagerServie 服务负责应用的安装、卸载等相关工作，而真正干活的还是 installd。 其中 PKMS 执行权限为 system，而进程 installd 的执行权限为 root。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>installd 是由 Android 系统的 init 进程(pid=1)，在解析 init.rc 文件的如下代码块时，通过 fork 创建的用户空间的守护进程 installd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service installd /system/bin/installd</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">installd</span> <span class="title">stream</span> 600 <span class="title">system</span> <span class="title">system</span></span></span><br></pre></td></tr></table></figure><p>installd 是随着系统启动过程中 main class 而启动的，并且会创建一个 socket 套接字，用于跟上层的 PKMS 进行交互。 installd 的启动入口 frameworks/base/cmds/installd/installd.c 的 main() 方法，接下来从这里开始说起。</p><p>installd.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> argc __unused, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_MAX]; <span class="comment">//buffer大小为1024Byte</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> alen;</span><br><span class="line">    <span class="keyword">int</span> lsocket, s;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化全局信息【1】</span></span><br><span class="line">    <span class="keyword">if</span> (initialize_globals() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化相关目录【2】</span></span><br><span class="line">    <span class="keyword">if</span> (initialize_directories() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取套接字"installd"</span></span><br><span class="line">    lsocket = android_get_control_socket(SOCKET_PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listen(lsocket, <span class="number">5</span>)) &#123; <span class="comment">//监听socket消息</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fcntl(lsocket, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        alen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">        s = accept(lsocket, &amp;addr, &amp;alen); <span class="comment">//接受socket消息</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fcntl(s, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> count;</span><br><span class="line">            <span class="comment">//读取指令的长度</span></span><br><span class="line">            <span class="keyword">if</span> (readx(s, &amp;count, <span class="keyword">sizeof</span>(count))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((count &lt; <span class="number">1</span>) || (count &gt;= BUFFER_MAX)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取指令的内容</span></span><br><span class="line">            <span class="keyword">if</span> (readx(s, buf, count)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[count] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//执行指令【3】</span></span><br><span class="line">            <span class="keyword">if</span> (execute(s, buf)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>installd.cpp -&gt; initialize_globals</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initialize_globals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据目录/data/</span></span><br><span class="line">    <span class="keyword">if</span> (get_path_from_env(&amp;android_data_dir, <span class="string">"ANDROID_DATA"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// app目录/data/app/</span></span><br><span class="line">    <span class="keyword">if</span> (copy_and_append(&amp;android_app_dir, &amp;android_data_dir, APP_SUBDIR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 受保护的app目录/data/priv-app/</span></span><br><span class="line">    <span class="keyword">if</span> (copy_and_append(&amp;android_app_private_dir, &amp;android_data_dir, PRIVATE_APP_SUBDIR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// app本地库目录/data/app-lib/</span></span><br><span class="line">    <span class="keyword">if</span> (copy_and_append(&amp;android_app_lib_dir, &amp;android_data_dir, APP_LIB_SUBDIR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sdcard挂载点/mnt/asec</span></span><br><span class="line">    <span class="keyword">if</span> (get_path_from_env(&amp;android_asec_dir, <span class="string">"ASEC_MOUNTPOINT"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多媒体目录/data/media</span></span><br><span class="line">    <span class="keyword">if</span> (copy_and_append(&amp;android_media_dir, &amp;android_data_dir, MEDIA_SUBDIR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部app目录/mnt/expand</span></span><br><span class="line">    <span class="keyword">if</span> (get_path_from_string(&amp;android_mnt_expand_dir, <span class="string">"/mnt/expand/"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统和厂商目录</span></span><br><span class="line">    android_system_dirs.count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    android_system_dirs.dirs = (<span class="keyword">dir_rec_t</span>*) <span class="built_in">calloc</span>(android_system_dirs.count, <span class="keyword">sizeof</span>(<span class="keyword">dir_rec_t</span>));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">dir_rec_t</span> android_root_dir;</span><br><span class="line">    <span class="comment">// 目录/system</span></span><br><span class="line">    <span class="keyword">if</span> (get_path_from_env(&amp;android_root_dir, <span class="string">"ANDROID_ROOT"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录/system/app</span></span><br><span class="line">    android_system_dirs.dirs[<span class="number">0</span>].path = build_string2(android_root_dir.path, APP_SUBDIR);</span><br><span class="line">    android_system_dirs.dirs[<span class="number">0</span>].len = <span class="built_in">strlen</span>(android_system_dirs.dirs[<span class="number">0</span>].path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目录/system/app-lib</span></span><br><span class="line">    android_system_dirs.dirs[<span class="number">1</span>].path = build_string2(android_root_dir.path, PRIV_APP_SUBDIR);</span><br><span class="line">    android_system_dirs.dirs[<span class="number">1</span>].len = <span class="built_in">strlen</span>(android_system_dirs.dirs[<span class="number">1</span>].path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录/vendor/app/</span></span><br><span class="line">    android_system_dirs.dirs[<span class="number">2</span>].path = strdup(<span class="string">"/vendor/app/"</span>);</span><br><span class="line">    android_system_dirs.dirs[<span class="number">2</span>].len = <span class="built_in">strlen</span>(android_system_dirs.dirs[<span class="number">2</span>].path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录/oem/app/</span></span><br><span class="line">    android_system_dirs.dirs[<span class="number">3</span>].path = strdup(<span class="string">"/oem/app/"</span>);</span><br><span class="line">    android_system_dirs.dirs[<span class="number">3</span>].len = <span class="built_in">strlen</span>(android_system_dirs.dirs[<span class="number">3</span>].path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>installd.cpp -&gt; initialize_directories</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initialize_directories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取当前文件系统版本</span></span><br><span class="line">    <span class="keyword">char</span> version_path[PATH_MAX];</span><br><span class="line">    <span class="built_in">snprintf</span>(version_path, PATH_MAX, <span class="string">"%s.layout_version"</span>, android_data_dir.path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldVersion;</span><br><span class="line">    <span class="keyword">if</span> (fs_read_atomic_int(version_path, &amp;oldVersion) == <span class="number">-1</span>) &#123;</span><br><span class="line">        oldVersion = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> version = oldVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录/data/user</span></span><br><span class="line">    <span class="keyword">char</span> *user_data_dir = build_string2(android_data_dir.path, SECONDARY_USER_PREFIX);</span><br><span class="line">    <span class="comment">// 目录/data/data</span></span><br><span class="line">    <span class="keyword">char</span> *legacy_data_dir = build_string2(android_data_dir.path, PRIMARY_USER_PREFIX);</span><br><span class="line">    <span class="comment">// 目录/data/user/0</span></span><br><span class="line">    <span class="keyword">char</span> *primary_data_dir = build_string3(android_data_dir.path, SECONDARY_USER_PREFIX, <span class="string">"0"</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//将/data/user/0链接到/data/data</span></span><br><span class="line">    <span class="keyword">if</span> (access(primary_data_dir, R_OK) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (symlink(legacy_data_dir, primary_data_dir)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... //处理data/media 相关</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>installd.cpp -&gt; execute</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">char</span> cmd[BUFFER_MAX])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> reply[REPLY_MAX];</span><br><span class="line">    <span class="keyword">char</span> *arg[TOKEN_MAX+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> count;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    reply[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    arg[<span class="number">0</span>] = cmd;</span><br><span class="line">    <span class="keyword">while</span> (*cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*cmd)) &#123;</span><br><span class="line">            *cmd++ = <span class="number">0</span>;</span><br><span class="line">            n++;</span><br><span class="line">            arg[n] = cmd;</span><br><span class="line">            <span class="keyword">if</span> (n == TOKEN_MAX) &#123;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*cmd) &#123;</span><br><span class="line">          cmd++; <span class="comment">//计算参数个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cmds) / <span class="keyword">sizeof</span>(cmds[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmds[i].name,arg[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != cmds[i].numargs) &#123;</span><br><span class="line">                <span class="comment">//参数个数不匹配，直接返回</span></span><br><span class="line">                ALOGE(<span class="string">"%s requires %d arguments (%d given)\n"</span>,</span><br><span class="line">                    cmds[i].name, cmds[i].numargs, n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//执行相应的命令[见小节2.5]</span></span><br><span class="line">                ret = cmds[i].func(arg + <span class="number">1</span>, reply);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (reply[<span class="number">0</span>]) &#123;</span><br><span class="line">        n = <span class="built_in">snprintf</span>(cmd, BUFFER_MAX, <span class="string">"%d %s"</span>, ret, reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">snprintf</span>(cmd, BUFFER_MAX, <span class="string">"%d"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; BUFFER_MAX) n = BUFFER_MAX;</span><br><span class="line">    count = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将命令执行后的返回值写入socket套接字</span></span><br><span class="line">    <span class="keyword">if</span> (writex(s, &amp;count, <span class="keyword">sizeof</span>(count))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writex(s, cmd, count)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Installer"><a href="#Installer" class="headerlink" title="Installer"></a>Installer</h3><p>当守护进程 installd 启动完成后，上层 framework 便可以通过 socket 跟该守护进程进行通信。 在 SystemServer 启动服务的过程中创建 Installer 对象，便会有一次跟 installd 通信的过程。</p><p>SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//启动 installer 服务</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Installer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Installer</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    <span class="comment">//创建 InstallerConnection 对象</span></span><br><span class="line">    mInstaller = <span class="keyword">new</span> InstallerConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Slog.i(TAG, <span class="string">"Waiting for installd to be ready."</span>);</span><br><span class="line">  mInstaller.waitForConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建 Installer 对象，再调用 onStart() 方法，该方法中主要工作是等待 socket 通道建立完成。</p><p>InstallerConnection.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (execute(<span class="string">"ping"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.w(TAG, <span class="string">"installd not ready"</span>);</span><br><span class="line">        SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">    String res = transact(cmd);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(res);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">transact</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connect()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!writeCommand(cmd)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!connect() || !writeCommand(cmd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取应答消息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> replyLength = readReply();</span><br><span class="line">    <span class="keyword">if</span> (replyLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(buf, <span class="number">0</span>, replyLength);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Slog.i(TAG, <span class="string">"connecting..."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSocket = <span class="keyword">new</span> LocalSocket();</span><br><span class="line"></span><br><span class="line">        LocalSocketAddress address = <span class="keyword">new</span> LocalSocketAddress(<span class="string">"installd"</span>,</span><br><span class="line">                LocalSocketAddress.Namespace.RESERVED);</span><br><span class="line"></span><br><span class="line">        mSocket.connect(address);</span><br><span class="line"></span><br><span class="line">        mIn = mSocket.getInputStream();</span><br><span class="line">        mOut = mSocket.getOutputStream();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        disconnect();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">writeCommand</span><span class="params">(String cmdString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] cmd = cmdString.getBytes();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = cmd.length;</span><br><span class="line">    <span class="keyword">if</span> ((len &lt; <span class="number">1</span>) || (len &gt; buf.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = (<span class="keyword">byte</span>) (len &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mOut.write(buf, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">//写入长度</span></span><br><span class="line">        mOut.write(cmd, <span class="number">0</span>, len); <span class="comment">//写入具体命令</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        disconnect();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readReply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!readFully(buf, <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = (((<span class="keyword">int</span>) buf[<span class="number">0</span>]) &amp; <span class="number">0xff</span>) | ((((<span class="keyword">int</span>) buf[<span class="number">1</span>]) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ((len &lt; <span class="number">1</span>) || (len &gt; buf.length)) &#123;</span><br><span class="line">        disconnect();</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!readFully(buf, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Streams.readFully(mIn, buffer, <span class="number">0</span>, len);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">         disconnect();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可见，一次 transact 过程为先 connect() 来判断是否建立 socket 连接，如果已连接则通过 writeCommand() 将命令写入 socket 的 mOut 管道，等待从管道的 mIn 中 readFully() 读取应答消息。</p><h2 id="Apk-安装过程分析"><a href="#Apk-安装过程分析" class="headerlink" title="Apk 安装过程分析"></a>Apk 安装过程分析</h2><h3 id="adb-install-分析"><a href="#adb-install-分析" class="headerlink" title="adb install 分析"></a>adb install 分析</h3><p>adb install 有多个参数，这里仅考虑最简单的，如： <code>adb install frameworktest.apk</code>。adb 是一个命令，install 是它的参数。此处直接跳到处理 install 参数的代码：</p><p>commandline.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adb_commandline</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">   <span class="comment">//... </span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"install"</span>)) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line"><span class="comment">//调用 install_app 函数处理</span></span><br><span class="line">       <span class="keyword">return</span> install_app(ttype, serial, argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_app</span><span class="params">(transport_type transport, <span class="keyword">char</span>*serial, <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//要安装的APK现在还在Host机器上，要先把APK复制到手机中。</span></span><br><span class="line">   <span class="comment">//这里需要设置复制目标的目录，如果安装在内部存储中，则目标目录为/data/local/tmp；</span></span><br><span class="line">   <span class="comment">//如果安装在SD卡上，则目标目录为/sdcard/tmp。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> DATA_DEST = <span class="string">"/data/local/tmp/%s"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> SD_DEST = <span class="string">"/sdcard/tmp/%s"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* where = DATA_DEST;</span><br><span class="line">    <span class="keyword">char</span> apk_dest[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> verification_dest[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> *apk_file;</span><br><span class="line">    <span class="keyword">char</span> *verification_file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> file_arg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> err</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*argv[i] != <span class="string">'-'</span>) &#123;</span><br><span class="line">           file_arg = i</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">"-i"</span>)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">"-s"</span>)) &#123;</span><br><span class="line">           where = SD_DEST; <span class="comment">//-s参数指明该APK安装到SD卡</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    apk_file = argv[file_arg];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取目标文件的全路径，如果安装在内部存储中，则目标全路径为/data/local/tmp/安装包名，</span></span><br><span class="line">    <span class="comment">//调用do_sync_push将此APK传送到手机的目标路径</span></span><br><span class="line">    err = do_sync_push(apk_file, apk_dest, <span class="number">1</span> <span class="comment">/* verify APK */</span>);</span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">    <span class="comment">//执行 pm 命令【1】</span></span><br><span class="line"></span><br><span class="line">    pm_command(transport,serial, argc, argv);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  cleanup_apk:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在手机中执行shell rm 命令，删除刚才传送过去的目标 Apk 文件</span></span><br><span class="line">  delete_file(transport, serial, apk_dest);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commandline.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pm_command</span><span class="params">(transport_type transport,<span class="keyword">char</span>* serial,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf), <span class="string">"shell:pm"</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//发送"shell:pm install 参数"给手机端的 adbd</span></span><br><span class="line">   send_shellcommand(transport, serial, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手机端的 adbd 在收到客户端发来的 shell:pm 命令时会启动一个 shell，然后在其中执行 pm。</p><p>pm 实际上是一个脚本，其内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Script to start <span class="string">"pm"</span> on the device,which has a very rudimentary</span><br><span class="line"><span class="meta"># shell.</span></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">base=/system</span><br><span class="line"><span class="keyword">export</span> CLASSPATH=$base/frameworks/pm.jar</span><br><span class="line">exec app_process $base/bincom.android.commands.pm.Pm <span class="string">"$@"</span></span><br></pre></td></tr></table></figure><p>在编译 system.image 时，Android.mk 中会将该脚本复制到 system/bin 目录下。从 pm 脚本的内容来看，它就是通过 app_process 执行 pm.jar 包的 main 函数。</p><p>pm.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Pm().run(args);<span class="comment">//创建一个 Pm 对象，并执行它的 run 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接分析 run 函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> validCommand = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//获取PKMS的binder客户端</span></span><br><span class="line">mPm = IPackageManager.Stub</span><br><span class="line">.asInterface(ServiceManager.getService(<span class="string">"package"</span>));</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">mArgs = args;</span><br><span class="line">String op = args[<span class="number">0</span>];</span><br><span class="line">mNextArg = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//...//处理其他命令，这里仅考虑 install 的处理</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"install"</span>.equals(op)) &#123;</span><br><span class="line">   runInstall();</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">intinstallFlags = <span class="number">0</span>;</span><br><span class="line">String installerPackageName = <span class="keyword">null</span>;</span><br><span class="line">String opt;</span><br><span class="line"><span class="keyword">while</span> ((opt=nextOption()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (opt.equals(<span class="string">"-l"</span>)) &#123;</span><br><span class="line">       installFlags |= PackageManager.INSTALL_FORWARD_LOCK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt.equals(<span class="string">"-r"</span>)) &#123;</span><br><span class="line">installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt.equals(<span class="string">"-i"</span>)) &#123;</span><br><span class="line">installerPackageName = nextOptionData();</span><br><span class="line"><span class="comment">//... //参数解析</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Uri apkURI;</span><br><span class="line"><span class="keyword">final</span> Uri verificationURI;</span><br><span class="line"><span class="keyword">final</span> String apkFilePath = nextArg();</span><br><span class="line">System.err.println(<span class="string">"/tpkg: "</span> + apkFilePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(apkFilePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">apkURI = Uri.fromFile(<span class="keyword">new</span> File(apkFilePath));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//获取 Verification Package 的文件位置</span></span><br><span class="line"><span class="keyword">final</span> String verificationFilePath = nextArg();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(verificationFilePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">  verificationURI = Uri.fromFile(<span class="keyword">new</span> File(verificationFilePath));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   verificationURI = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建 PackageInstallObserver，用于接收 PKMS 的安装结果</span></span><br><span class="line">PackageInstallObserver obs = <span class="keyword">new</span> PackageInstallObserver();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//调用 PKMS 的 installPackageWithVerification 完成安装</span></span><br><span class="line">   mPm.installPackageWithVerification(apkURI, obs,</span><br><span class="line">                          installFlags,installerPackageName,</span><br><span class="line">                          verificationURI,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (obs) &#123;</span><br><span class="line"><span class="keyword">while</span>(!obs.finished) &#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">          obs.wait();<span class="comment">//等待安装结果</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(obs.result == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Success"</span>);<span class="comment">//安装成功，打印 Success</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//...//安装失败，打印失败原因</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pm 解析参数后，最终通过 PKMS 的 Binder 客户端调用 installPackageWithVerification 以完成后续的安装工作，所以，下面进入 PKMS 看看安装到底是怎么一回事。</p><h3 id="installPackageWithVerification-分析"><a href="#installPackageWithVerification-分析" class="headerlink" title="installPackageWithVerification 分析"></a>installPackageWithVerification 分析</h3><p>PackageManagerService.java::installPackageWithVerification</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installPackageWithVerification</span><span class="params">(UripackageURI,</span></span></span><br><span class="line"><span class="function"><span class="params">IPackageInstallObserverobserver,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> flags, String installerPackageName, Uri verificationURI,</span></span></span><br><span class="line"><span class="function"><span class="params">ManifestDigest manifestDigest)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查客户端进程是否具有安装 Package 的权限。在本例中，该客户端进程是 shell</span></span><br><span class="line">mContext.enforceCallingOrSelfPermission(</span><br><span class="line">android.Manifest.permission.INSTALL_PACKAGES,null);</span><br><span class="line">final <span class="keyword">int</span> uid = Binder.getCallingUid();</span><br><span class="line">final <span class="keyword">int</span> filteredFlags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(uid == Process.SHELL_UID || uid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//...//如果通过 shell pm 的方式安装，则增加 INSTALL_FROM_ADB 标志</span></span><br><span class="line">filteredFlags = flags | PackageManager.INSTALL_FROM_ADB;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">filteredFlags = flags &amp; ~PackageManager.INSTALL_FROM_ADB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 Message，code 为 INIT_COPY，将该消息发送给之前在 PKMS 构造函数中</span></span><br><span class="line"><span class="comment">//创建的 mHandler 对象，将在另外一个工作线程中处理此消息</span></span><br><span class="line">final Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 InstallParams，其基类是 HandlerParams</span></span><br><span class="line">msg.obj = <span class="keyword">new</span> InstallParams(packageURI, observer,</span><br><span class="line">filteredFlags,installerPackageName,</span><br><span class="line">verificationURI,manifestDigest);</span><br><span class="line">mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="INIT-COPY-处理"><a href="#INIT-COPY-处理" class="headerlink" title="INIT_COPY 处理"></a>INIT_COPY 处理</h3><p>INIT_COPY 只是安装流程的第一步。先来看相关代码：</p><p>PackageManagerService.java::handleMesssage</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doHandleMessage(msg);<span class="comment">//调用 doHandleMessage 函数</span></span><br><span class="line">&#125; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INIT_COPY: &#123;</span><br><span class="line">            <span class="comment">//这里记录的是 params 的基类类型 HandlerParams，实际类型为 InstallParams</span></span><br><span class="line">            HandlerParams params = (HandlerParams) msg.obj;</span><br><span class="line">            <span class="comment">//idx为当前等待处理的安装请求的个数</span></span><br><span class="line">            <span class="keyword">int</span> idx = mPendingInstalls.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mBound) &#123;</span><br><span class="line">                <span class="comment">//APK 的安装居然需要使用另外一个 APK 提供的服务，该服务就是</span></span><br><span class="line">                <span class="comment">//DefaultContainerService，由 DefaultCotainerService.apk 提供，</span></span><br><span class="line">                <span class="comment">//下面的 connectToService 函数将调用 bindService 来启动该服务</span></span><br><span class="line">                <span class="keyword">if</span> (!connectToService()) &#123;</span><br><span class="line">                    params.serviceError();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">////如果已经连上，则以 idx 为索引，将 params 保存到 mPendingInstalls 中</span></span><br><span class="line">                    mPendingInstalls.add(idx, params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mPendingInstalls.add(idx, params);</span><br><span class="line">                <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果安装请求队列之前的状态为空，则表明要启动安装</span></span><br><span class="line">                    mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MCS_BOUND: &#123;</span><br><span class="line">            <span class="comment">//稍后分析</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里假设之前已经成功启动了 DefaultContainerService（以后简称 DCS），并且 idx 为零，所以这是 PKMS 首次处理安装请求，也就是说，下一个将要处理的是 MCS_BOUND 消息。</p><h3 id="MCS-BOUND-处理"><a href="#MCS-BOUND-处理" class="headerlink" title="MCS_BOUND 处理"></a>MCS_BOUND 处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INIT_COPY: &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MCS_BOUND: &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mContainerService = (IMediaContainerService) msg.obj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mContainerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mBound) &#123;</span><br><span class="line">                    <span class="comment">//如果没法启动该 service，则不能安装程序</span></span><br><span class="line">                    mPendingInstalls.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                HandlerParams params = mPendingInstalls.get(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//调用 params 对象的 startCopy 函数，该函数由基类 HandlerParams 定义</span></span><br><span class="line">                    <span class="keyword">if</span> (params.startCopy()) &#123;</span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                        <span class="keyword">if</span> (mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            mPendingInstalls.remove(<span class="number">0</span>);<span class="comment">//删除队列头</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (mPendingInstalls.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">                                <span class="comment">//如果安装请求都处理完了，则需要和 Service 断绝联系,</span></span><br><span class="line">                                <span class="comment">//通过发送 MSC_UNB 消息处理断交请求</span></span><br><span class="line">                                removeMessages(MCS_UNBIND);</span><br><span class="line">                                Message ubmsg = obtainMessage(MCS_UNBIND);</span><br><span class="line">                                sendMessageDelayed(ubmsg, <span class="number">10000</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//如果还有未处理的请求，则继续发送 MCS_BOUND 消息。</span></span><br><span class="line">                            <span class="comment">//为什么不通过一个循环来处理所有请求呢</span></span><br><span class="line">                            mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MCS_BOUND 的处理还算简单，就是调用 HandlerParams 的 startCopy 函数。</p><p>PackageManagerService.java::HandlerParams.startCopy()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">booleanres;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//MAX_RETIRES 目前为 4，表示尝试 4 次安装，如果还不成功，则认为安装失败</span></span><br><span class="line"><span class="keyword">if</span>(++mRetries &gt; MAX_RETRIES) &#123;</span><br><span class="line">mHandler.sendEmptyMessage(MCS_GIVE_UP);</span><br><span class="line">handleServiceError();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handleStartCopy();<span class="comment">//调用派生类的 handleStartCopy 函数</span></span><br><span class="line">res= <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ...</span><br><span class="line"></span><br><span class="line">handleReturnCode();<span class="comment">//调用派生类的 handleReturnCode，返回处理结果</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，基类的 startCopy 将调用子类实现的 handleStartCopy 和 handleReturnCode 函数。下面来看 InstallParams 是如何实现这两个函数的。</p><h3 id="InstallParams-分析"><a href="#InstallParams-分析" class="headerlink" title="InstallParams 分析"></a>InstallParams 分析</h3><p>PackageManagerService::InstallParams.handleStartCopy()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartCopy</span><span class="params">()</span> throwsRemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> fwdLocked = (flags &amp;PackageManager.INSTALL_FORWARD_LOCK) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据 adb install 的参数，判断安装位置</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> onSd = (flags &amp; PackageManager.INSTALL_EXTERNAL) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> onInt = (flags &amp; PackageManager.INSTALL_INTERNAL) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">PackageInfoLite pkgLite = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(onInt &amp;&amp; onSd) &#123;</span><br><span class="line"><span class="comment">//APK 不能同时安装在内部存储和 SD 卡上</span></span><br><span class="line">ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fwdLocked &amp;&amp; onSd) &#123;</span><br><span class="line"><span class="comment">//fwdLocked 的应用不能安装在 SD 卡上</span></span><br><span class="line">ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> lowThreshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 DeviceStorageMonitorService 的 binder 客户端</span></span><br><span class="line"><span class="keyword">final</span> DeviceStorageMonitorService dsm = </span><br><span class="line">(DeviceStorageMonitorService) ServiceManager.getService(</span><br><span class="line">DeviceStorageMonitorService.SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dsm == <span class="keyword">null</span>) &#123;</span><br><span class="line">lowThreshold = <span class="number">0L</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//从 DSMS 查询内部空间最小余量，默认是总空间的10%</span></span><br><span class="line">lowThreshold = dsm.getMemoryLowThreshold();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//授权 DefContainerService URI 读权限</span></span><br><span class="line">mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE,</span><br><span class="line">packageURI,Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 DCS 的 getMinimalPackageInfo 函数，得到一个 PackageLite 对象，详见下面分析</span></span><br><span class="line">pkgLite = mContainerService.getMinimalPackageInfo(packageURI, flags,lowThreshold);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> <span class="comment">//...//撤销 URI 授权</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PacakgeLite 的 recommendedInstallLocation 成员变量保存该 APK 推荐的安装路径</span></span><br><span class="line"><span class="keyword">int</span> loc = pkgLite.recommendedInstallLocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loc == PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) &#123;</span><br><span class="line">ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>...&#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//根据 DCS 返回的安装路径，还需要调用 installLocationPolicy 进行检查</span></span><br><span class="line">loc = installLocationPolicy(pkgLite, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!onSd &amp;&amp; !onInt) &#123;</span><br><span class="line"><span class="keyword">if</span>(loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) &#123;</span><br><span class="line">flags |= PackageManager.INSTALL_EXTERNAL;</span><br><span class="line">flags &amp;=~PackageManager.INSTALL_INTERNAL;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//...//处理安装位置为内部存储的情况</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个安装参数对象，对于安装位置为内部存储的情况，args 的真实类型为 FileInstallArgs</span></span><br><span class="line"><span class="keyword">final</span> InstallArgs args = createInstallArgs(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">mArgs = args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> requiredUid = mRequiredVerifierPackage == <span class="keyword">null</span> ? -<span class="number">1</span> : getPackageUid(mRequiredVerifierPackage);</span><br><span class="line"><span class="keyword">if</span>(requiredUid != -<span class="number">1</span> &amp;&amp; isVerificationEnabled()) &#123;</span><br><span class="line"><span class="comment">//...//verification 的处理，这部分代码后续再介绍</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//调用 args 的 copyApk 函数</span></span><br><span class="line">ret = args.copyApk(mContainerService, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mRet = ret;<span class="comment">//确定返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，一共列出了五个关键点，总结如下：</p><ul><li>调用 DCS 的 getMinimalPackageInfo 函数，将得到一个 PackageLite 对象，该对象是一个轻量级的用于描述 APK 的结构（相比PackageParser.Package 来说）。在这段代码逻辑中，主要想取得其 recommendedInstallLocation 的值。此值表示该 APK 推荐的安装路径。</li><li>调用 installLocationPolicy 检查推荐的安装路径。例如：系统 Package 不允许安装在 SD 卡上。</li><li>createInstallArgs 将根据安装位置创建不同的 InstallArgs。如果是内部存储，则返回 FileInstallArgs，否则为 SdInstallArgs。</li><li>在正式安装前，应先对该 APK 进行必要的检查。这部分代码后续再介绍。</li><li>调用 InstallArgs 的 copyApk。对本例来说，将调用 FileInstallArgs 的 copyApk 函数。</li></ul><h3 id="DefaultContainerService-分析"><a href="#DefaultContainerService-分析" class="headerlink" title="DefaultContainerService 分析"></a>DefaultContainerService 分析</h3><p>DefaultContainerService.java::getMinimalPackageInfo()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PackageInfoLite <span class="title">getMinimalPackageInfo</span><span class="params">(finalUri fileUri, <span class="keyword">int</span> flags, longthreshold)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意该函数的参数：fileUri 指向该 APK 的文件路径（此时还在 /data/local/tmp 下）</span></span><br><span class="line">PackageInfoLite ret = <span class="keyword">new</span> PackageInfoLite();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">String scheme = fileUri.getScheme();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">String archiveFilePath = fileUri.getPath();</span><br><span class="line">DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">metrics.setToDefaults();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 PackageParser 的 parsePackageLite 解析该 APK 文件</span></span><br><span class="line"> PackageParser.PackageLite pkg =</span><br><span class="line">PackageParser.parsePackageLite(archiveFilePath,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;<span class="comment">//解析失败</span></span><br><span class="line"><span class="comment">//...//设置错误值</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret.packageName = pkg.packageName;</span><br><span class="line">ret.installLocation = pkg.installLocation;</span><br><span class="line">ret.verifiers = pkg.verifiers;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 recommendAppInstallLocation，取得一个合理的安装位置</span></span><br><span class="line">ret.recommendedInstallLocation =</span><br><span class="line"></span><br><span class="line">recommendAppInstallLocation(pkg.installLocation,archiveFilePath,</span><br><span class="line">           flags, threshold);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>APK 可在 AndroidManifest.xml 中声明一个安装位置，不过 DCS 除了解析该位置外，还需要做进一步检查，这个工作由 recommendAppInstallLocation 函数完成，代码如下：</p><p>DefaultContainerService.java::recommendAppInstallLocation()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recommendAppInstallLocation</span><span class="params">(intinstallLocation, </span></span></span><br><span class="line"><span class="function"><span class="params">StringarchiveFilePath, <span class="keyword">int</span> flags,<span class="keyword">long</span> threshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> prefer;</span><br><span class="line"><span class="keyword">boolean</span> checkBoth = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">check_inner: &#123;</span><br><span class="line"><span class="keyword">if</span>((flags &amp; PackageManager.INSTALL_FORWARD_LOCK) != <span class="number">0</span>) &#123;</span><br><span class="line">prefer = PREFER_INTERNAL;</span><br><span class="line"><span class="keyword">break</span> check_inner; <span class="comment">//根据 FOWRAD_LOCK 的情况，只能安装在内部存储</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; PackageManager.INSTALL_INTERNAL) != <span class="number">0</span>) &#123;</span><br><span class="line">prefer = PREFER_INTERNAL;</span><br><span class="line"><span class="keyword">break</span> check_inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...//检查各种情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(installLocation == PackageInfo.INSTALL_LOCATION_AUTO) &#123;</span><br><span class="line">prefer= PREFER_INTERNAL;<span class="comment">//一般设定的位置为 AUTO，默认是内部空间</span></span><br><span class="line">checkBoth = <span class="keyword">true</span>; <span class="comment">//设置checkBoth为true</span></span><br><span class="line">breakcheck_inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询 settings 数据库中的 secure 表，获取用户设置的安装路径</span></span><br><span class="line">intinstallPreference =</span><br><span class="line">Settings.System.getInt(getApplicationContext()</span><br><span class="line">.getContentResolver(),</span><br><span class="line"></span><br><span class="line">Settings.Secure.DEFAULT_INSTALL_LOCATION,</span><br><span class="line">PackageHelper.APP_INSTALL_AUTO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(installPreference == PackageHelper.APP_INSTALL_INTERNAL) &#123;</span><br><span class="line">prefer = PREFER_INTERNAL;</span><br><span class="line"><span class="keyword">break</span> check_inner;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(installPreference == PackageHelper.APP_INSTALL_EXTERNAL) &#123;</span><br><span class="line">prefer = PREFER_EXTERNAL;</span><br><span class="line">breakcheck_inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefer =PREFER_INTERNAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断外部存储空间是否为模拟的，这部分内容我们以后再介绍</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> emulated = Environment.isExternalStorageEmulated();</span><br><span class="line"><span class="keyword">final</span> FileapkFile = <span class="keyword">new</span> File(archiveFilePath);</span><br><span class="line"><span class="keyword">boolean</span> fitsOnInternal = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(checkBoth || prefer == PREFER_INTERNAL) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">//检查内部存储空间是否足够大</span></span><br><span class="line">fitsOnInternal = isUnderInternalThreshold(apkFile, threshold);</span><br><span class="line">&#125; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> fitsOnSd = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!emulated &amp;&amp; (checkBoth || prefer == PREFER_EXTERNAL)) &#123;</span><br><span class="line"><span class="keyword">try</span>&#123; <span class="comment">//检查外部存储空间是否足够大</span></span><br><span class="line">fitsOnSd = isUnderExternalThreshold(apkFile);</span><br><span class="line">&#125; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prefer== PREFER_INTERNAL) &#123;</span><br><span class="line"><span class="keyword">if</span>(fitsOnInternal) &#123;<span class="comment">//返回推荐安装路径为内部空间</span></span><br><span class="line"><span class="keyword">return</span> PackageHelper.RECOMMEND_INSTALL_INTERNAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!emulated &amp;&amp; prefer == PREFER_EXTERNAL) &#123;</span><br><span class="line"><span class="keyword">if</span>(fitsOnSd) &#123;<span class="comment">//返回推荐安装路径为外部空间</span></span><br><span class="line">returnPackageHelper.RECOMMEND_INSTALL_EXTERNAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(checkBoth) &#123;</span><br><span class="line"><span class="keyword">if</span>(fitsOnInternal) &#123;<span class="comment">//如果内部存储满足条件，先返回内部空间</span></span><br><span class="line"><span class="keyword">return</span> PackageHelper.RECOMMEND_INSTALL_INTERNAL;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (!emulated &amp;&amp; fitsOnSd) &#123;</span><br><span class="line"><span class="keyword">return</span> PackageHelper.RECOMMEND_INSTALL_EXTERNAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... //到此，前几个条件都不满足，此处将根据情况返回一个明确的错误值</span></span><br><span class="line"><span class="keyword">return</span> PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DCS 的 getMinimalPackageInfo 函数为了得到一个推荐的安装路径做了不少工作，其中，各种安装策略交叉影响。这里总结一下相关的知识点：</p><ul><li>APK 在 AndroidManifest.xml 中设置的安装点默认为 AUTO，在具体对应时倾向内部空间。</li><li>用户在 Settings 数据库中设置的安装位置。</li><li>检查外部存储或内部存储是否有足够空间。</li></ul><h3 id="InstallArgs-的-copyApk-函数分析"><a href="#InstallArgs-的-copyApk-函数分析" class="headerlink" title="InstallArgs 的 copyApk 函数分析"></a>InstallArgs 的 copyApk 函数分析</h3><p>至此，我们已经得到了一个合适的安装位置，下一步工作就由 copyApk 来完成。</p><p>PackageManagerService.java::InstallArgs.copyApk()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyApk</span><span class="params">(IMediaContainerService imcs, booleantemp)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            本例中temp参数为true，createCopyFile将在/data/app下创建一个临时文件。</span></span><br><span class="line"><span class="comment">            临时文件名为vmdl-随机数.tmp。为什么会用这样的文件名呢？</span></span><br><span class="line"><span class="comment">            因为PKMS通过Linux的inotify机制监控了/data/app,目录，如果新复制生成的文件名后缀</span></span><br><span class="line"><span class="comment">            为apk，将触发PKMS扫描。为了防止发生这种情况，这里复制生成的文件才有了</span></span><br><span class="line"><span class="comment">            如此奇怪的名字</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        createCopyFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FilecodeFile = <span class="keyword">new</span> File(codeFileName);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ParcelFileDescriptor out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = ParcelFileDescriptor.open(codeFile, ParcelFileDescriptor.MODE_READ_WRITE);</span><br><span class="line">    &#125;<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE,</span><br><span class="line">                                    packageURI, Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">        <span class="comment">//调用 DCS 的 copyResource，该函数将执行复制操作，最终结果是 /data/local/tmp</span></span><br><span class="line">        <span class="comment">//下的APK文件被复制到 /data/app 下，文件名也被换成 vmdl-随机数.tmp</span></span><br><span class="line">        ret = imcs.copyResource(packageURI, out);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//...//关闭 out，撤销 URI 授权</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handleReturnCode-分析"><a href="#handleReturnCode-分析" class="headerlink" title="handleReturnCode 分析"></a>handleReturnCode 分析</h3><p>在 HandlerParams 的 startCopy 函数中，handleStartCopy 执行完之后，将调用 handleReturnCode 开展后续工作，代码如下：</p><p>PackageManagerService.java::InstallParams.HandleParams()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用processPendingInstall函数，mArgs指向之前创建的FileInstallArgs对象</span></span><br><span class="line">        processPendingInstall(mArgs, mRet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPendingInstall</span><span class="params">(finalInstallArgs args, <span class="keyword">final</span> intcurrentStatus)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向 mHandler 中抛一个 Runnable 对象</span></span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHandler.removeCallbacks(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//创建一个 PackageInstalledInfo 对象，</span></span><br><span class="line">            PackageInstalledInfo res = <span class="keyword">new</span> PackageInstalledInfo();</span><br><span class="line">            res.returnCode = currentStatus;</span><br><span class="line">            res.uid = -<span class="number">1</span>;</span><br><span class="line">            res.pkg = <span class="keyword">null</span>;</span><br><span class="line">            res.removedInfo = <span class="keyword">new</span> PackageRemovedInfo();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                <span class="comment">//调用 FileInstallArgs 的 doPreInstall</span></span><br><span class="line">                args.doPreInstall(res.returnCode);</span><br><span class="line">                <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                    <span class="comment">//调用 installPackageLI 进行安装</span></span><br><span class="line">                    installPackageLI(args, <span class="keyword">true</span>, res);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用 FileInstallArgs 的 doPostInstall</span></span><br><span class="line">                args.doPostInstall(res.returnCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> update = res.removedInfo.removedPackage != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> doRestore = (!update &amp;&amp; res.pkg != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    res.pkg.applicationInfo.backupAgentName != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> token;<span class="comment">//计算一个ID号</span></span><br><span class="line">            <span class="keyword">if</span> (mNextInstallToken &lt; <span class="number">0</span>) mNextInstallToken = <span class="number">1</span>;</span><br><span class="line">            token = mNextInstallToken++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建一个 PostInstallData 对象</span></span><br><span class="line">            PostInstallData data = <span class="keyword">new</span> PostInstallData(args, res);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存到 mRunningInstalls 结构中，以 token 为 key</span></span><br><span class="line">            mRunningInstalls.put(token, data);</span><br><span class="line">            <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore)&#123;</span><br><span class="line">             <span class="comment">//...//备份恢复的情况暂时不考虑</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!doRestore) &#123;</span><br><span class="line">                <span class="comment">//抛一个 POST_INSTALL 消息给 mHandler 进行处理</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, <span class="number">0</span>);</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可知，handleReturnCode 主要做了 4 件事情：</p><ul><li>调用 InstallArgs 的 doPreInstall 函数，在本例中是 FileInstallArgs 的 doPreInstall 函数。</li><li>调用 PKMS 的 installPackageLI 函数进行 APK 安装，该函数内部将调用 InstallArgs的doRename 对临时文件进行改名。另外，还需要扫描此 APK 文件。此过程和之前介绍的“扫描系统 Package”一节的内容类似。至此，该 APK 中的私有财产就全部被登记到 PKMS 内部进行保存了。</li><li>调用 InstallArgs 的 doPostInstall 函数，在本例中是 FileInstallArgs 的 doPostInstall 函数。</li><li>此时，该 APK 已经安装完成（不论失败还是成功），继续向 mHandler 抛送一个 POST_INSTALL 消息，该消息携带一个 token，通过它可从 mRunningInstalls 数组中取得一个 PostInstallData 对象。</li></ul><p>这里介绍一下 FileInstallArgs 的 doRename 函数，它的功能是将临时文件改名，最终的文件的名称一般为“包名-数字.apk”。其中，数字是一个 index，从 1 开始。</p><h3 id="POST-INSTALL-处理"><a href="#POST-INSTALL-处理" class="headerlink" title="POST_INSTALL 处理"></a>POST_INSTALL 处理</h3><p>PackageManagerService.java::doHandleMessage()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INIT_COPY: &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MCS_BOUND: &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> POST_INSTALL: &#123;</span><br><span class="line">            PostInstallData data = mRunningInstalls.get(msg.arg1);</span><br><span class="line">            mRunningInstalls.delete(msg.arg1);</span><br><span class="line">            <span class="keyword">boolean</span> deleteOld = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                InstallArgs args = data.args;</span><br><span class="line">                PackageInstalledInfo res = data.res;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                    <span class="keyword">final</span> String packageName = res.pkg.applicationInfo.packageName;</span><br><span class="line">                    res.removedInfo.sendBroadcast(<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                    Bundle extras = <span class="keyword">new</span> Bundle(<span class="number">1</span>);</span><br><span class="line">                    extras.putInt(Intent.EXTRA_UID, res.uid);</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> update = res.removedInfo.removedPackage != <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (update) &#123;</span><br><span class="line">                        extras.putBoolean(Intent.EXTRA_REPLACING, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//发送 PACKAGE_ADDED 广播</span></span><br><span class="line">                    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,</span><br><span class="line">                                         packageName, extras, <span class="keyword">null</span>, <span class="keyword">null</span>, updateUsers);</span><br><span class="line">                    <span class="keyword">if</span> (update) &#123;</span><br><span class="line">                        <span class="comment">//如果是 APK 升级，那么发送 PACKAGE_REPLACE 和 MY_PACKAGE_REPLACED 广播</span></span><br><span class="line">                        <span class="comment">//二者不同之处在于 PACKAGE_REPLACE 将携带一个 extra 信息</span></span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">                Runtime.getRuntime().gc();</span><br><span class="line">                <span class="keyword">if</span> (deleteOld) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                        <span class="comment">//调用 FileInstallArgs 的 doPostDeleteLI 进行资源清理</span></span><br><span class="line">                        res.removedInfo.args.doPostDeleteLI(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (args.observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 向 pm 通知安装的结果</span></span><br><span class="line">                        Bundle extras = extrasForInstallResult(res);</span><br><span class="line">                        args.observer.onPackageInstalled(res.name, res.returnCode,</span><br><span class="line">                                                         res.returnMsg, extras);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        Slog.i(TAG, <span class="string">"Observer no longer exists."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Bogus post-install token "</span> + msg.arg1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Apk-安装流程总结"><a href="#Apk-安装流程总结" class="headerlink" title="Apk 安装流程总结"></a>Apk 安装流程总结</h3><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_pkms/08.png?raw=true" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://blog.csdn.net/innost/article/details/47253179" target="_blank" rel="noopener">深入理解 PackagerManagerService</a></li><li><a href="http://gityuan.com/2016/11/06/packagemanager/" target="_blank" rel="noopener">PackageManager 启动篇</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> PackageMangerService </tag>
            
            <tag> PKMS </tag>
            
            <tag> 工作流程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 虚拟机内存分配机制</title>
      <link href="/2018/07/06/jvm-memory/"/>
      <url>/2018/07/06/jvm-memory/</url>
      <content type="html"><![CDATA[<h1 id="Java-虚拟机内存分配机制"><a href="#Java-虚拟机内存分配机制" class="headerlink" title="Java 虚拟机内存分配机制"></a>Java 虚拟机内存分配机制</h1><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>对于大多数的程序员来说，Java 内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的“堆”对应内存模型的 Java 堆，“栈”是指虚拟机栈，然而 Java 内存模型远比这更复杂，想深入了解 Java 的内存，还是有必要明白整个内存区域分。</p><p>了解 Java GC 机制，必须先清楚在 JVM 中内存区域的划分。 在 Java 运行时的数据区里，由 JVM 管理的内存区域分为下图几个模块：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/jvm_memory_area.png?raw=true" alt="JVM 内存划分"></p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。 字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。</p><p>每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。</p><p>如果程序执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（ native，由 C 语言编写完成）方法，则计数器的值为 Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义 OutOfMemoryError 的区域。</p><h3 id="虚拟机栈（JVM-Stack）"><a href="#虚拟机栈（JVM-Stack）" class="headerlink" title="虚拟机栈（JVM Stack）"></a>虚拟机栈（JVM Stack）</h3><p>一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作数栈、动态链接、方法出口等，当方法被调用时，栈帧在 JVM 栈中入栈，当方法执行完成时，栈帧出栈。</p><p>局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。 在局部变量表中，只有 long 和 double 类型会占用 2 个局部变量空间（Slot，对于32位机器，一个 Slot 就是 32 个 bit），其它都是 1 个 Slot。 需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。</p><p>虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出 StatckOverFlowError（栈溢出）；不过多数 Java 虚拟机都允许动态扩展虚拟机栈的大小（有少部分是固定长度的），所以线程可以一直申请栈，直到内存不足，此时，会抛出 OutOfMemoryError（内存溢出）。</p><p>每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p><h3 id="本地方法栈（Native-Method-Statck）"><a href="#本地方法栈（Native-Method-Statck）" class="headerlink" title="本地方法栈（Native Method Statck）"></a>本地方法栈（Native Method Statck）</h3><p>本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行 Java 方法的，而本地方法栈是用来执行 native 方法的，在很多虚拟机中（如：Sun 的 JDK 默认的 HotSpot 虚拟机），会将本地方法栈与虚拟机栈放在一起使用。</p><p>本地方法栈也是线程私有的。</p><h3 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h3><p>堆区是理解 Java GC 机制最重要的区域，没有之一。 在 JVM 所管理的内存中，堆区是最大的一块，堆区也是 Java GC 机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。 堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。</p><p>一般的，根据 Java 虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。 如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出 OutOfMemoryError:Java heap space 异常。</p><p>关于堆区的内容还有很多，将在下面“内存分配机制”中详细介绍。</p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>在 Java 虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将 Java GC 的分代收集机制分为 3 个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的 HotSpot Java 虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。 不过，除 HotSpot 之外的多数虚拟机，并不将方法区当做永久代，HotSpot 本身，也计划取消永久代。 本文中，由于主要使用 Oracle JDK6.0，因此仍将使用永久代一词。</p><p>方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final 常量、静态变量、编译器即时编译的代码等。</p><p>方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。 一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。</p><p>在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。</p><p>在方法区上定义了 OutOfMemoryError:PermGen space 异常，在内存不足时抛出。</p><ul><li><strong>运行时常量池（Runtime Constant Pool）</strong> </li></ul><p>方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如 String 类的 intern() 方法，作用是 String 维护了一个常量池，如果调用的字符 “abc” 已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。</p><h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>直接内存并不是 JVM 管理的内存，可以这样理解，直接内存，就是 JVM 以外的机器内存。</p><p>比如：你有 4G 的内存，JVM占用了1G，则其余的 3G 就是直接内存，JDK 中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由 C 语言实现的 native 函数库分配在直接内存中，用存储在 JVM 堆中的 DirectByteBuffer 来引用。 由于直接内存受到本机器内存的限制，所以也可能出现 OutOfMemoryError 的异常。</p><h2 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h2><p>以下面代码为例，来分析，Java 的实例对象在内存中的空间分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JVM 启动时将 Person.class 放入方法区</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new Person 创建实例后，name 引用放入堆区，name 对象放入常量池</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new Person 创建实例后，age = 0 放入堆区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 方法放入方法区，方法内代码作为 Code 属性放入方法区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//toString 方法放入方法区，方法内代码作为 Code 属性放入方法区</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JVM 启动时将 Test.class 放入方法区</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main 方法放入方法区，方法内代码作为 Code 属性放入方法区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//person1 是引用放入虚拟机栈区，new 关键字开辟堆内存 Person 自定义对象放入堆区</span></span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 person 引用创建 toString() 方法栈帧</span></span><br><span class="line">        person1.toString();</span><br><span class="line">        person2.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先 JVM 会将 Test.class, Person.class 加载到方法区，找到有 main() 方法的类开始执行。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/jvm_memory_area_simple1.png?raw=true" alt="JVM 内存划分 实例1"></p><p>如上图所示，JVM 找到 main() 方法入口，创建 main() 方法的栈帧放入虚拟机栈，开始执行 main() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>执行到这句代码时，JVM 会先创建 Person </p><p>实例放入堆区，person2 也同理。</p><ol start="2"><li>创建完 Person 两个实例，main() 方法中的 person1，person2 会指向堆区中的 0x001，0x002（这里的内存地址仅作为示范）。紧接着会调用 Person 的构造函数进行赋值，如下图：</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/jvm_memory_area_simple2.png?raw=true" alt="JVM 内存划分 实例2"></p><p>如上图所示，新创建的的 Person 实例中的 name, age 开始都是默认值。 调用构造函数之后进行赋值，name 是 String 引用类型，会在常量池中创建并将地址赋值给 name，age 是基本数据类型将直接保存数值。</p><p>注：Java 中基本类型的包装类的大部分都实现了常量池技术，这些类是 Byte, Short, Integer, Long, Character, Boolean，另外两种浮点数类型的包装类则没有实现。</p><table><thead><tr><th style="text-align:left">基本数据类型</th><th style="text-align:left">包装类 （是否实现了常量池技术）</th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">Byte    是</td></tr><tr><td style="text-align:left">boolean</td><td style="text-align:left">Boolean    是</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">Short    是</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">Character    是</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">Integer    是</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">Long    是</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">Float    否</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">Double    否</td></tr></tbody></table><ol start="3"><li>Person 实例初始化完后，执行到 toString() 方法，同 main() 方法一样 JVM 会创建一个 toString() 的栈帧放入虚拟机栈中，执行完之后返回一个值。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/jvm_memory_area_simple3.png?raw=true" alt="JVM 内存划分 实例3"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入理解 Java 虚拟机》</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Java 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 虚拟机 </tag>
            
            <tag> 内存分配机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 虚拟机垃圾回收机制</title>
      <link href="/2018/06/16/jvm-gc/"/>
      <url>/2018/06/16/jvm-gc/</url>
      <content type="html"><![CDATA[<h1 id="Java-虚拟机垃圾回收机制"><a href="#Java-虚拟机垃圾回收机制" class="headerlink" title="Java 虚拟机垃圾回收机制"></a>Java 虚拟机垃圾回收机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>垃圾回收是一种自动的存储管理机制。 当一些被占用的内存不再需要时，就应该予以释放，以让出空间，这种存储资源管理，称为垃圾回收（Garbage Collection）。 垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。</p><h2 id="哪些对象需要回收？"><a href="#哪些对象需要回收？" class="headerlink" title="哪些对象需要回收？"></a>哪些对象需要回收？</h2><p>自动垃圾回收机制就是寻找Java堆中的对象，并对对象进行分类判别，寻找出正在使用的对象和已经不会使用的对象，然后把那些不会使用的对象从堆上清除。</p><ul><li>引用计数法</li></ul><p>引用计数算法是垃圾收集器中的早期策略。 在这种方法中，堆中的每个对象实例都有一个引用计数。 当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。 当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。 特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。 任何引用计数为0的对象实例可以被当作垃圾收集。</p><p>引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题</p><ul><li>可达性分析</li></ul><p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。 当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_reference_chain.jpg?raw=true" alt="可达性分析"></p><h2 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h2><ul><li>标记-清除算法</li></ul><ol><li>标记，也就是垃圾收集器会找出那些需要回收的对象所在的内存和不需要回收的对象所在的内存，并把它们标记出来，简单的说，也就是先找出垃圾在哪儿？</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_marking.jpg?raw=true" alt="标记"></p><p>所有堆中的对象都会被扫描一遍，以此来确定回收的对象，所以这通常会是一个相对比较耗时的过程。</p><ol start="2"><li>清除，垃圾收集器会清除掉上一步标记出来的那些需要回收的对象区域。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_clean.jpg?raw=true" alt="清除"></p><p>存在的问题就是碎片问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><ul><li>复制算法</li></ul><p>标记清除算法每次执行都需要对堆中全部对象扫面一遍效率不高，为解决效率问题，复制算法将内存按容量划分为大小相等的两块，每次只是用其中的一块。 当这一块使用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都对半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_copy.jpg?raw=true" alt="复制算法"></p><ul><li>标记-整理算法</li></ul><p>由于简单的标记清除可能会存在碎片的问题，所以又出现了压缩清除的方法，也就是先清除需要回收的对象，然后再对内存进行压缩操作，将内存分成可用和不可用两大部分。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_compacting.jpg?raw=true" alt="压缩"></p><h2 id="内存分代"><a href="#内存分代" class="headerlink" title="内存分代"></a>内存分代</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generation Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。 一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率较高、没有额外的空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来回收。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_heap_structure.jpg?raw=true" alt="内存分代"></p><ul><li>新生代</li></ul><p>所有新 new 出来的对象都会最先出现在新生代中，当新生代这部分内存满了之后，就会发起一次垃圾收集事件，这种发生在新生代的垃圾收集称为 Minor collections。 这种收集通常比较快，因为新生代的大部分对象都是需要回收的，那些暂时无法回收的就会被移动到老年代。</p><p>全局暂停事件（Stop the World）：所有小收集（minor garbage collections）都是全局暂停事件，也就是意味着所有的应用线程都需要停止，直到垃圾回收的操作全部完成。类似于“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”</p><ul><li>老年代</li></ul><p>老年代用来存储那些存活时间较长的对象。 一般来说，我们会给新生代的对象限定一个存活的时间，当达到这个时间还没有被收集的时候就会被移动到老年代中。随着时间的推移，老年代也会被填满，最终导致老年代也要进行垃圾回收。这个事件叫做大收集(major garbage collection)。</p><p>大收集也是全局暂停事件。通常大收集比较慢，因为它涉及到所有的存活对象。所以，对于对相应时间要求高的应用，应该将大收集最小化。此外，对于大收集，全局暂停事件的暂停时长会受到用于老年代的垃圾回收器的影响。</p><ul><li>永久代</li></ul><p>永久代存储了描述应用程序类和方法的元数据，JVM 运行应用程序的时候需要这些元数据。 永久代由 JVM 在运行时基于应用程序所使用的类产生。 此外，Java SE 类库的类和方法可能也存储在这里。</p><p>如果 JVM 发现有些类不在被其他类所需要，同时其他类需要更多的空间，这时候这些类可能就会被垃圾回收。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_heap_structure_desc.jpg?raw=true" alt="内存分代详细"></p><h2 id="分代垃圾回收过程"><a href="#分代垃圾回收过程" class="headerlink" title="分代垃圾回收过程"></a>分代垃圾回收过程</h2><p>我们已经知道垃圾回收所需要的方法和堆内存的分代，那么接下来我们就来具体看一下垃圾回收的具体过程。</p><ol><li>第一步 所有 new 出来的对象都会最先分配到新生代区域中，两个 survivor 区域初始化是为空的。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection1.jpg?raw=true" alt="内存分代收集1"></p><ol start="2"><li>第二步，当 eden 区域满了之后，就引发一次小收集（minor garbage collections）。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection2.jpg?raw=true" alt="内存分代收集2"></p><ol start="3"><li>第三步，当在小收集（minor garbage collections）存活下来的对象就会被移动到 S0 survivor 区域。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection3.jpg?raw=true" alt="内存分代收集3"></p><ol start="4"><li>第四步，然后当 eden 区域又填满的时候，又会发生下一次的垃圾回收，存活的对象会被移动到 survivor 区域而未存活对象会被直接删除。 但是，不同的是，在这次的垃圾回收中，存活对象和之前的 survivor 中的对象都会被移动到 s1 中。 一旦所有对象都被移动到 s1 中，那么 s2 中的对象就会被清除，仔细观察图中的对象，数字表示经历的垃圾收集的次数。 目前我们已经有不同的年龄对象了。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection4.jpg?raw=true" alt="内存分代收集4"></p><ol start="5"><li>第五步，下一次垃圾回收的时候，又会重复上次的步骤，清除需要回收的对象，并且又切换一次 survivor 区域，所有存活的对象都被移动至 s0。 eden 和 s1 区域被清除。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection5.jpg?raw=true" alt="内存分代收集5"></p><ol start="6"><li>第六步，重复以上步骤，并记录对象的年龄，当有对象的年龄到达一定的阈值的时候，就将新生代中的对象移动到老年代中。在本例中，这个阈值为8。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection6.jpg?raw=true" alt="内存分代收集6"></p><ol start="7"><li>第七步，接下来垃圾收集器就会重复以上步骤，不断的进行对象的清除和年代的移动。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection7.jpg?raw=true" alt="内存分代收集7"></p><ol start="8"><li>最后，我们观察上述过程可以发现，大部分的垃圾收集过程都是在新生代进行的，直到老年代中的内存不够用了才会发起一次 大收集(major garbage collection)，会进行标记和整理压缩。</li></ol><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/jvm/gc_collection8.jpg?raw=true" alt="内存分代收集8"></p><h2 id="垃圾回收器的类型"><a href="#垃圾回收器的类型" class="headerlink" title="垃圾回收器的类型"></a>垃圾回收器的类型</h2><p>Java 提供多种类型的垃圾回收器。 JVM 中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p><ul><li>Serial 收集器：新生代收集器，使用复制算法，使用一个线程进行 GC，串行，其它工作线程暂停。</li><li>ParNew 收集器：新生代收集器，使用复制算法，Serial 收集器的多线程版，用多个线程进行 GC，并行，其它工作线程暂停。 使用 -XX:+UseParNewGC 开关来控制使用 ParNew+Serial Old 收集器组合收集内存；使用 -XX:ParallelGCThreads 来设置执行内存回收的线程数。</li><li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注 CPU 吞吐量，即运行用户代码的时间/总时间。 使用 -XX:+UseParallelGC 开关控制使用 Parallel Scavenge+Serial Old 收集器组合回收垃圾。</li><li>Serial Old 收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li><li>Parallel Old 收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与 Parallel Scavenge 差不错，使用标记整理算法，在 Parallel Old 执行时，仍然需要暂停其它线程。</li><li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。 使用 -XX:+UseConcMarkSweepGC 进行 ParNew+CMS+Serial Old 进行内存回收，优先使用 ParNew+CMS，当用户线程内存不足时，采用备用方案 Serial Old 收集。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入理解 Java 虚拟机》</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Java 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 虚拟机 </tag>
            
            <tag> 垃圾回收机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章看明白 HTTP，HTTPS，SSL/TSL 之间的关系</title>
      <link href="/2018/05/22/internet-http-https/"/>
      <url>/2018/05/22/internet-http-https/</url>
      <content type="html"><![CDATA[<h1 id="HTTP，HTTPS，SSL-TSL"><a href="#HTTP，HTTPS，SSL-TSL" class="headerlink" title="HTTP，HTTPS，SSL/TSL"></a>HTTP，HTTPS，SSL/TSL</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="什么是-HTTP-？"><a href="#什么是-HTTP-？" class="headerlink" title="什么是 HTTP ？"></a>什么是 HTTP ？</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。【摘自百度百科】</p><p>伴随着计算机网络和浏览器的诞生，HTTP1.0 也随之而来，处于计算机网络中的应用层，HTTP 是建立在 TCP 协议之上，所以 HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/http_version.jpg?raw=true" alt="http 版本"></p><p>早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从 Web 服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的 HTML 页面将要放在我们的 web 服务器上，用户端通过浏览器访问 url 地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。 </p><p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。简单来说，HTTP 是一个网络协议，专门用来帮你传输 Web 内容的。</p><h2 id="HTTP-和-TCP-之间的关系"><a href="#HTTP-和-TCP-之间的关系" class="headerlink" title="HTTP 和 TCP 之间的关系"></a>HTTP 和 TCP 之间的关系</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/http_tcp.jpg?raw=true" alt="http TCP"></p><p>简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/http_connect.jpg?raw=true" alt="http connect"></p><p>HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接(Keep-Alive)”又称“持久连接(Persistent Connection)”）。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/http_connect_simple.jpg?raw=true" alt="http simple"></p><p>假设有一个网页，里面包含好多图片，还包含好多【外部的】 CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/http_connect_keep.jpg?raw=true" alt="http keep"></p><p>相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。</p><p>在 HTTP 1.0 版本，【默认】使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）；<br>到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”的）。所以，在 HTTP 1.1 中，【默认】采用的是“Keep-Alive”的方式。</p><h2 id="URI-和-URL-之间的关系"><a href="#URI-和-URL-之间的关系" class="headerlink" title="URI 和 URL 之间的关系"></a>URI 和 URL 之间的关系</h2><ul><li>URI （Uniform Resource Identifier，统一资源标识符）。 </li></ul><p>URI 属于 URL 更高层次的抽象，一种字符串文本标准。就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。<br>二者的区别在于，URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（http://）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ftp://ftp.is.co.za/rfc/rfc1808.txt (URL)</span><br><span class="line">http://www.ietf.org/rfc/rfc2396.txt (URL)</span><br><span class="line">ldap://[2001:db8::7]/c=GB?objectClass?one (URL)</span><br><span class="line">mailto:John.Doe@example.com (URL)</span><br><span class="line">news:comp.infosystems.www.servers.unix (URL)</span><br><span class="line">tel:+1-816-555-1212</span><br><span class="line">telnet://192.0.2.16:80/ (URL)</span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span><br></pre></td></tr></table></figure><p><a href="http://www.iana.org/assignments/uri-schemes" target="_blank" rel="noopener">IANA - Uniform Resource Identifier (URI) SCHEMES（统一资源标识符方案）</a></p><p>具体详见：<a href="http://baike.baidu.com/item/URI" target="_blank" rel="noopener">http://baike.baidu.com/item/URI</a></p><ul><li>URL（Uniform Resource Locator，统一资源定位符）</li></ul><p>通常而言，我们所熟悉的 URL 的常见定义格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]</span><br></pre></td></tr></table></figure><blockquote><p>scheme //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。</p><p>host   //HTTP服务器的IP地址或者域名</p><p>port#  //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>path   //访问资源的路径</p><p>url-params  //所带参数 </p><p>query-string    //发送给http服务器的数据</p><p>anchor //锚点定位</p></blockquote><p>具体详见：<a href="http://baike.baidu.com/item/URL" target="_blank" rel="noopener">http://baike.baidu.com/item/URL</a></p><h2 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h2><ol><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ol><h2 id="HTTPS-的诞生"><a href="#HTTPS-的诞生" class="headerlink" title="HTTPS 的诞生"></a>HTTPS 的诞生</h2><p>为了解决 HTTP 协议的以上缺点，在上世纪90年代中期，由网景（NetScape）公司设计了 SSL 协议。SSL 是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）。</p><p>到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。</p><p>很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</p><p>互联网加密协议历史：</p><ul><li>1994年，NetScape 公司设计了 SSL 协议的1.0版，但是未发布。</li><li>1995年，NetScape 公司发布 SSL 2.0版，很快发现有严重漏洞。</li><li>1996年，SSL 3.0 版问世，得到大规模应用。</li><li>1999年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。</li><li>2006年和2008年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版。最新的变动是2011年 TLS 1.2 的修订版。</li></ul><p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。<br>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p><p>所谓的 HTTPS 其实是“HTTP over SSL”或“HTTP over TLS”，它是 HTTP 与 SSL/TSL 的结合使用而已。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/http_https.jpg?raw=true" alt="http https"></p><h2 id="“对称加密”与“非对称加密”"><a href="#“对称加密”与“非对称加密”" class="headerlink" title="“对称加密”与“非对称加密”"></a>“对称加密”与“非对称加密”</h2><ul><li>明文传输消息</li></ul><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/pass_none.jpg?raw=true" alt="pass_none"></p><ul><li>“加密”和“解密”</li></ul><p>通俗而言，你可以把“加密”和“解密”理解为某种【互逆的】数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。<br>“加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东西——叫做“密钥”——来参与数学运算。</p><ul><li>“对称加密”</li></ul><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/pass_key.jpg?raw=true" alt="pass_key"></p><p>所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。</p><p>存在疑问：密钥怎么传输？<br>如果密钥可以安全的传输，那么消息也应该可以安全的传输，就像蛋生鸡，鸡生蛋一样。</p><ul><li>“非对称加密”</li></ul><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/pass_pub_pre_key.jpg?raw=true" alt="pass_pub_pre_key"></p><p>所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用【不同的】密钥。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。</p><p>被劫持情况：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/pass_pub_hacker.jpg?raw=true" alt="pass_pub_hacker"></p><p>窃听者可以伪造服务器的公钥与客户端通讯，客户端以为是跟服务器通讯，其实是与窃听者在通讯，后果可想而知。</p><h2 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h2><p>CA 是 PKI 系统中通信双方信任的实体，被称为可信第三方（Trusted Third Party，简称TTP）。　CA 证书，顾名思义，就是 CA 颁发的证书。</p><p>CA 的初始是为了解决上面非对称加密被劫持的情况，服务器申请 CA 证书时将服务器的“公钥”提供给 CA，CA 使用自己的“私钥”将“服务器的公钥”加密后（即：CA证书）返回给服务器，服务器再将“CA 证书”提供给客户端。一般系统或者浏览器会内置 CA 的根证书（公钥），</p><p>HTTPS 中 CA 证书的获取<br><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/https_ca.jpg?raw=true" alt="https_ca"></p><p>注：上图步骤 2 之后，客户端获取到“CA 证书”会进行本地验证，即使用本地系统或者浏览器中的公钥进行解密，每个“CA 证书”都会有一个证书编号可用于解密后进行比对（具体验证算法请查阅相关资料）。</p><p>步骤 5 之前使用的是对称加密，之后将使用对称加密来提高通讯效率。</p><h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，缩短 Web 页面的加载时间（50%）。</p><p><a href="http://www.chromium.org/spdy/" target="_blank" rel="noopener">SPDY- The Chromium Projects</a></p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/http_spdy.jpg?raw=true" alt="http_spdy"></p><p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><p>具体详见：<a href="http://baike.baidu.com/item/SPDY" target="_blank" rel="noopener">http://baike.baidu.com/item/SPDY</a></p><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：<br>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。<br>HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE。</p><p>具体详见：<a href="http://baike.baidu.com/item/HTTP%202.0" target="_blank" rel="noopener">http://baike.baidu.com/item/HTTP%202.0</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《图解HTTP》、《图解TCP/IP》、百度百科</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> 网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> SSL </tag>
            
            <tag> TSL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章看明白 TCP/IP，TCP，UDP，IP，Socket 之间的关系</title>
      <link href="/2018/05/05/internet-tcp-ip/"/>
      <url>/2018/05/05/internet-tcp-ip/</url>
      <content type="html"><![CDATA[<h1 id="TCP-IP，TCP，UDP，IP，Socket"><a href="#TCP-IP，TCP，UDP，IP，Socket" class="headerlink" title="TCP/IP，TCP，UDP，IP，Socket"></a>TCP/IP，TCP，UDP，IP，Socket</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>什么是 TCP/IP？</li><li>TCP，UDP 有什么区别？</li><li>什么是 Socket？</li></ul><p>网上这方面的资料有很多，但都很琐碎，没有系统化，要么看完很快就忘记了，要么就是看完迷迷糊糊似懂非懂，下面我们来一一攻破以上问题。</p><h2 id="什么是-TCP-IP-？"><a href="#什么是-TCP-IP-？" class="headerlink" title="什么是 TCP/IP ？"></a>什么是 TCP/IP ？</h2><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p><p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。</p><blockquote><p>个人认为，因为 TCP/IP 族内的协议有很多，为了突出 TCP 与 IP 这两个协议的重要性，所以就用 TCP/IP 来表示 TCP/IP 协议族了。</p></blockquote><h2 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/tcp_osi.jpg?raw=true" alt="参考模型"></p><ul><li>OSI 参考模型</li></ul><p>OSI 参考模型是 ISO 的建议，它是为了使各层上的协议国际标准化而发展起来的。OSI 参考模型全称是开放系统互连参考模型(Open System Interconnection Reference Model)。这一参考模型共分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><ul><li>TCP/IP 参考模型</li></ul><p>TCP/IP 参考模型是首先由 ARPANET 所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为 TCP/IP 参考模型(TCP/IP Reference Model)。这一网络协议共分为四层：数据链路层、网络层、传输层和应用层。</p><h2 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP/IP 的分层管理"></a>TCP/IP 的分层管理</h2><p>TCP/IP 协议族里重要的一点就是分层。把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。</p><p>值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。</p><table><thead><tr><th style="text-align:left">OSI中的层</th><th style="text-align:left">功能</th><th style="text-align:left">TCP/IP协议族</th></tr></thead><tbody><tr><td style="text-align:left">7 应用层</td><td style="text-align:left">文件传输，电子邮件，文件服务，虚拟终端</td><td style="text-align:left">TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等</td></tr><tr><td style="text-align:left">6 表示层</td><td style="text-align:left">数据格式化，代码转换，数据加密</td><td style="text-align:left">没有协议</td></tr><tr><td style="text-align:left">5 会话层</td><td style="text-align:left">解除或建立与别的接点的联系</td><td style="text-align:left">没有协议</td></tr><tr><td style="text-align:left">4 传输层</td><td style="text-align:left">提供端对端的接口</td><td style="text-align:left">TCP，UDP</td></tr><tr><td style="text-align:left">3 网络层</td><td style="text-align:left">为数据包选择路由</td><td style="text-align:left">IP，ICMP，OSPF，EIGRP，IGMP</td></tr><tr><td style="text-align:left">2 数据链路层</td><td style="text-align:left">传输有地址的帧以及错误检测功能</td><td style="text-align:left">SLIP，CSLIP，PPP，MTU</td></tr><tr><td style="text-align:left">1 物理层</td><td style="text-align:left">以二进制数据形式在物理媒体上传输数据</td><td style="text-align:left">ISO2110，IEEE802，IEEE802.2</td></tr></tbody></table><ul><li>数据链路层</li></ul><p>数据链路层是负责接收 IP 数据包并通过网络发送，或者从网络上接收物理帧，抽出 IP 数据包，交给 IP 层。</p><p>ARP 是正向地址解析协议，通过已知的 IP，寻找对应主机的 MAC 地址。</p><p>RARP 是反向地址解析协议，通过 MAC 地址确定 IP 地址。比如无盘工作站还有 DHCP 服务。</p><p>常见的接口层协议有：<br>Ethernet 802.3、Token Ring 802.5、X.25、Frame relay、HDLC、PPP ATM等。</p><ul><li>网络层</li></ul><p>负责相邻计算机之间的通信。其功能包括三方面。</p><ol><li>处理来自传输层的分组发送请求，收到请求后，将分组装入 IP 数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。</li><li>处理输入数据报：首先检查其合法性，然后进行寻径–假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。</li><li>处理路径、流控、拥塞等问题。</li></ol><p>网络层包括：IP(Internet Protocol) 协议、ICMP(Internet Control Message Protocol)</p><p>控制报文协议、ARP(Address Resolution Protocol) 地址转换协议、RARP(Reverse ARP) 反向地址转换协议。</p><p>IP 是网络层的核心，通过路由选择将下一条IP封装后交给接口层。IP数据报是无连接服务。</p><p>ICMP 是网络层的补充，可以回送报文。用来检测网络是否通畅。</p><p>Ping 命令就是发送 ICMP 的 echo 包，通过回送的 echo relay 进行网络测试。</p><ul><li>传输层</li></ul><p>提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送，即耳熟能详的“三次握手”过程，从而提供可靠的数据传输。</p><p>传输层协议主要是：传输控制协议 TCP(Transmission Control Protocol) 和用户数据报协议 UDP(User Datagram protocol)。</p><ul><li>应用层</li></ul><p>向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录 TELNET 使用 TELNET 协议提供在网络其它主机上注册的接口。TELNET 会话提供了基于字符的虚拟终端。文件传输访问 FTP 使用 FTP 协议来提供网络内机器间的文件拷贝功能。</p><p>应用层协议主要包括如下几个：FTP、TELNET、DNS、SMTP、NFS、HTTP。</p><p>FTP(File Transfer Protocol）是文件传输协议，一般上传下载用FTP服务，数据端口是 20H，控制端口是 21H。</p><p>Telnet 服务是用户远程登录服务，使用 23H 端口，使用明码传送，保密性差、简单方便。</p><p>DNS(Domain Name Service）是域名解析服务，提供域名到 IP 地址之间的转换，使用端口 53。</p><p>SMTP(Simple Mail Transfer Protocol）是简单邮件传输协议，用来控制信件的发送、中转，使用端口 25。</p><p>NFS（Network File System）是网络文件系统，用于网络中不同主机间的文件共享。</p><p>HTTP(Hypertext Transfer Protocol）是超文本传输协议，用于实现互联网中的 WWW 服务，使用端口 80。</p><h2 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><ul><li>连接建立</li></ul><p>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答 SYN + ACK ，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p><p>TCP三次握手的过程如下：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/tcp_start.jpg?raw=true" alt="连接建立"></p><ol><li>客户端发送 SYN（SEQ=x）报文给服务器端，进入 SYN_SEND 状态。</li><li>服务器端收到 SYN 报文，回应一个 SYN （SEQ=y）ACK(ACK=x+1）报文，进入 SYN_RECV 状态。</li><li>客户端收到服务器端的 SYN 报文，回应一个 ACK(ACK=y+1）报文，进入 Established 状态。</li></ol><p>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</p><ul><li>连接终止</li></ul><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。具体过程如下图所示。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/tcp_end.jpg?raw=true" alt="连接终止"></p><ol><li>某个应用进程首先调用 close，称该端执行“主动关闭”（active close）。该端的 TCP 于是发送一个 FIN 分节，表示数据发送完毕。</li><li>接收到这个 FIN 的对端执行 “被动关闭”（passive close），这个 FIN 由 TCP 确认。<blockquote><p>注意：FIN 的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN 的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</p></blockquote></li><li>一段时间后，接收到这个文件结束符的应用进程将调用 close 关闭它的套接字。这导致它的 TCP 也发送一个 FIN。</li><li>接收这个最终FIN的原发送端 TCP（即执行主动关闭的那一端）确认这个 FIN。<br>既然每个方向都需要一个 FIN 和一个 ACK，因此通常需要4个分节。</li></ol><p>无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。</p><h2 id="什么是-UDP-？"><a href="#什么是-UDP-？" class="headerlink" title="什么是 UDP ？"></a>什么是 UDP ？</h2><p>UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是17。</p><p>UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。</p><p>UDP 是不具有可靠性的数据报协议。细微的处理他会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，确不能保证消息一定会到达。因此应用有时会根据自己的需要进行重发处理。</p><h2 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h2><p>TCP 用于在传输层有必要实现可靠传输的情况。由于它是面向有链接并具备顺序控制、重发控制等机制的，所以他可以为应用提供可靠的传输。</p><p>而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。</p><p>我们举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失会被重发，但这样无法流畅的传输通话人的声音，会导致无法进行正常交流。而采用 UDP，他不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也支持会影响某一小部分的通话。此外，在多播与广播通信中也是用 UDP 而不是 TCP。</p><h2 id="什么是-IP-？"><a href="#什么是-IP-？" class="headerlink" title="什么是 IP ？"></a>什么是 IP ？</h2><p>网络之间互连的协议（IP）是 Internet Protocol 的外语缩写，IP 是在 TCP/IP 协议中网络层的主要协议，任务是仅仅根据源主机和目的主机的地址传送数据。为此目的，IP 定义了寻址方法和数据报的封装结构。第一个架构的主要版本，现在称为 IPv4，仍然是最主要的互联网协议，尽管世界各地正在积极部署 IPv6。</p><p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。</p><p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。</p><h2 id="什么是-Socket-？"><a href="#什么是-Socket-？" class="headerlink" title="什么是 Socket ？"></a>什么是 Socket ？</h2><p>应用在使用 TCP 或 UDP 时，会用到操作系统提供的类库。这种类库一般被称为 API（Application Programming Interface，应用编程接口）。</p><p>使用 TCP 或 UDP 通讯时，优惠广泛使用到套接字（Socket）的 API。套接字原本是由 BSD UNIX 开发的，但是后被移植到了 Windows 的 Winsock 以及嵌入式操作系统中。</p><p>应用程序利用套接字，可以设置对端的 IP 地址，端口号，并实现数据的发送与接收。</p><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 Socket。</p><p>建立网络通信连接至少要一对端口号(Socket)。Socket 本质是编程接口(API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口；HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。</p><h2 id="TCP-IP-通讯示例"><a href="#TCP-IP-通讯示例" class="headerlink" title="TCP/IP 通讯示例"></a>TCP/IP 通讯示例</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/tcp_transaction.jpg?raw=true" alt="TCP/IP 通讯示例"></p><p>在 TCP/IP 通讯过程中，每个分层，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送端的目标地址一节协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层角度看，从上一层收到的包全部被认为是本层的数据。</p><p>假设甲给乙发送邮件，内容为：“早上好”。而从 TCP/IP 通信上看，是从一台计算机 A 向另一台计算机 B 发送邮件。我们通过这个例子来讲解一下 TCP/IP 通信的过程。</p><ul><li>数据包的发送处理</li></ul><ol><li>应用程序处理</li></ol><p>启动应用程序新建邮件，将收件人邮箱填好，再由键盘输入“早上好”，鼠标点击“发送”按钮就可以开始 TCP/IP 的通信了。</p><p>首先，应用程序会对邮件内容进行编码处理，例如：UTF-8，GB2312 等。这些编码相当于 OSI 的表示层功能。应用在发送邮件的那一刻建立 TCP 连接，从而利用这个 TCP 连接发送数据。它的过程首先是将应用的数据发送给下一层的 TCP，在做实际的转发处理。</p><ol start="2"><li>TCP 模块处理</li></ol><p>TCP根据应用的提示，负责建立连接，发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。</p><p>为了实现 TCP 的这一功能，需要在应用层数据的前端附加一个 TCP 的首部。TCP 的首部中包括源端口号和目标端口号、序号。随后将附加了 TCP 首部的包再发送给 IP。</p><ol start="3"><li>IP 模块处理</li></ol><p>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 首部中包含接收端 IP 地址，发送端 IP 地址。随后 IP 包将被发送给连接这些路由器或主机网络接口的驱动程序，以实现真正的发送数据。</p><ol start="4"><li>网络接口（以太网驱动）的处理</li></ol><p>从 IP 传过来的 IP 包，对于以太网卡来说就是数据。给这些数据附加上以太网首部并进行发送处理。以太网首部中包含接收端 MAC 地址，发送端 MAC 地址，以太网类型，以太网数据协议。根据上述信息产生的以太网数据将被通过物理层传输给接收端。</p><ul><li>数据包的接收处理</li></ul><ol><li>网络接口（以太网驱动）的处理</li></ol><p>主机收到以太网包以后，首先从以太网的包首部找到 MAC 地址判断是否为发给自己的包。如果不是发给自己的则丢弃数据，如果是发给自己的则将数据传给处理 IP 的子程序。</p><ol start="2"><li>IP 模块处理</li></ol><p>IP 模块收到 IP 包首部以及后面的数据部分以后，也做类似的处理。如果判断得出包首部的 IP 地址与自己的 IP 地址匹配，则可接受数据并从中查找上一层的协议。并将后面的数据传给 TCP 或者 UDP 处理。对于有路由的情况下，接收端的地址往往不是自己的地址，此时需要借助路由控制表，从中找出应该送到的主机或者路由器以后再进行转发数据。</p><ol start="3"><li>TCP 模块处理</li></ol><p>在 TCP 模块中，首先会校验数据是否被破坏，然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据接收完毕后，接收端则发送一个“确认绘制”给发送端。数据被完整地接收以后，会传给由端口号识别的应用程序。</p><ol start="4"><li>应用程序处理</li></ol><p>接收端应用程序会直接接收发送端发送的数据。通过解析数据可以获知邮件的内容信息。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/http/tcp_data.jpg?raw=true" alt="TCP/IP 数据包"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《图解HTTP》、《图解TCP/IP》、百度百科</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> 网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
            <tag> IP </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章看明白 Android Service 启动过程</title>
      <link href="/2018/04/21/android-service-start/"/>
      <url>/2018/04/21/android-service-start/</url>
      <content type="html"><![CDATA[<h1 id="Android-Service-启动过程"><a href="#Android-Service-启动过程" class="headerlink" title="Android - Service 启动过程"></a>Android - Service 启动过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Service 启动过程与 Activity 启动过程比较相似，不了解 Activity 启动过程的可以先看一下：<a href="">Activity 启动过程</a>。</p><p>Service 的启动分两种情况：startService，bindService。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_service/service_start.png?raw=true" alt=""></p><h2 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h2><p>通常情况我们在调用 startService 启动 Service 是运行在 App 进程中的。下面主要讨论下运行在单独进程中的情况。</p><p>在 AndroidManifest 文件中把 Service 配置 android:process 上属性，Service 就可以启动在单独进程中了。</p><p>首先要明白一个问题，在 Activity 中使用的 startService 方法是定义在 Context 的抽象类中，它的真正实现者是 ContextImpl，所以我们首先进入 ContextImpl 类。</p><ul><li>ContextImpl.startService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line">        ComponentName cn = ActivityManagerNative.getDefault().</span><br><span class="line">startService(mMainThread.getApplicationThread(),</span><br><span class="line">service,service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 ContextImpl 类的 startService 开始，然后进入本类的 startServiceCommon 方法，并最终调用 ActivityManagerNative.getDefault() 对象的 startService 方法。其实这里的 ActivityManagerNative.getDefault() 就是 ActivityManagerProxy 对象。这里涉及到 Binder 相关知识，不了解的请看：<a href="">Binder 机制</a>。</p><ul><li>ActivityManagerProxy.startService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">            String resolvedType, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    service.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    ComponentName res = ComponentName.readFromParcel(reply);</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Binder 调用 ActivityManagerNative 类中 onTransact 方法，其识别码为 START_SERVICE_TRANSACTION，并最终调用 ActivityManagerNative 的实现类 ActivityManagerService 的 startService 方法。</p><ul><li>ActivityManagerService.startService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">            String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startService"</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里调用 mServices 对象的 startServiceLocked 方法，这里的 mServices 对象是 ActiveServices 类。</p><ul><li>ActiveServices.startServiceLocked()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, </span></span></span><br><span class="line"><span class="function"><span class="params">String resolvedType, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, </span><br><span class="line">callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">    ServiceRecord r = res.record;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//这里紧接着会调用 startServiceInnerLocked 方法</span></span><br><span class="line">    <span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">            ServiceRecord r, <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startRunningLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里紧接着会调用 bringUpServiceLocked 方法</span></span><br><span class="line">        String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 retrieveServiceLocked 方法来解析 service 这个 Intent，就是解析前面我们在 AndroidManifest.xml 定义的 Service 标签的 intent-filter 相关内容，然后将解析结果放在 res.record 中，再调用 startServiceInnerLocked 方法。startServiceInnerLocked 方法中会调用 bringUpServiceLocked 方法。</p><ul><li>ActiveServices.bringUpServiceLocked()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（1）这里如果当前的 ProcessRecord 不为 null，那就不需要重新创建进程，</span></span><br><span class="line"><span class="comment">//而是调用 realStartServiceLocked 方法来启动 Service</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                    realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">                <span class="comment">// restart the application.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）如果是需要创建新进程，那么将调用 ActivityManagerService.startProcessLocked 方法来启动新进程</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                    <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                bringDownServiceLocked(r);</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">                r.isolatedProc = app;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后将 ServiceRecord 保存到成员变量 mPendingServices 中</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">            mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较重要，这里有两种选择，当 Service 所在的进程存在时，将调用realStartServiceLocked 方法来启动 Service，否则的话调用 startProcessLocked 方法来启动新进程。</p><ul><li>ActivityManagerService.startProcessLocked()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType, </span></span></span><br><span class="line"><span class="function"><span class="params">String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isActivityProcess = (entryPoint == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) </span><br><span class="line">        entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line">    checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">    <span class="comment">//通过 processName，uid 等启动新进程</span></span><br><span class="line">    Process.ProcessStartResult startResult = Process.start(entryPoint, </span><br><span class="line">app.processName, uid, uid, gids, debugFlags, mountExternal, </span><br><span class="line">app.info.targetSdkVersion, app.info.seinfo, requiredAbi, </span><br><span class="line">instructionSet, app.info.dataDir, entryPointArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 Process 的 start 方法启动 ActivityThread 的新进程，我们进入该类的 main 方法。</p><ul><li>ActivityThread.main()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">//创建 ActivityThread 对象，并调用其 attach 方法</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里调用了 ActivityManagerProxy.attachApplication 方法。</span></span><br><span class="line">        mgr.attachApplication(mAppThread);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 应用程序中，每一个进程对应一个 ActivityThread 实例，然后这里创建了 ActivityThread 对象并调用了其 attach 方法，在 attach 方法中又调用了 ActivityManagerProxy.attachApplication 方法。</p><ul><li>ActivityManagerProxy.attachApplication()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(app.asBinder());</span><br><span class="line">    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Binder 机制会调用 ActivityManagerNative 中的 onTransact 方法，其识别码为 ATTACH_APPLICATION_TRANSACTION，并最终调用 ActivityManagerService 中的 attachApplication 方法。</p><ul><li>ActivityManagerService.attachApplication()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//调用 attachApplicationLocked</span></span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown launching activities in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find any services that should be running in this process...</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里会调用 ActiveServices 对象的 attachApplicationLocked 方法</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown starting services in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果是启动 Service 将调用 ActiveServices 对象的 attachApplicationLocked 方法，而如果是启动 Activity 将调用 ActivityStackSupervisor 对象的 attachApplicationLocked 方法。</p><ul><li>ActiveServices.attachApplicationLocked() -&gt; realStartServiceLocked()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                    app.repProcState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 app.thread 是一个 IApplicationThread 对象，而 IApplicationThread 的代理类是 ApplicationThreadProxy，我们进入 app.thread 对象的 scheduleCreateService 方法。</p><ul><li>ApplicationThreadProxy.scheduleCreateService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token, ServiceInfo info, </span></span></span><br><span class="line"><span class="function"><span class="params">CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    info.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    compatInfo.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeInt(processState);</span><br><span class="line">    mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Binder 对象调用 ApplicationThreadNative 的 onTransact 方法，在其方法中调用子类的 scheduleCreateService 方法，即最终调用 ApplicationThreadNative 的子类 ApplicationThread 的 scheduleCreateService 方法。</p><ul><li>ApplicationThread.scheduleCreateService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,  ServiceInfo info, </span></span></span><br><span class="line"><span class="function"><span class="params">CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Handler 发送 Message 来处理该操作，并进入到 H 的 handleMessage 方法中，其识别码为 CREATE_SERVICE。</p><ul><li>H.handleMessage()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"serviceCreate"</span>);</span><br><span class="line">        <span class="comment">//这里调用 handleCreateService 方法</span></span><br><span class="line">        handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ApplicationThread.handleCreateService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//（1）通过类加载器来加载 Service 对象</span></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）这里创建 ContextImpl 对象</span></span><br><span class="line">    ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">    context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">    Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                    ActivityManagerNative.getDefault());</span><br><span class="line">    <span class="comment">//（3）这里调用 Service 的 onCreate 方法</span></span><br><span class="line">    service.onCreate();</span><br><span class="line">    mServices.put(data.token, service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>处通过类加载器 ClassLoader 来加载 Service 对象，此处的 data.info.name 就是我们要启动的 Service，加载完成后需要将其强转换为 Service 对象，也就是说我们的 Service 必须要继承于 Service 基类。 </li><li>处这里先创建一个 ContextImpl 对象，每个 Activity 和 Service 都有一个 Context 对象。 </li><li>处这里调用 Service 的 onCreate 方法。</li></ol><h2 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h2><ul><li>如何 bind 一个 Service？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, XXXService.class);</span><br><span class="line">    <span class="comment">// bindService 的具体实现在 ContextImpl</span></span><br><span class="line">    <span class="comment">// BIND_AUTO_CREATE 参数具体使用的代码 ActivityServices</span></span><br><span class="line">    bindService(intent, conn, BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// 绑定成功</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123; </span><br><span class="line">      <span class="comment">// 绑定结束 </span></span><br><span class="line">       ...  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ContextImpl.bindServce()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mMainThread.getHandler()，传入的 handle 是主线程的 Handle</span></span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(),</span><br><span class="line">            Process.myUserHandle());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> flags, Handler handler, UserHandle user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1，将传入的 ServiceConnection 转化为 IServiceConnection 返回</span></span><br><span class="line">        <span class="comment">// mPackgeInfo 是 LoadedApk</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2，Binder 调用 AMS 的 bindService 方法，下面具体分析</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LoadedApk</li></ul><p>LoadedApk 对象是 Apk 文件在内存中的表示。 Apk 文件的相关信息，诸如 Apk 文件的代码和资源，甚至代码里面的 Activity，Service 等组件的信息我们都可以通过此对象获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">getServiceDispatcher</span><span class="params">(ServiceConnection c, </span></span></span><br><span class="line"><span class="function"><span class="params">Context context, Handler handler, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// private final ArrayMap&lt;Context,</span></span><br><span class="line">        <span class="comment">// ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices</span></span><br><span class="line">        <span class="comment">// 根据当前的 Context 获取 ArrayMap&lt;ServiceConnection,  LoadedApk.ServiceDispatcher&gt;</span></span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在，尝试根据当前的 ServiceConnection 获取 ServiceDispatcher</span></span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果与 ServiceConnection 对应的 ServiceDispatcher 不存在，创建一个保存了当前 </span></span><br><span class="line"><span class="comment">// ServiceConnection 的 ServiceDispatcher 对象，</span></span><br><span class="line">            <span class="comment">// 并将之前传入的主线的 Handle 保存，同时创建一个 InnerConnection 对象保存</span></span><br><span class="line">            sd = <span class="keyword">new</span> ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将该 ServiceConnection 与 ServiceDispatcher 关系保存</span></span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果最开始就获取到 ServiceDispatcher，比如多次 bindService，</span></span><br><span class="line">            <span class="comment">// 就会调用 ServiceDispatcher 的 validate 判断此次 bindService 是否合法</span></span><br><span class="line">            <span class="comment">// validate 的判断逻辑比较简单：</span></span><br><span class="line"><span class="comment">// 1.判断当前的 context 是否和之前 bindService 的一样 </span></span><br><span class="line"><span class="comment">// 2.判断当前 handler 是否是主线程的 handle</span></span><br><span class="line">            <span class="comment">// 以上两个条件都满足的情况下正常执行，反之抛出相应的异常</span></span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ActivityManagerService.bindService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service, </span></span></span><br><span class="line"><span class="function"><span class="params">String resolvedType, IServiceConnection connection, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> flags, String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 ActiveServices 的 bindServiceLocked 方法</span></span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ActiveServices.bindServiceLocked() -&gt; bringUpServiceLocked() -&gt; realStartServiceLocked()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r, ProcessRecord app, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 第一步，调用 ApplicationThread 的 scheduleCreateService 方法，</span></span><br><span class="line"><span class="comment">// 之后会实例化 Service 并调用 Service 的 onCreate 方法，这里的过程跟上面 startService 中一样。</span></span><br><span class="line">        <span class="comment">// 不会调用 onStartCommand</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo, </span><br><span class="line">mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 第二步，调用 requestServiceBindingLocked</span></span><br><span class="line">    requestServiceBindingLocked(r, execInFg);</span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    <span class="comment">// If the service is in the started state, and there are no</span></span><br><span class="line">    <span class="comment">// pending arguments, then fake up one so its onStartCommand() will</span></span><br><span class="line">    <span class="comment">// be called.</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, </span><br><span class="line">r.makeNextStartId(), <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// StartItem 的 taskRemoved 如果是 false 的话，</span></span><br><span class="line"><span class="comment">// 调用下面方法会调用 Service 的 onStartCommand</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, </span></span></span><br><span class="line"><span class="function"><span class="params">IntentBindRecord i, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// 调用 ApplicationThread 的 scheduleBindService 方法</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ApplicationThread.scheduleBindService()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 根据 token 获取 Service token 具体分析</span></span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// rebind 具体分析</span></span><br><span class="line">            <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                <span class="comment">// 调用 Service 的 onBind，返回给客户端调用的 Binder</span></span><br><span class="line">                IBinder binder = s.onBind(data.intent);</span><br><span class="line">                <span class="comment">// 调用 AMS 的 publishService，进而通知客户端连接成功</span></span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .publishService(data.token, data.intent, binder);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.onRebind(data.intent);</span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .serviceDoneExecuting(data.token, SERVICE_DONE_EXECUTING_ANON,</span><br><span class="line">                     <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 ApplicationThread 的 scheduleBindService，scheduleBindService 通过 mH 发送一个 H.BIND_SERVICE 消息，mH 收到该消息调用 handleBindService(BindServiceData data)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>startService</li></ul><p>使用这种 start 方式启动的 Service 的生命周期如下：<br>onCreate() -&gt; onStartCommand()（onStart()方法已过时） -&gt; onDestory()</p><p>说明：如果服务已经开启，不会重复的执行 onCreate()， 而是会调用 onStart() 和onStartCommand()。<br>服务停止的时候调用 onDestory()。服务只会被停止一次。</p><p>特点：一旦服务开启跟调用者(开启者)就没有任何关系了。<br>开启者退出了，开启者挂了，服务还在后台长期的运行。<br>开启者不能调用服务里面的方法。</p><ul><li>bindService</li></ul><p>使用这种 start 方式启动的 Service 的生命周期如下：<br>onCreate() -&gt; onBind() -&gt; onUnbind() -&gt; onDestory()</p><p>注意：绑定服务不会调用 onStart() 或者 onStartCommand() 方法</p><p>特点：bind 的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。<br>绑定者可以调用服务里面的方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2016/03/06/start-service/" target="_blank" rel="noopener">startService 启动过程分析</a></li><li>《深入理解 Android 内核设计思想》</li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> 启动过程 </tag>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系</title>
      <link href="/2018/03/08/android-surface-surfaceflinger/"/>
      <url>/2018/03/08/android-surface-surfaceflinger/</url>
      <content type="html"><![CDATA[<h1 id="Android-SurfaceFlinger-图形系统"><a href="#Android-SurfaceFlinger-图形系统" class="headerlink" title="Android - SurfaceFlinger 图形系统"></a>Android - SurfaceFlinger 图形系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-系统启动过程.md" target="_blank" rel="noopener">Android 系统启动过程</a></li><li><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Activity启动过程.md" target="_blank" rel="noopener">Activity 创建过程</a></li><li><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Activity与Window与View之间的关系.md" target="_blank" rel="noopener">Activity 与 Window 与 View 之间的关系</a></li></ul><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/android-bootloader.png?raw=true" alt=""></p><p>通过前面的知识我们知道了，Android 系统从按下开机键到桌面，从桌面点击 App 图标到 Activity 显示的过程。但是 Activity 是怎么显示在屏幕上的呢？下面我们就来讨论下这一过程。</p><h2 id="SurfaceFlinger-启动过程"><a href="#SurfaceFlinger-启动过程" class="headerlink" title="SurfaceFlinger 启动过程"></a>SurfaceFlinger 启动过程</h2><p>SurfaceFlinger 启动过程：<br><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_surfaceflinger/surfaceflinger_start.png?raw=true" alt=""></p><p>SurfaceFlinger 进程是由 init 进程创建的，运行在独立的 SurfaceFlinger 进程中。init 进程读取 init.rc 文件启动 SurfaceFlinger。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">graphics</span> <span class="title">drmrpc</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure><p>SurfaceFlinger 的创建会执行 main() 方法：<br>main_surfaceflinger.cpp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化 surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger =  <span class="keyword">new</span> SurfaceFlinger();</span><br><span class="line"></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发布 surface flinger，注册到 ServiceManager</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行在当前线程</span></span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SurfaceFlinger 的实例化会执行到：onFirstRef()<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onFirstRef() &#123;</span><br><span class="line">    mEventQueue.init(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>onFirstRef() 中会创建 Handler 并初始化。<br>MessageQueue.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::init(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">true</span>);</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后会执行到 SurfaceFlinger::init()：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 EGL，作为默认的显示</span></span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化硬件 composer 对象</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>, *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 RenderEngine 引擎</span></span><br><span class="line">    mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检索创建的 EGL 上下文</span></span><br><span class="line">    mEGLContext = mRenderEngine-&gt;getEGLContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化非虚拟显示屏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        <span class="comment">//建立已连接的显示设备</span></span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            <span class="keyword">bool</span> isSecure = <span class="literal">true</span>;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token = mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            <span class="comment">//创建 BufferQueue 的生产者和消费者</span></span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    <span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs = <span class="keyword">new</span> FramebufferSurface(*mHwc, i, consumer);</span><br><span class="line">            <span class="keyword">int32_t</span> hwcId = allocateHwcDisplayId(type);</span><br><span class="line">            <span class="comment">//创建显示设备</span></span><br><span class="line">            sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            <span class="keyword">if</span> (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当应用和 sf 的 vsync 偏移量一致时，则只创建一个 EventThread 线程</span></span><br><span class="line">    <span class="keyword">if</span> (vsyncPhaseOffsetNs != sfVsyncPhaseOffsetNs) &#123;</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">        mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">        mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建 DispSyncSource 对象</span></span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf-app"</span>);</span><br><span class="line">        <span class="comment">//创建线程 EventThread</span></span><br><span class="line">        mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);</span><br><span class="line">        <span class="comment">//设置 EventThread</span></span><br><span class="line">        mEventQueue.setEventThread(mEventThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 EventControl</span></span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">"EventControl"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当不存在 HWComposer 时，则设置软件 vsync</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc-&gt;initCheck() != NO_ERROR) &#123;</span><br><span class="line">        mPrimaryDispSync.setPeriod(<span class="number">16666667</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化绘图状态</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化显示设备</span></span><br><span class="line">    initializeDisplays();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动开机动画</span></span><br><span class="line">    startBootAnim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法主要功能是：</p><ol><li>初始化 EGL</li><li>创建 HWComposer</li><li>初始化非虚拟显示屏</li><li>启动 EventThread 线程</li><li>启动开机动画</li></ol><p>创建 HWComposer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler):mFlinger(flinger), mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>), mCBContext(<span class="keyword">new</span> cb_context), mEventHandler(handler), mDebugForceFakeVSync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> needVSyncThread = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> fberr = loadFbHalModule(); <span class="comment">//加载 framebuffer 的 HAL 层模块</span></span><br><span class="line">    loadHwcModule(); <span class="comment">//加载 HWComposer 模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记已分配的 display ID</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;</span><br><span class="line">        mAllocatedDisplayIDs.markBit(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            mCBContext-&gt;hwc = <span class="keyword">this</span>;</span><br><span class="line">            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;</span><br><span class="line">            <span class="comment">//VSYNC 信号的回调方法</span></span><br><span class="line">            mCBContext-&gt;procs.vsync = &amp;hook_vsync;</span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));</span><br><span class="line">            <span class="comment">//注册回调函数</span></span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入此处，说明已成功打开硬件 composer 设备，则不再需要 vsync 线程</span></span><br><span class="line">        needVSyncThread = <span class="literal">false</span>;</span><br><span class="line">        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;</span><br><span class="line">        <span class="comment">//不支持硬件的 VSYNC，则会创建线程来模拟定时 VSYNC 信号</span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWComposer 代表着硬件显示设备，注册了 VSYNC 信号的回调。VSYNC 信号本身是由显示驱动产生的，在不支持硬件的 VSYNC，则会创建“VSyncThread”线程来模拟定时 VSYNC 信号。</p><p>当硬件产生VSYNC信号时，则会发送消息，handler 收到消息进行处理。当 SurfaceFlinger 进程收到 VSync 信号后经层层调用，最终调用到该对象的 handleMessageRefresh() 方法。</p><p>SurfaceFlinger.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    preComposition();<span class="comment">//处理显示设备与 layers 的改变，更新光标</span></span><br><span class="line">    rebuildLayerStacks();<span class="comment">//重建所有可见 Layer 列表，根据Z轴排序</span></span><br><span class="line">    setUpHWComposer();<span class="comment">//更新 HWComposer 图层</span></span><br><span class="line">    doDebugFlashRegions(); </span><br><span class="line">    doComposition();<span class="comment">//生成 OpenGL 纹理图像</span></span><br><span class="line">    postComposition();<span class="comment">//将图像传递到物理屏幕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Surface-创建过程"><a href="#Surface-创建过程" class="headerlink" title="Surface 创建过程"></a>Surface 创建过程</h2><p>Surface 创建过程：<br><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_surfaceflinger/surface_creat.png?raw=true" alt=""></p><p>Surface 创建的过程就是 Activity 显示的过程，在 ActivityThread.handleResumeActivity() 中调用了 Activity.makeVisible()，我们接着看下 Activity 是怎么显示出来的。</p><p>Activity.makeVisible：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();<span class="comment">//此处 getWindowManager 获取的是 WindowManagerImpl 对象</span></span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManagerImpl.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManagerGlobal.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">//创建 ViewRootImpl</span></span><br><span class="line">    ViewRootImpl root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    <span class="comment">//设置 View</span></span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建 ViewRootImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">ThreadedRenderer</span>.<span class="title">DrawCallbacks</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface(); <span class="comment">//创建 Surface，此时 Surface 创建完什么都没有，详见下面分析</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="comment">//获取 IWindowSession 的代理类</span></span><br><span class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">        mDisplay = display;</span><br><span class="line">        mThread = Thread.currentThread(); <span class="comment">//主线程</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManagerGlobal.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取 IMS 的代理类</span></span><br><span class="line">                InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取 WMS 的代理类</span></span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                <span class="comment">//经过 Binder 调用，最终调用 WMS</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;...&#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManagerService.openSession：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建 Session 对象</span></span><br><span class="line">    Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback, client, inputContext);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次经过 Binder 将数据写回 app 进程，则获取的便是 Session 的代理对象 IWindowSession。</p><p>创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。<br>ViewRootImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    requestLayout(); <span class="comment">//详见下面分析</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过 Binder调用，进入 system 进程的 Session</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">          getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">          mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">          mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> <span class="keyword">extends</span> <span class="title">IWindowSession</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用 WMS.addWindow</span></span><br><span class="line">        <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">                outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowManagerService.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">    <span class="comment">//创建 WindowState</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调整 WindowManager 的 LayoutParams 参数</span></span><br><span class="line">    mPolicy.adjustWindowParamsLw(win.mAttrs);</span><br><span class="line">    res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">    addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 设置 input</span></span><br><span class="line">    mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    <span class="comment">//详见下面分析</span></span><br><span class="line">    win.attach();</span><br><span class="line">    mWindowMap.put(client.asBinder(), win);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">//当该窗口能接收按键事件，则更新聚焦窗口</span></span><br><span class="line">        focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WindowState.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建 SurfaceSession 对象，并将当前 Session 添加到 WMS.mSessions 成员变量。<br>Session.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SurfaceSession 的创建会调用 JNI，在 JNI 调用 nativeCreate()。<br>android_view_SurfaceSession.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">    client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建 SurfaceComposerClient 对象， 作为跟 SurfaceFlinger 通信的代理对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient() &#123;</span><br><span class="line">    <span class="comment">//getComposerService() 将返回 SF 的 Binder 代理端的 BpSurfaceFlinger 对象</span></span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sm(getComposerService());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先调用 SF 的 createConnection()，再调用_init</span></span><br><span class="line">    _init(sm, sm-&gt;createConnection());</span><br><span class="line">    <span class="keyword">if</span>(mClient != <span class="number">0</span>) &#123;</span><br><span class="line">       Mutex::Autolock _l(gLock);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//gActiveConnections 是全局变量，把刚才创建的 client 保存到这个 map 中去</span></span><br><span class="line">       gActiveConnections.add(mClient-&gt;asBinder(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SurfaceFlinger.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceFlingerClient&gt;SurfaceFlinger::createConnection() &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="keyword">uint32_t</span> token = mTokens.acquire();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先创建一个Client</span></span><br><span class="line">    sp&lt;Client&gt; client = <span class="keyword">new</span> Client(token, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把这个Client对象保存到mClientsMap中，token是它的标识。</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mClientsMap.add(token, client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个用于 Binder 通信的 BClient，BClient 派生于 ISurfaceFlingerClient，</span></span><br><span class="line"><span class="comment">    它的作用是接受客户端的请求，然后把处理提交给 SF，注意，并不是提交给 Client。</span></span><br><span class="line"><span class="comment">    Client 会创建一块共享内存，该内存由 getControlBlockMemory 函数返回。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sp&lt;BClient&gt; bclient = <span class="keyword">new</span> BClient(<span class="keyword">this</span>, token,client-&gt;getControlBlockMemory());</span><br><span class="line">    <span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Client::Client(ClientID clientID, constsp&lt;SurfaceFlinger&gt;&amp; flinger):ctrlblk(<span class="number">0</span>), cid(clientID), mPid(<span class="number">0</span>), mBitmap(<span class="number">0</span>), mFlinger(flinger) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pgsize = getpagesize();</span><br><span class="line">    <span class="comment">//下面这个操作会使 cblksize 为页的大小，目前是4096字节</span></span><br><span class="line">    constint cblksize = ((<span class="keyword">sizeof</span>(SharedClient)+(pgsize<span class="number">-1</span>))&amp;~(pgsize<span class="number">-1</span>));</span><br><span class="line">    mCblkHeap = <span class="keyword">new</span> MemoryHeapBase(cblksize, <span class="number">0</span>, <span class="string">"SurfaceFlinger Clientcontrol-block"</span>);</span><br><span class="line"></span><br><span class="line">    ctrlblk = <span class="keyword">static_cast</span>&lt;SharedClient *&gt;(mCblkHeap-&gt;getBase());</span><br><span class="line">    <span class="keyword">if</span>(ctrlblk) &#123;</span><br><span class="line">       <span class="keyword">new</span>(ctrlblk) SharedClient;<span class="comment">//原来 Surface 的 CB 对象就是在共享内存中创建的这个 SharedClient 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SharedClient：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedClient</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   SharedClient();</span><br><span class="line">   ~SharedClient();</span><br><span class="line">   <span class="keyword">status_t</span> validate(<span class="keyword">size_t</span> token) <span class="keyword">const</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> getIdentity(<span class="keyword">size_t</span> token) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutexlock;</span><br><span class="line">    Condition cv; <span class="comment">//支持跨进程的同步对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//NUM_LAYERS_MAX 为 31，SharedBufferStack 是什么？</span></span><br><span class="line">    SharedBufferStack surfaces[ NUM_LAYERS_MAX ];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SharedClient的构造函数，没什么新意，不如Audio的CB对象复杂</span></span><br><span class="line">SharedClient::SharedClient():lock(Mutex::SHARED), cv(Condition::SHARED) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个 Client 最多支持 31 个显示层。每一个显示层的生产/消费步调都由会对应的 SharedBufferStack 来控制。而它内部就用了几个成员变量来控制读写位置。</p><p>SharedBufferStack.h：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SharedBufferStack</span>&#123;</span></span><br><span class="line">     ......</span><br><span class="line">    <span class="comment">//Buffer 是按块使用的，每个 Buffer 都有自己的编号，其实就是数组中的索引号。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> head;     <span class="comment">//FrontBuffer 的编号</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> available; <span class="comment">//空闲 Buffer 的个数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> queued;  <span class="comment">//脏 Buffer 的个数，脏 Buffer 表示有新数据的 Buffer</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> inUse; <span class="comment">//SF 当前正在使用的 Buffer 的编号   </span></span><br><span class="line">    <span class="keyword">volatilestatus_t</span> status; <span class="comment">//状态码</span></span><br><span class="line">     ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>SF 的一个 Client 分配一个跨进程共享的 SharedClient 对象。这个对象有31个 SharedBufferStack 元素，每一个 SharedBufferStack 对应于一个显示层。</p><p>一个显示层将创建两个 Buffer，后续的 PageFlipping 就是基于这两个 Buffer 展开的。</p><p>接着看 SurfaceComposerClient 中这个_init函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceComposerClient::_init(</span><br><span class="line">       <span class="keyword">const</span> sp&lt;ISurfaceComposer&gt;&amp; sm, constsp&lt;ISurfaceFlingerClient&gt;&amp; conn) &#123;</span><br><span class="line">    mPrebuiltLayerState = <span class="number">0</span>;</span><br><span class="line">    mTransactionOpen = <span class="number">0</span>;</span><br><span class="line">    mStatus = NO_ERROR;</span><br><span class="line">    mControl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mClient = conn;<span class="comment">// mClient 就是 BClient 的客户端</span></span><br><span class="line">    mControlMemory =mClient-&gt;getControlBlock();</span><br><span class="line">    mSignalServer = sm;<span class="comment">// mSignalServer 就是 BpSurfaceFlinger</span></span><br><span class="line">    <span class="comment">//mControl 就是那个创建于共享内存之中的 SharedClient</span></span><br><span class="line">    mControl = <span class="keyword">static_cast</span>&lt;SharedClient*&gt;(mControlMemory-&gt;getBase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。在 setView() 中调用了 requestLayout() 方法我们来看下这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   checkThread();</span><br><span class="line">   mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">   scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mTraversalScheduled) &#123;</span><br><span class="line">       mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">       sendEmptyMessage(DO_TRAVERSAL); <span class="comment">//发送 DO_TRAVERSAL 消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> DO_TRAVERSAL:</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();<span class="comment">//调用 performTraversals()</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalView host = mView;<span class="comment">//还记得这mView吗？它就是 DecorView</span></span><br><span class="line">    booleaninitialized = <span class="keyword">false</span>;</span><br><span class="line">    booleancontentInsetsChanged = <span class="keyword">false</span>;</span><br><span class="line">    booleanvisibleInsetsChanged;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        relayoutResult= <span class="comment">// 1. 关键函数relayoutWindow</span></span><br><span class="line">        relayoutWindow(params, viewVisibility,insetsPending);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    draw(fullRedrawNeeded);<span class="comment">// 2. 开始绘制</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility, <span class="keyword">boolean</span> insetsPending)</span><span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">       <span class="comment">//原来是调用 IWindowSession 的 relayout()，暂且记住这个调用</span></span><br><span class="line">       <span class="keyword">int</span> relayoutResult = sWindowSession.relayout(mWindow, params, (<span class="keyword">int</span>) (mView.mMeasuredWidth * appScale + <span class="number">0.5f</span>),  (<span class="keyword">int</span>) (mView.mMeasuredHeight * appScale + <span class="number">0.5f</span>), viewVisibility, insetsPending, mWinFrame, mPendingContentInsets, mPendingVisibleInsets, mPendingConfiguration, mSurface); <span class="comment">//mSurface 做为参数传进去了。</span></span><br><span class="line">       &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;<span class="comment">//mSurface 是 ViewRoot 的成员变量</span></span><br><span class="line">    ......</span><br><span class="line">    Canvascanvas;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">       <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">       <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">       <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//从 mSurface 中 lock 一块 Canvas</span></span><br><span class="line">       canvas = surface.lockCanvas(dirty);</span><br><span class="line">       ......</span><br><span class="line">       mView.draw(canvas);<span class="comment">//调用 DecorView 的 draw 函数，canvas 就是画布</span></span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">//unlock 画布，屏幕上马上就能看到 View 的样子了</span></span><br><span class="line">       surface.unlockCanvasAndPost(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 ViewRoot 构造时，会创建一个 Surface，它使用无参构造函数，代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure></p><p>此时创建完的 Surface 是空的，什么都没有。接着继续分析 relayoutWindow()，在 relayoutWindow() 中会调用 IWindowSession 的 relayout()，这是一个跨进程方法会调用到 WMS 中的 Session.relayout()，最后调用到 WindowManagerService.relayoutWindow()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session,IWindow client,</span></span></span><br><span class="line"><span class="function"><span class="params">           WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">boolean</span> insetsPending,</span></span></span><br><span class="line"><span class="function"><span class="params">           Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration outConfig, SurfaceoutSurface)</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//win 就是 WinState，这里将创建一个本地的 Surface 对象</span></span><br><span class="line">        Surfacesurface = win.createSurfaceLocked();</span><br><span class="line">        <span class="keyword">if</span>(surface != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先创建一个本地 surface，然后在 outSurface 的对象上调用 copyFrom</span></span><br><span class="line">            <span class="comment">//将本地 Surface 的信息拷贝到 outSurface 中，为什么要这么麻烦呢？</span></span><br><span class="line">            outSurface.copyFrom(surface);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManagerService.java::WindowState：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Surface <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//mSurfaceSession 就是在 Session 上创建的 SurfaceSession 对象</span></span><br><span class="line">        <span class="comment">//这里，以它为参数，构造一个新的 Surface 对象</span></span><br><span class="line">        mSurface = <span class="keyword">new</span> Surface(mSession.mSurfaceSession, mSession.mPid, mAttrs.getTitle().toString(), <span class="number">0</span>, w, h, mAttrs.format, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    Surface.openTransaction();<span class="comment">//打开一个事务处理</span></span><br><span class="line">    ......</span><br><span class="line">    Surface.closeTransaction();<span class="comment">//关闭一个事务处理</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造 Surface 对象：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">(SurfaceSession s,<span class="comment">//传入一个SurfaceSession对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> pid, String name, <span class="keyword">int</span> display, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span> throws OutOfResourcesException </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">       mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line">       <span class="comment">//又一个 native 函数</span></span><br><span class="line">       init(s,pid,name,display,w,h,format,flags);</span><br><span class="line">       mName = name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Surface_init</span><span class="params">(JNIEnv*env, jobject clazz, jobject session, jint pid, jstring jname, jint dpy, jint w, jint h, jint format, jintflags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 SurfaceSession 对象中取出之前创建的那个 SurfaceComposerClient 对象</span></span><br><span class="line">    SurfaceComposerClient* client = (SurfaceComposerClient*)env-&gt;GetIntField(session, sso.client);</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;<span class="comment">//注意它的类型是 SurfaceControl</span></span><br><span class="line">    <span class="keyword">if</span> (jname == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用 SurfaceComposerClient 的 createSurface 函数，返回的 surface 是一个 SurfaceControl 类型</span></span><br><span class="line">        surface = client-&gt;createSurface(pid, dpy, w, h, format, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//把这个 surfaceControl 对象设置到 Java 层的 Surface 对象中</span></span><br><span class="line">   setSurfaceControl(env, clazz, surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 createSurface 内部会使用 Binder 通信将请求发给 SurfaceFlinger：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurface&gt;SurfaceFlinger::createSurface(ClientID clientId, <span class="keyword">int</span> pid, <span class="keyword">const</span> String8&amp; name, ISurfaceFlingerClient::<span class="keyword">surface_data_t</span>* params, DisplayID d, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;LayerBaseClient&gt; layer;<span class="comment">//LayerBaseClient 是 Layer 家族的基类</span></span><br><span class="line">    <span class="comment">//这里又冒出一个 LayerBaseClient 的内部类，它也叫Surface</span></span><br><span class="line">    sp&lt;LayerBaseClient::Surface&gt; surfaceHandle;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 clientId 找到 createConnection 时加入的那个 Client 对象</span></span><br><span class="line">    sp&lt;Client&gt; client = mClientsMap.valueFor(clientId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//注意这个 id，它的值表示 Client 创建的是第几个显示层</span></span><br><span class="line">    <span class="comment">//同时也表示将使用 SharedBufferStatck 数组的第 id 个元素</span></span><br><span class="line">    <span class="keyword">int32_t</span> id = client-&gt;generateId(pid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个 Client 不能创建多于 NUM_LAYERS_MAX 个的Layer</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">uint32_t</span>(id) &gt;= NUM_LAYERS_MAX) &#123;</span><br><span class="line">       <span class="keyword">return</span> surfaceHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 flags 参数来创建不同类型的显示层</span></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> eFXSurfaceNormal:</span><br><span class="line">           <span class="keyword">if</span> (UNLIKELY(flags &amp; ePushBuffers)) &#123;</span><br><span class="line">             <span class="comment">//创建 PushBuffer 类型的显示层</span></span><br><span class="line">            layer = createPushBuffersSurfaceLocked(client, d, id, w, h, flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//创建 Normal 类型的显示层</span></span><br><span class="line">               layer = createNormalSurfaceLocked(client, d, id, w, h, flags, format);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> eFXSurfaceBlur:</span><br><span class="line">            <span class="comment">//创建 Blur 类型的显示层</span></span><br><span class="line">           layer = createBlurSurfaceLocked(client, d, id, w, h, flags);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> eFXSurfaceDim:</span><br><span class="line">            <span class="comment">//创建 Dim 类型的显示层</span></span><br><span class="line">           layer = createDimSurfaceLocked(client, d, id, w, h, flags);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(layer != <span class="number">0</span>) &#123;</span><br><span class="line">        layer-&gt;setName(name);</span><br><span class="line">        setTransactionFlags(eTransactionNeeded);</span><br><span class="line">        <span class="comment">//从显示层对象中取出一个 ISurface 对象赋值给 SurfaceHandle</span></span><br><span class="line">        surfaceHandle = layer-&gt;getSurface();</span><br><span class="line">        <span class="keyword">if</span>(surfaceHandle != <span class="number">0</span>) &#123;</span><br><span class="line">           params-&gt;token = surfaceHandle-&gt;getToken();</span><br><span class="line">           params-&gt;identity = surfaceHandle-&gt;getIdentity();</span><br><span class="line">           params-&gt;width = w;</span><br><span class="line">           params-&gt;height = h;</span><br><span class="line">           params-&gt;format = format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> surfaceHandle;<span class="comment">//ISurface 的 Bn 端就是这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;LayerBaseClient&gt;SurfaceFlinger::createNormalSurfaceLocked(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client, DisplayID display, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(format) &#123; <span class="comment">//一些图像方面的参数设置，可以不去管它</span></span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">       format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">       format = PIXEL_FORMAT_RGB_565;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个 Layer 类型的对象</span></span><br><span class="line">    sp&lt;Layer&gt; layer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, display,client, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 Buffer</span></span><br><span class="line">    <span class="keyword">status_t</span> err = layer-&gt;setBuffers(w, h, format, flags);</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(err == NO_ERROR)) &#123;</span><br><span class="line">        <span class="comment">//初始化这个新 layer 的一些状态</span></span><br><span class="line">        layer-&gt;initStates(w, h, flags);</span><br><span class="line">        <span class="comment">//下面这个函数把这个 layer 加入到 Z 轴集合中</span></span><br><span class="line">        addLayer_l(layer);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createNormalSurfaceLocked 函数有三个关键点，它们是：</p><ul><li>构造一个Layer对象。</li><li>调用Layer对象的setBuffers函数。</li><li>调用SF的addLayer_l函数。</li></ul><p>当跨进程的 createSurface() 执行完返回一个 ISurface 对象，接下来会创建 SurfaceControl 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl::SurfaceControl(</span><br><span class="line">       <span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">       <span class="keyword">const</span> sp&lt;ISurface&gt;&amp; surface,</span><br><span class="line">       <span class="keyword">const</span> ISurfaceFlingerClient::surface_data_t&amp; data,</span><br><span class="line">       uint32_t w, uint32_t h, PixelFormat format, uint32_t flags)</span><br><span class="line">    <span class="comment">//mClient 为 SurfaceComposerClient，而 mSurface 指向跨进程 createSurface() 调用返回的 ISurface 对象</span></span><br><span class="line">    :mClient(client), mSurface(surface),</span><br><span class="line">     mToken(data.token), mIdentity(data.identity),</span><br><span class="line">     mWidth(data.width), mHeight(data.height), mFormat(data.format),</span><br><span class="line">     mFlags(flags)&#123;</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SurfaceControl 类可以看作是一个 wrapper 类，它封装了一些函数，通过这些函数可以方便地调用 mClient 或 ISurface 提供的函数。</p><p>最后会执行 copyFrom() 返回给 App 客户端：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Surface_copyFrom</span><span class="params">(JNIEnv* env,jobject clazz, jobject other)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据JNI函数的规则，clazz 是 copyFrom 的调用对象，而 other 是 copyFrom 的参数。</span></span><br><span class="line">    <span class="comment">//目标对象此时还没有设置 SurfaceControl，而源对象在前面已经创建了 SurfaceControl</span></span><br><span class="line">    constsp&lt;SurfaceControl&gt;&amp; surface = getSurfaceControl(env, clazz);</span><br><span class="line">    constsp&lt;SurfaceControl&gt;&amp; rhs = getSurfaceControl(env, other);</span><br><span class="line">    <span class="keyword">if</span> (!SurfaceControl::isSameSurface(surface, rhs)) &#123;</span><br><span class="line">        <span class="comment">//把源 SurfaceControl 对象设置到目标 Surface 中</span></span><br><span class="line">        setSurfaceControl(env, clazz, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>copyFrom 期间一共有三个关键对象，它们分别是：</p><ul><li>SurfaceComposerClient</li><li>SurfaceControl</li><li>Surface，这个 Surface 对象属于 Native 层，和 Java 层的 Surface 相对应</li></ul><p>其中转移到 ViewRoot 成员变量 mSurface 中的，就是最后这个 Surface 对象了。</p><p>在 SurfaceFlinger 进程中，Client 的一个 Layer 将使用 SharedBufferStack 数组中的一个成员，并通过 SharedBufferServer 结构来控制这个成员，我们知道 SurfaceFlinger 是消费者，所以可由 SharedBufferServer 来控制数据的读取。</p><p>与之相对应，客户端的进程也会有一个对象来使用这个 SharedBufferStack，可它是通过另外一个叫 SharedBufferClient 的结构来控制的。客户端为 SurfaceFlinger 提供数据，所以可由 SharedBufferClient 控制数据的写入。</p><h2 id="Surface-显示过程"><a href="#Surface-显示过程" class="headerlink" title="Surface 显示过程"></a>Surface 显示过程</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_surfaceflinger/surface_display.png?raw=true" alt=""></p><p>如图所示，在 App 进程中创建 PhoneWindow 后会创建 ViewRoot。ViewRoot 的创建会创建一个 Surface，这个 Surface 其实是空的，通过与 WindowManagerService 通信 copyFrom() 一个 NativeSurface。在与 SurfaceFlinger 通信时，会创建 SharedClient 一段共享内存，里面存放的是 SharedBufferStack 对应 SurfaceFlinger 中的 SurfaceLayer 每个 Layer 其实是一个 FrameBuffer，每个 FrameBuffer 中有两个 GraphicBuffer 记作 FrontBuffer 和 BackBuffer。</p><p>在 SurfaceFlinger 中 SharedBufferServer 来管理 FrameBuffer。同时在 App 端 copyFrom() 出来 NativeSurface 时会创建一个 SharedBufferClient 与 SharedClient 这块共享内存关联。当客户端 addView() 或者需要更新 View 时，会通过 SharedBufferClient 写入数据到 ShareClient 中，SurfaceFlinger 中的 SharedBufferServer 接收到通知会将 FrameBuffer 中的数据传输到屏幕上。</p><p>HWComposer 是基于硬件来产生 VSync 信号的，来通知 SurfaceFlinger 重绘控制显示的帧率。</p><p>以上理解属于个人观点，能力有限，若有错误欢迎指出，欢迎交流学习，共同进步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://blog.csdn.net/innost/article/details/47208337" target="_blank" rel="noopener">深入理解Surface系统</a></li><li><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">Android图形系统</a></li><li><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">SurfaceFlinger启动篇</a></li><li><a href="http://gityuan.com/2017/02/18/surface_flinger_2/" target="_blank" rel="noopener">SurfaceFlinger绘图篇</a></li><li>《深入理解 Android 内核设计思想》</li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Surface </tag>
            
            <tag> SurfaceFlinger </tag>
            
            <tag> 视图显示原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章看明白 Activity 与 Window 与 View 之间的关系</title>
      <link href="/2018/02/11/android-activity-window-view/"/>
      <url>/2018/02/11/android-activity-window-view/</url>
      <content type="html"><![CDATA[<h1 id="Android-Activity-与-Window-与-View-之间的关系"><a href="#Android-Activity-与-Window-与-View-之间的关系" class="headerlink" title="Android - Activity 与 Window 与 View 之间的关系"></a>Android - Activity 与 Window 与 View 之间的关系</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道 Activity 启动后就可以看到我们写的 Layout 布局界面，Activity 从 setContentView() 到显示中间做了什么呢？下面我们就来分析下这个过程。</p><p>如不了解 Activity 的启动过程请参阅：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Activity启动过程.md" target="_blank" rel="noopener">Activity 启动过程</a></p><p>本文主要对于以下问题进行分析：</p><ul><li>Window 是什么？</li><li>Activity 与 PhoneWindow 与 DecorView 之间什么关系？</li></ul><h2 id="onCreate-Window-创建过程"><a href="#onCreate-Window-创建过程" class="headerlink" title="onCreate() - Window 创建过程"></a>onCreate() - Window 创建过程</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_activity/app_start.png?raw=true" alt=""></p><p>在 Activity 创建过程中执行 scheduleLaunchActivity() 之后便调用到了 handleLaunchActivity() 方法。</p><p>ActivityThread.handleLaunchActivity()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//初始化 WindowManagerService，主要是获取到 WindowManagerService 代理对象</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    <span class="comment">//详情见下面分析</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        <span class="comment">//详见下面分析 [onResume() - Window 显示过程]</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//获取 ClassLoader</span></span><br><span class="line">    java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">    <span class="comment">//创建目标 Activity 对象</span></span><br><span class="line">    activity = mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line">    StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">    r.intent.setExtrasClassLoader(cl);</span><br><span class="line">    r.intent.prepareToEnterProcess();</span><br><span class="line">    <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.state.setClassLoader(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Application 对象</span></span><br><span class="line">    Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">        CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">        Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">        <span class="comment">//详情见下面分析</span></span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                r.referrer, r.voiceInteractor);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//回调 Activity.onCreate()</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, <span class="keyword">int</span> ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>); <span class="comment">//创建 PhoneWindow</span></span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    mApplication = application; <span class="comment">//所属的 Application</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置并获取 WindowManagerImpl 对象</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可看出 Activity 里新建一个 PhoneWindow 对象。在 Android 中，Window 是个抽象的概念， Android 中 Window 的具体实现类是 PhoneWindow，Activity 和 Dialog 中的 Window 对象都是 PhoneWindow。</p><p>同时得到一个 WindowManager 对象，WindowManager 是一个抽象类，这个 WindowManager 的具体实现是在 WindowManagerImpl 中，对比 Context 和 ContextImpl。</p><p>Window.setWindowManager()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName, <span class="keyword">boolean</span> hardwareAccelerated)</span> </span>&#123; </span><br><span class="line">    ...    </span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 Activity 会有一个 WindowManager 对象，这个 mWindowManager 就是和 WindowManagerService 进行通信，也是 WindowManagerService 识别 View 具体属于那个 Activity 的关键，创建时传入 IBinder 类型的 mToken。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindow.setWindowManager(..., mToken, ..., ...)</span><br></pre></td></tr></table></figure><p>这个 Activity 的 mToken，这个 mToken 是一个 IBinder，WindowManagerService 就是通过这个 IBinder 来管理 Activity 里的 View。</p><p>回调 Activity.onCreate() 后，会执行 setContentView() 方法将我们写的 Layout 布局页面设置给 Activity。</p><p>Activity.setContentView()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);        </span><br><span class="line">    initWindowDecorActionBar();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PhoneWindow.setContentView()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">    installDecor(); </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PhoneWindow.installDecor()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"><span class="comment">//根据不同的 Theme，创建不同的 DecorView，DecorView 是一个 FrameLayout </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时只是创建了 PhoneWindow，和DecorView，但目前二者也没有任何关系，产生关系是在ActivityThread.performResumeActivity 中，再调用 r.activity.performResume()，调用 r.activity.makeVisible，将 DecorView 添加到当前的 Window 上。</p><h2 id="onResume-Window-显示过程"><a href="#onResume-Window-显示过程" class="headerlink" title="onResume() - Window 显示过程"></a>onResume() - Window 显示过程</h2><p>Activity 与 PhoneWindow 与 DecorView 关系图：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_activity_window_view/android_phonewindow_decorview.png?raw=true" alt=""></p><p>ActivityThread.handleResumeActivity()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行到 onResume()</span></span><br><span class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">        <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mNumVisibleActivities++;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="comment">//添加视图，详见下面分析</span></span><br><span class="line">                r.activity.makeVisible(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//resume 完成</span></span><br><span class="line">        <span class="keyword">if</span> (reallyResume) &#123;</span><br><span class="line">              ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> clearHide)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//回调 onResume()</span></span><br><span class="line">        r.activity.performResume();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Activity.makeVisible()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        <span class="comment">//详见下面分析</span></span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManager 的 addView 的具体实现在 WindowManagerImpl 中，而 WindowManagerImpl 的 addView 又会调用 WindowManagerGlobal.addView()。</p><p>WindowManagerGlobal.addView()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ViewRootImpl root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);        </span><br><span class="line">    view.setLayoutParams(wparams);    </span><br><span class="line">    mViews.add(view);    </span><br><span class="line">    mRoots.add(root);    </span><br><span class="line">    mParams.add(wparams);        </span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个过程创建一个 ViewRootImpl，并将之前创建的 DecoView 作为参数传入，以后 DecoView 的事件都由 ViewRootImpl 来管理了，比如，DecoView 上添加 View，删除 View。ViewRootImpl 实现了 ViewParent 这个接口，这个接口最常见的一个方法是 requestLayout()。</p><p>ViewRootImpl 是个 ViewParent，在 DecoView 添加的 View 时，就会将 View 中的 ViewParent 设为 DecoView 所在的 ViewRootImpl，View 的 ViewParent 相同时，理解为这些 View 在一个 View 链上。所以每当调用 View 的 requestLayout()时，其实是调用到 ViewRootImpl，ViewRootImpl 会控制整个事件的流程。可以看出一个 ViewRootImpl 对添加到 DecoView 的所有 View 进行事件管理。</p><p>ViewRootImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">//获取 IWindowSession 的代理类</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    mDisplay = display;</span><br><span class="line">    mThread = Thread.currentThread(); <span class="comment">//主线程</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>); </span><br><span class="line">    mChoreographer = Choreographer.getInstance();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过 Binder 调用，进入 system 进程的 Session</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">          getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">          mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">          mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManagerGlobal：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取 InputManagerService 的代理类</span></span><br><span class="line">                InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取 WindowManagerService 的代理类</span></span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                <span class="comment">//经过 Binder 调用，最终调用 WindowManagerService</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;...&#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 binder 调用进入 system_server 进程。<br>Session：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> <span class="keyword">extends</span> <span class="title">IWindowSession</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//详情见下面</span></span><br><span class="line">        <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">                outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManagerService：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">    <span class="comment">//创建 WindowState</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调整 WindowManager 的 LayoutParams 参数</span></span><br><span class="line">    mPolicy.adjustWindowParamsLw(win.mAttrs);</span><br><span class="line">    res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">    addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 设置 input</span></span><br><span class="line">    mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    <span class="comment">// 创建 Surface 与 SurfaceFlinger 通信，详见下面[SurfaceFlinger 图形系统]</span></span><br><span class="line">    win.attach();</span><br><span class="line">    mWindowMap.put(client.asBinder(), win);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">//当该窗口能接收按键事件，则更新聚焦窗口</span></span><br><span class="line">        focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建 Surface 的过程详见：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-SurfaceFlinger图形系统.md" target="_blank" rel="noopener">SurfaceFlinger 图形系统</a></p><p>Activity 中 Window 创建过程：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_activity_window_view/android_activity_window_create.png?raw=true" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Window 是什么？</li></ul><p>Window 是 Android 中窗口的宏观定义，主要是管理 View 的创建，以及与 ViewRootImpl 的交互，将 Activity 与 View 解耦。</p><ul><li>Activity 与 PhoneWindow 与 DecorView 之间什么关系？</li></ul><p>一个 Activity 对应一个 Window 也就是 PhoneWindow，一个 PhoneWindow 持有一个 DecorView 的实例，DecorView 本身是一个 FrameLayout。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2017/01/22/start-activity-wms/" target="_blank" rel="noopener">以Window视角来看startActivity</a></li><li><a href="https://silencedut.github.io/2016/08/10/Android视图框架Activity,Window,View,ViewRootImpl理解" target="_blank" rel="noopener">Android视图框架Activity,Window,View,ViewRootImpl理解</a></li><li>《深入理解 Android 内核设计思想》</li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Activity </tag>
            
            <tag> Window </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章看明白 Android 从点击应用图标到界面显示的过程</title>
      <link href="/2018/01/04/android-activity-start/"/>
      <url>/2018/01/04/android-activity-start/</url>
      <content type="html"><![CDATA[<h1 id="Android-Activity-启动过程"><a href="#Android-Activity-启动过程" class="headerlink" title="Android - Activity 启动过程"></a>Android - Activity 启动过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从点击桌面应用图标到应用显示的过程我们再熟悉不过了，下面我们来分析下这个过程都做了什么。</p><p>本文主要对以下问题分析：</p><ul><li>ActivityThread 是什么，它是一个线程吗，如何被启动的？</li><li>ActivityClientRecord 与 ActivityRecord 是什么？</li><li>Context 是什么，ContextImpl，ContextWapper 是什么？</li><li>Instrumentation 是什么？</li><li>Application 是什么，什么时候创建的，每个应用程序有几个 Application？</li><li>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？</li><li>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？</li></ul><h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h2><p>如不了解 Android 是如何从开机到 Launcher 启动的过程，请先阅读<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-系统启动过程.md" target="_blank" rel="noopener">Android - 系统启动过程</a>。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/android-bootloader.png?raw=true" alt=""></p><p>我们知道 Android 系统启动后已经启动了 Zygote，ServiceManager，SystemServer 等系统进程；ServiceManager 进程中完成了 Binder 初始化；SystemServer 进程中 ActivityManagerService，WindowManagerService，PackageManagerService 等系统服务在 ServiceManager 中已经注册；最后启动了 Launcher 桌面应用。</p><p>其实 Launcher 本身就是一个应用程序，运行在自己的进程中，我们看到的桌面就是 Launcher 中的一个 Activity。</p><p>应用安装的时候，通过 PackageManagerService 解析 apk 的 AndroidManifest.xml 文件，提取出这个 apk 的信息写入到 packages.xml 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下/data/system/packages.xml。</p><p>同时桌面 Launcher 会为安装过的应用生成不同的应用入口，对应桌面上的应用图标，下面分析点击应用图标的到应用启动的过程。</p><h2 id="点击-Launcher-中应用图标"><a href="#点击-Launcher-中应用图标" class="headerlink" title="点击 Launcher 中应用图标"></a>点击 Launcher 中应用图标</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_activity/app_start.png?raw=true" alt=""></p><p>点击 Launcher 中应用图标将会执行以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Launcher.startActivitySafely()</span><br><span class="line">Launcher.startActivity()</span><br><span class="line"><span class="comment">//以上两个方法主要是检查将要打开的 Activity 是否存在</span></span><br><span class="line"></span><br><span class="line">Activity.startActivity()</span><br><span class="line"><span class="comment">//这段代码大家已经很熟悉，经常打开 Activity 用的就是这个方法</span></span><br><span class="line"></span><br><span class="line">Activity.startActivityForResult()</span><br><span class="line"><span class="comment">//默认 requestCode = -1，也可通过调用 startActivityForResult() 传入 requestCode。 </span></span><br><span class="line"><span class="comment">//然后通过 MainThread 获取到 ApplicationThread 传入下面方法。</span></span><br><span class="line"></span><br><span class="line">Instrumentation.execStartActivity()</span><br><span class="line"><span class="comment">//通过 ActivityManagerNative.getDefault() 获取到 ActivityManagerService 的代理为进程通讯作准备。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerNative.getDefault().startActivity()</span><br><span class="line">ActivityManagerProxy.startActivity()</span><br><span class="line"><span class="comment">//调用代理对象的 startActivity() 方法，发送 START_ACTIVITY_TRANSACTION 命令。</span></span><br></pre></td></tr></table></figure><p>在 system_server 进程中的服务端 ActivityManagerService 收到 START_ACTIVITY_TRANSACTION 命令后进行处理，调用 startActivity() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startActivity() -&gt; startActivityAsUser(intent, requestCode, userId)</span><br><span class="line"><span class="comment">//通过 UserHandle.getCallingUserId() 获取到 userId 并调用 startActivityAsUser() 方法。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityMayWait() -&gt; resolveActivity()</span><br><span class="line"><span class="comment">//通过 intent 创建新的 intent 对象，即使之前 intent 被修改也不受影响。 然后调用 resolveActivity()。</span></span><br><span class="line"><span class="comment">//然后通过层层调用获取到 ApplicationPackageManager 对象。</span></span><br><span class="line"></span><br><span class="line">PackageManagerService.resolveIntent() -&gt; queryIntentActivities()</span><br><span class="line"><span class="comment">//获取 intent 所指向的 Activity 信息，并保存到 Intent 对象。</span></span><br><span class="line"></span><br><span class="line">PackageManagerService.chooseBestActivity()</span><br><span class="line"><span class="comment">//当存在多个满足条件的 Activity 则会弹框让用户来选择。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityLocked()</span><br><span class="line"><span class="comment">//获取到调用者的进程信息。 通过 Intent.FLAG_ACTIVITY_FORWARD_RESULT 判断是否需要进行 startActivityForResult 处理。 </span></span><br><span class="line"><span class="comment">//检查调用者是否有权限来调用指定的 Activity。 </span></span><br><span class="line"><span class="comment">//创建 ActivityRecord 对象，并检查是否运行 App 切换。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityUncheckedLocked() -&gt; startActivityLocked()</span><br><span class="line"><span class="comment">//进行对 launchMode 的处理[可参考 Activity 启动模式]，创建 Task 等操作。</span></span><br><span class="line"><span class="comment">//启动 Activity 所在进程，已存在则直接 onResume()，不存在则创建 Activity 并处理是否触发 onNewIntent()。</span></span><br><span class="line"></span><br><span class="line">ActivityStack.resumeTopActivityInnerLocked()</span><br><span class="line"><span class="comment">//找到 resume 状态的 Activity，执行 startPausingLocked() 暂停该 Activity，同时暂停所有处于后台栈的 Activity，找不到 resume 状态的 Activity 则回桌面。</span></span><br><span class="line"><span class="comment">//如果需要启动的 Activity 进程已存在，直接设置 Activity 状态为 resumed。 调用下面方法。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startSpecificActivityLocked()</span><br><span class="line"><span class="comment">//进程存在调用 realStartActivityLocked() 启动 Activity，进程不存在则调用下面方法。</span></span><br></pre></td></tr></table></figure><h2 id="fork-新进程"><a href="#fork-新进程" class="headerlink" title="fork 新进程"></a>fork 新进程</h2><p>从 Launcher 点击图标，如果应用没有启动过，则会 fork 一个新进程。创建新进程的时候，ActivityManagerService 会保存一个 ProcessRecord 信息，Activity 应用程序中的AndroidManifest.xml 配置文件中，我们没有指定 Application 标签的 process 属性，系统就会默认使用 package 的名称。每一个应用程序都有自己的 uid，因此，这里 uid + process 的组合就可以为每一个应用程序创建一个 ProcessRecord。每次在新建新进程前的时候会先判断这个 ProcessRecord 是否已存在，如果已经存在就不会新建进程了，这就属于应用内打开 Activity 的过程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startProcessLocked()</span><br><span class="line"><span class="comment">//进程不存在请求 Zygote 创建新进程。 创建成功后切换到新进程。</span></span><br></pre></td></tr></table></figure><p>进程创建成功切换至 App 进程，进入 app 进程后将 ActivityThread 类加载到新进程，并调用 ActivityThread.main() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.main()</span><br><span class="line"><span class="comment">//创建主线程的 Looper 对象，创建 ActivityThread 对象，ActivityThread.attach() 建立 Binder 通道，开启 Looper.loop() 消息循环。</span></span><br><span class="line"></span><br><span class="line">ActivityThread.attach()</span><br><span class="line"><span class="comment">//开启虚拟机各项功能，创建 ActivityManagerProxy 对象，调用基于 IActivityManager 接口的 Binder 通道 ActivityManagerProxy.attachApplication()。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerProxy.attachApplication()</span><br><span class="line"><span class="comment">//发送 ATTACH_APPLICATION_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><p>此时只创建了应用程序的 ActivityThread 和 ApplicationThread，和开启了 Handler 消息循环机制，其他的都还未创建， ActivityThread.attach(false) 又会最终到 ActivityMangerService 的 attachApplication，这个工程其实是将本地的 ApplicationThread 传递到 ActivityMangerService。然后 ActivityMangerService 就可以通过 ApplicationThread 的代理 ApplicationThreadProxy 来调用应用程序 ApplicationThread.bindApplication，通知应用程序的 ApplicationThread 已和 ActivityMangerService 绑定，可以不借助其他进程帮助直接通信了。此时 Launcher 的任务也算是完成了。</p><p>在 system_server 进程中的服务端 ActivityManagerService 收到 ATTACH_APPLICATION_TRANSACTION 命令后进行处理，调用 attachApplication()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityMangerService.attachApplication() -&gt; attachApplicationLocked()</span><br><span class="line"><span class="comment">//首先会获取到进程信息 ProcessRecord。 绑定死亡通知，移除进程启动超时消息。 获取到应用 ApplicationInfo 并绑定应用 IApplicationThread.bindApplication(appInfo)。</span></span><br><span class="line"><span class="comment">//然后检查 App 所需组件。</span></span><br></pre></td></tr></table></figure><ul><li>Activity: 检查最顶层可见的 Activity 是否等待在该进程中运行，调用 ActivityStackSupervisor.attachApplicationLocked()。</li><li>Service：寻找所有需要在该进程中运行的服务，调用 ActiveServices.attachApplicationLocked()。</li><li>Broadcast：检查是否在这个进程中有下一个广播接收者，调用 sendPendingBroadcastsLocked()。</li></ul><p>此处讨论 Activity 的启动过程，只讨论 ActivityStackSupervisor.attachApplicationLocked() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityStackSupervisor.attachApplicationLocked() -&gt; realStartActivityLocked()</span><br><span class="line"><span class="comment">//将该进程设置为前台进程 PROCESS_STATE_TOP，调用 ApplicationThreadProxy.scheduleLaunchActivity()。</span></span><br><span class="line"></span><br><span class="line">ApplicationThreadProxy.scheduleLaunchActivity()</span><br><span class="line"><span class="comment">//发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><p>发送送完 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，还会发送 BIND_APPLICATION_TRANSACTION 命令来创建 Application。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThreadProxy.bindApplication()</span><br><span class="line"><span class="comment">//发送 BIND_APPLICATION_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><h2 id="App-进程初始化"><a href="#App-进程初始化" class="headerlink" title="App 进程初始化"></a>App 进程初始化</h2><p>在 app 进程中，收到 BIND_APPLICATION_TRANSACTION 命令后调用 ActivityThread.bindApplication()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.bindApplication()</span><br><span class="line"><span class="comment">//缓存 Service，初始化 AppBindData，发送消息 H.BIND_APPLICATION。</span></span><br></pre></td></tr></table></figure><p>ApplicationThreadProxy.bindApplication(…) 会传来这个应用的一些信息，如ApplicationInfo，Configuration 等，在 ApplicationThread.bindApplication 里会待信息封装成A ppBindData，通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(H.BIND_APPLICATION, data)</span><br></pre></td></tr></table></figure><p>将信息放到应用里的消息队列里，通过 Handler 消息机制，在 ActivityThread.handleMeaasge 里处理 H.BIND_APPLICATION 的信息，调用 AplicationThread.handleBindApplication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    Process.setArgV0(data.processName);<span class="comment">//设置进程名</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化 mInstrumentation</span></span><br><span class="line">    <span class="keyword">if</span>(data.mInstrumentation!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Application，data.info 是个 LoadedApk 对象。</span></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line">    <span class="comment">//调用 Application 的 onCreate()方法。</span></span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;   </span><br><span class="line">       <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时新建一个 Application 的 ContextImpl 对象，</span></span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过在 handleBindApplication 创建的 mInstrumentation 对象新建一个 Application 对象，同时进行 attach。</span></span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置进程名，获取 LoadedApk 对象，创建 ContextImpl 上下文</span></span><br><span class="line"><span class="comment">//LoadedApk.makeApplication() 创建 Application 对象，调用 Application.onCreate() 方法。</span></span><br></pre></td></tr></table></figure><p>Instrumentation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line">Instrumentation类：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span>  </span>&#123;</span><br><span class="line">    <span class="comment">//实例化 Application</span></span><br><span class="line">    Application app = (Application)clazz.newInstance();     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Application 和 context绑定</span></span><br><span class="line">    app.attach(context);    </span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//attach 就是将新建的 ContextImpl 赋值到 mBase，这个 ContextImpl 对象就是所有Application 内 Context 的具体实现，同时赋值一些其他的信息如 mLoadedApk。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;    </span><br><span class="line">    mBase = base;  </span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时 Application 就创建好了，这点很重要，很多资料里说 Application 是在performLaunchActivity() 里创建的，因为 performLaunchActivity() 也有mInstrumentation.newApplication 这个调用，newApplication() 函数中可看出会先判断是否以及创建了 Application，如果之前已经创建，就返回已创建的 Application 对象。</p><h2 id="Activity-启动"><a href="#Activity-启动" class="headerlink" title="Activity 启动"></a>Activity 启动</h2><p>上面 fork 进程时会发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，在 app 进程中，收到 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令后调用 ApplicationThread.scheduleLaunchActivity()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThread.scheduleLaunchActivity()</span><br><span class="line"><span class="comment">//发送消息 H.LAUNCH_ACTIVITY。</span></span><br><span class="line"></span><br><span class="line">sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line"></span><br><span class="line">ActivityThread.handleLaunchActivity()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onConfigurationChanged()，初始化 WindowManagerService。</span></span><br><span class="line"><span class="comment">//调用 ActivityThread.performLaunchActivity()</span></span><br><span class="line"></span><br><span class="line">ActivityThread.performLaunchActivity() &#123;</span><br><span class="line">    <span class="comment">//类似 Application 的创建过程，通过 classLoader 加载到 activity.</span></span><br><span class="line">    activity = mInstrumentation.newActivity(classLoader, </span><br><span class="line">               component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">//因为 Activity 有界面，所以其 Context 是 ContextThemeWrapper 类型，但实现类仍是ContextImpl.</span></span><br><span class="line">    Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">    activity.attach(context,mInstrumentation,application,...);</span><br><span class="line">    <span class="comment">//与 Window 进行关联</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//attach 后调用 activity 的 onCreate()方法。</span></span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity,...)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在ActivityThread.handleLaunchActivity里，接着调用</span></span><br><span class="line"></span><br><span class="line">Activity.performCreate() -&gt; onCreate()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onCreate()。</span></span><br><span class="line"></span><br><span class="line">Activity.setContentView()</span><br><span class="line"><span class="comment">//设置 layout 布局</span></span><br><span class="line"></span><br><span class="line">ActivityThread.performResumeActivity()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onResume()。</span></span><br></pre></td></tr></table></figure><p>与 Window 进行关联，具体过程详见：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Activity与Window与View之间的关系.md" target="_blank" rel="noopener">Activity，Window，View 之间的关系</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Activity 的整体启动流程如图所示：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_activity/activity_start.jpg?raw=true" alt="Activity 启动过程"></p><ul><li>ActivityThread 是什么，它是一个线程吗，如何被启动的？</li></ul><p>它不是一个线程，它是运行在 App 进程中的主线程中的一个方法中。当 App 进程创建时会执行 ActivityThread.main()，ActivityThread.main() 首先会创建 Looper 执行 Looper.prepareMainLooper()；然后创建 ActivityThread 并调用 ActivityThread.attach() 方法告诉 ActivityManagerService 我们创建了一个应用 并将 ApplicationThread 传给 ActivityManagerService；最后调用 Looper.loop()。</p><ul><li>ActivityClientRecord 与 ActivityRecord 是什么？</li></ul><p>记录 Activity 相关信息，比如：Window，configuration，ActivityInfo 等。<br>ActivityClientRecord 是客户端的，ActivityRecord 是 ActivityManagerService 服务端的。</p><ul><li>Context 是什么，ContextImpl，ContextWapper 是什么？</li></ul><p>Context 定义了 App 进程的相关环境，Context 是一个接口，ContextImpl 是子类，ContextWapper 是具体实现。</p><p>应用资源是在 Application 初始化的时候，也就是创建 Application，ContextImpl 的时候，ContextImpl 就包含这个路径，主要就是对就是 ResourcesManager 这个单例的引用。</p><p>可以看出每次创建 Application 和 Acitvity 以及 Service 时就会有一个 ContextImpl 实例，ContentProvider 和B roadcastReceiver 的 Context 是其他地方传入的。</p><p>所以 Context 数量 = Application 数量 + Activity 数量 + Service 数量，单进程情况下 Application 数量就是 1。</p><ul><li>Instrumentation 是什么？</li></ul><p>管理着组件 Application，Activity，Service 等的创建，生命周期调用。</p><ul><li>Application 是什么，什么时候创建的，每个应用程序有几个 Application？</li></ul><p>Application 是在 ActivityThread.handleBindApplication() 中创建的，一个进程只会创建一个 Application，但是一个应用如果有多个进程就会创建多个 Application 对象。</p><ul><li>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？</li></ul><p>点击 Launcher 时会创建一个新进程来开启 Activity，而应用内打开 Activity，如果 Activity 不指定新进程，将在原来进程打开，是否开启新进程实在 ActivityManagerService 进行控制的，上面分析得到，每次开启新进程时会保存进程信息，默认为 应用包名 + 应用UID，打开 Activity 时会检查请求方的信息来判断是否需要新开进程。Launcher 打开 Activity 默认 ACTIVITY_NEW_TASK，新开一个 Activity 栈来保存 Activity 的信息。</p><ul><li>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？</li></ul><p>Activity.onCreate() 完成了 App 进程，Application，Activity 的创建，调用 setContentView() 给 Activity 设置了 layout 布局。</p><p>Activity.onResume() 完成了 Activity 中 Window 与 WindowManager 的关联，并对所有子 View 进行渲染并显示。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/6685853/" target="_blank" rel="noopener">Android应用程序的Activity启动过程简要介绍和学习计划</a></li><li><a href="https://silencedut.github.io/2016/08/02/Android%20应用点击图标到Activity界面显示的过程分析/" target="_blank" rel="noopener">Android 应用点击图标到Activity界面显示的过程分析</a></li><li>《深入理解 Android 内核设计思想》</li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Activity </tag>
            
            <tag> 启动过程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 项目架构探索</title>
      <link href="/2017/12/12/android-arch/"/>
      <url>/2017/12/12/android-arch/</url>
      <content type="html"><![CDATA[<h1 id="Android-Architecture"><a href="#Android-Architecture" class="headerlink" title="Android Architecture"></a>Android Architecture</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>该项目结合 MVP 与 Clean 架构思想，探索在 Android 项目上的最佳实践。</p><p>遵循 <a href="https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">Clean Architecture</a> 的原则。</p><p><img src="https://github.com/jeanboydev/Android-Architecture/blob/master/resources/images/android-architecture.png?raw=true" alt="architecture"></p><ul><li>数据层（Data Layer）：加入数据转换层（Mapper）将服务端数据模型（Entity）与本地数据模型（Model）解耦。</li><li>业务层（Domain Layer）：按模块划分业务，具体业务交给 Usecase 处理。</li><li>显示层（View Layer）： Presenter 不再与 Activity/Fragment 一一对应，Presenter 按照业务模块划分功能，大大提高 Presenter 的复用性。Activity/Fragment 中可以实现多个 View，持有多个 Presenter 来完成业务逻辑。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><table><thead><tr><th>分支</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/jeanboydev/Android-Architecture" target="_blank" rel="noopener">master</a></td><td>演示了 Model-View-Presenter（MVP）+ Clean 架构，提供一些基类，状态栏沉浸适配等</td></tr><tr><td><a href="https://github.com/jeanboydev/Android-Architecture/tree/develop" target="_blank" rel="noopener">develop</a></td><td>使用 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a></td></tr><tr><td><a href="https://github.com/jeanboydev/Android-Architecture/tree/develop-dagger" target="_blank" rel="noopener">develop-dagger</a></td><td>加入 <a href="https://github.com/google/dagger" target="_blank" rel="noopener">dagger</a> 的支持</td></tr><tr><td><a href="https://github.com/jeanboydev/Android-Architecture/tree/develop-dagger-rxjava" target="_blank" rel="noopener">develop-dagger-rxjava</a></td><td>加入 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">rxjava</a> 的支持</td></tr></tbody></table><h2 id="数据层（Data-Layer）"><a href="#数据层（Data-Layer）" class="headerlink" title="数据层（Data Layer）"></a>数据层（Data Layer）</h2><p><img src="https://github.com/jeanboydev/Android-Architecture/blob/master/resources/images/android-architecture-data.png?raw=true" alt="data.png"></p><p>数据层（Data Layer）主要是数据获取与数据缓存策略的处理。</p><p>比如：第一次获取到数据，缓存到持久层（持久层可以放入数据库，SharedPreferences，文件或者其他形式）和内存中；第二次获取数据时应优先从内存中读取，其次是持久层，若本地缓存失效则直接从远程服务端获取，然后缓存到本地。</p><p>具体实现参见 <a href="https://github.com/jeanboydev/Android-Architecture/blob/master/data/src/main/java/com/jeanboy/data/repository/UserRepository.java" target="_blank" rel="noopener">UserRepository</a></p><h2 id="业务层（Domain-Layer）"><a href="#业务层（Domain-Layer）" class="headerlink" title="业务层（Domain Layer）"></a>业务层（Domain Layer）</h2><p><img src="https://github.com/jeanboydev/Android-Architecture/blob/master/resources/images/android-architecture-domain-data.png?raw=true" alt="domain-data"></p><p>业务层（Domain Layer）主要是根据业务需求来操作数据的逻辑。业务层将每条需求交个 Usecase 来处理，Usecase 通过 Repository 来获取数据。业务层与数据层解耦，方便扩展与测试。</p><p>具体实现参见 <a href="https://github.com/jeanboydev/Android-Architecture/blob/master/domain/src/main/java/com/jeanboy/domain/usecase/LoginRemoteTask.java" target="_blank" rel="noopener">LoginRemoteTask</a></p><h2 id="显示层（View-Layer）"><a href="#显示层（View-Layer）" class="headerlink" title="显示层（View Layer）"></a>显示层（View Layer）</h2><p><img src="https://github.com/jeanboydev/Android-Architecture/blob/master/resources/images/android-architecture-view-domain.png?raw=true" alt="view-domain"></p><p>显示层（View Layer）主要是数据的展示与更新操作。显示层通过 Presenter 与业务层交互，Activity / Fragment 与 Presenter 解耦，将业务实现由 Presenter 组合而成。Presenter 与 View 对应，Activity / Fragment 由多个 View 管理。</p><p>具体实现参见 <a href="https://github.com/jeanboydev/Android-Architecture/blob/master/app/src/main/java/com/jeanboy/app/architecture/ui/activity/LoginActivity.java" target="_blank" rel="noopener">LoginActivity</a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://github.com/jeanboydev/Android-Architecture/blob/master/resources/images/android_project.png?raw=true" alt="architecture"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/Blankj/AndroidStandardDevelop" target="_blank" rel="noopener">Android 开发规范</a></li><li><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">android-architecture</a></li><li><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">Android-CleanArchitecture</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Architecture </tag>
            
            <tag> 内存优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - 性能优化 内存优化</title>
      <link href="/2017/11/05/android-performance-optimization-memory/"/>
      <url>/2017/11/05/android-performance-optimization-memory/</url>
      <content type="html"><![CDATA[<h1 id="Android-性能优化-内存优化"><a href="#Android-性能优化-内存优化" class="headerlink" title="Android - 性能优化 内存优化"></a>Android - 性能优化 内存优化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="JVM-内存分配机制"><a href="#JVM-内存分配机制" class="headerlink" title="JVM 内存分配机制"></a>JVM 内存分配机制</h2><ul><li>详见：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/JVM/JVM-内存分配机制.md" target="_blank" rel="noopener">JVM 内存分配机制</a></li></ul><h2 id="JVM-垃圾回收机制"><a href="#JVM-垃圾回收机制" class="headerlink" title="JVM 垃圾回收机制"></a>JVM 垃圾回收机制</h2><ul><li>详见：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/JVM/JVM-垃圾回收机制.md" target="_blank" rel="noopener">JVM 垃圾回收机制</a></li></ul><h2 id="DVM-与-JVM-的区别"><a href="#DVM-与-JVM-的区别" class="headerlink" title="DVM 与 JVM 的区别"></a>DVM 与 JVM 的区别</h2><ul><li>虚拟机区别</li></ul><p>Dalvik 虚拟机（DVM）是 Android 系统在 java虚拟机（JVM）基础上优化得到的，DVM 是基于寄存器的，而 JVM 是基于栈的，由于寄存器高效快速的特性，DVM 的性能相比 JVM 更好。</p><ul><li>字节码区别</li></ul><p>Dalvik 执行 <strong>.dex</strong> 格式的字节码文件，JVM 执行的是 <strong>.class</strong> 格式的字节码文件，Android 程序在编译之后产生的 .class 文件会被 aapt 工具处理生成 R.class 等文件，然后 dx 工具会把 .class 文件处理成 .dex 文件，最终资源文件和 .dex 文件等打包成 .apk 文件。</p><h2 id="OOM-代码相关优化"><a href="#OOM-代码相关优化" class="headerlink" title="OOM 代码相关优化"></a>OOM 代码相关优化</h2><p>当应用程序申请的 java heap 空间超过 Dalvik VM HeapGrowthLimit 时溢出。 OOM 并不代表内存不足，只要申请的 heap 超过 Dalvik VM HeapGrowthLimit 时，即使内存充足也会溢出。 效果是能让较多进程常驻内存。</p><ul><li>Bitmap</li></ul><p>Bitmap 非常消耗内存，而且在 Android 中，读取 bitmap 时， 一般分配给虚拟机的图片堆栈只有 8M，所以经常造成 OOM 问题。 所以有必要针对 Bitmap 的使用作出优化：</p><ol><li>图片显示：加载合适尺寸的图片，比如显示缩略图的地方不要加载大图。</li><li>图片回收：使用完 bitmap，及时使用 Bitmap.recycle() 回收。</li></ol><blockquote><p>问题：Android 不是自身具备垃圾回收机制吗？此处为何要手动回收？</p><p>Bitmap 对象不是 new 生成的，而是通过 BitmapFactory 生产的。 而且通过源码可发现是通过调用 JNI 生成 Bitma p对象（nativeDecodeStream()等方法）。 所以，加载 bitmap 到内存里包括两部分，Dalvik 内存和 Linux kernel 内存。 前者会被虚拟机自动回收。 而后者必须通过 recycle() 方法，内部调用 nativeRecycle() 让 linux kernel 回收。</p></blockquote><ol start="3"><li>捕获 OOM 异常：程序中设定如果发生 OOM 的应急处理方式。</li><li>图片缓存：内存缓存、硬盘缓存等</li><li>图片压缩：直接使用 ImageView 显示 Bitmap 时会占很多资源，尤其当图片较大时容易发 生OOM。 可以使用 BitMapFactory.Options 对图片进行压缩。</li><li>图片像素：android 默认颜色模式为 ARGB_8888，显示质量最高，占用内存最大。 若要求不高时可采用 RGB_565 等模式。 </li><li>图片大小：图片 长度×宽度×单位像素 所占据字节数。</li></ol><p>我们知道 ARGB 指的是一种色彩模式，里面 A 代表 Alpha，R 表示 Red，G 表示 Green，B 表示 Blue。 所有的可见色都是由红绿蓝组成的，所以红绿蓝又称为三原色，每个原色都存储着所表示颜色的信息值,下表中对四种颜色模式的详细描述，以及每种色彩模式占用的字节数。</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th><th style="text-align:left">占用字节</th></tr></thead><tbody><tr><td style="text-align:left">ALPHA</td><td style="text-align:left">Alpha 由 8 位组成</td><td style="text-align:left">1B</td></tr><tr><td style="text-align:left">ARGB_4444</td><td style="text-align:left">4 个 4 位组成 16 位，每个色彩元素站 4 位</td><td style="text-align:left">2B</td></tr><tr><td style="text-align:left">ARGB_8888</td><td style="text-align:left">4 个 8 为组成 32 位，每个色彩元素站 8 位（默认）</td><td style="text-align:left">4B</td></tr><tr><td style="text-align:left">RGB_565</td><td style="text-align:left">R 为 5 位，G 为 6 位，B 为 5 位共 16 位，没有Alpha</td><td style="text-align:left">2B</td></tr></tbody></table><ul><li>对象引用类型</li></ul><ol><li>强引用（Strong Reference）:JVM宁愿抛出OOM，也不会让GC回收的对象 </li><li>软引用（Soft Reference） ：只有内存不足时，才会被GC回收。 </li><li>弱引用（weak Reference）：在GC时，一旦发现弱引用，立即回收 </li><li>虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。 可以用来作为 GC 回收 Object 的标志。 </li></ol><ul><li>缓存池</li></ul><p>对象池：如果某个对象在创建时，需要较大的资源开销，那么可以将其放入对象池，即将对象保存起来，下次需要时直接取出使用，而不用再次创建对象。当然，维护对象池也需要一定开销，故要衡量。</p><p>线程池：与对象池差不多，将线程对象放在池中供反复使用，减少反复创建线程的开销。</p><h2 id="内存泄露相关优化"><a href="#内存泄露相关优化" class="headerlink" title="内存泄露相关优化"></a>内存泄露相关优化</h2><p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p><ul><li>单例造成的内存泄漏</li></ul><p>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。</p><p>如下这个典例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context，所以这个 Context 的生命周期的长短至关重要：</p><ol><li>传入的是 Application 的 Context：这将没有任何问题，因为单例的生命周期和 Application 的一样长。</li><li>传入的是 Activity 的 Context：当这个 Context 所对应的 Activity 退出时，由于该 Context 和 Activity 的生命周期一样长（Activity 间接继承于 Context），所以当前 Activity 退出时它的内存并不会被回收，因为单例对象持有该 Activity 的引用。</li></ol><p>所以正确的单例应该修改为下面这种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不管传入什么 Context 最终将使用 Application 的 Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏。</p><ul><li>非静态内部类创建静态实例造成的内存泄漏</li></ul><p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mResource == <span class="keyword">null</span>)&#123;</span><br><span class="line">            mResource = <span class="keyword">new</span> TestResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。</p><p>正确的做法为：</p><p>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用 Context，请使用 ApplicationContext。</p><ul><li>Handler 造成的内存泄漏</li></ul><p>Handler 的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等 api 都应该会借助 Handler 来处理，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏，如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种创建 Handler 的方式会造成内存泄漏，由于 mHandler 是 Handler 的非静态匿名内部类的实例，所以它持有外部类 Activity 的引用，我们知道消息队列是在一个 Looper 线程中不断轮询处理消息，那么当这个 Activity 退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的 Message 持有 mHandler 实例的引用，mHandler 又持有 Activity 的引用，所以导致该 Activity 的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        reference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">            activity.mTextView.setText(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个静态 Handler 内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，这样虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列中的消息，更准确的做法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        reference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">            activity.mTextView.setText(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 mHandler.removeCallbacksAndMessages(null); 是移除消息队列中所有消息和所有的 Runnable。 当然也可以使用 mHandler.removeCallbacks(); 或 mHandler.removeMessages(); 来移除指定的 Runnable 和 Message。</p><ul><li>线程造成的内存泄漏</li></ul><p>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和 Runnable 都是一个匿名内部类，因此它们对当前 Activity 都有一个隐式引用。 如果 Activity 在销毁之前，任务还未完成，那么将导致 Activity 的内存资源无法回收，造成内存泄漏。 正确的做法还是使用静态内部类的方式，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPostExecute(aVoid);</span><br><span class="line">        MainActivity activity = (MainActivity) weakReference.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line"><span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();</span><br></pre></td></tr></table></figure><p>这样就避免了 Activity 的内存资源泄漏，当然在 Activity 销毁时候也应该取消相应的任务 AsyncTask::cancel()，避免任务在后台执行浪费资源。</p><ul><li>资源使用完未关闭</li></ul><p>BraodcastReceiver，ContentObserver，FileObserver，Cursor，Callback等在 Activity onDestroy 或者某类生命周期结束之后一定要 unregister 或者 close 掉，否则这个 Activity 类会被 system 强引用，不会被内存回收。</p><p>不要直接对 Activity 进行直接引用作为成员变量，如果不得不这么做，请用 private WeakReference mActivity 来做，相同的，对于Service 等其他有自己声明周期的对象来说，直接引用都需要谨慎考虑是否会存在内存泄露的可能。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul><li>常用数据结构优化</li></ul><ol><li>ArrayMap 及 SparseArray 是 android 的系统 API，是专门为移动设备而定制的。 用于在一定情况下取代 HashMap 而达到节省内存的目的。 对于 key 为 int 的 HashMap 尽量使用 SparceArray 替代，大概可以省 30% 的内存，而对于其他类型，ArrayMap 对内存的节省实际并不明显，10% 左右，但是数据量在 1000 以上时，查找速度可能会变慢。</li><li>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用 StringBuilder 来替代频繁的 “+”。</li></ol><ul><li>枚举</li></ul><p>Android 平台上枚举是比较争议的，在较早的 Android 版本，使用枚举会导致包过大，使用枚举甚至比直接使用 int 包的 size 大了 10 多倍。 在 stackoverflow 上也有很多的讨论, 大致意思是随着虚拟机的优化，目前枚举变量在 Android 平台性能问题已经不大，而目前 Android 官方建议，使用枚举变量还是需要谨慎，因为枚举变量可能比直接用 int 多使用 2 倍的内存。</p><ul><li>View 复用</li></ul><ol><li>使用 ListView 时 getView 里尽量复用 conertView，同时因为 getView 会频繁调用，要避免频繁地生成对象。 优先考虑使用 RecyclerView 代替 ListView。</li><li>重复的布局优先使用 <include>，使用 <merge> 减少 view 的层级，对于可以延迟初始化的页面，使用 <viewstub>。</viewstub></merge></include></li></ol><ul><li>谨慎使用多进程</li></ul><p>现在很多 App 都不是单进程，为了保活，或者提高稳定性都会进行一些进程拆分，而实际上即使是空进程也会占用内存(1M 左右)，对于使用完的进程，服务都要及时进行回收。</p><ul><li>系统资源</li></ul><p>尽量使用系统组件，图片甚至控件的 id。 例如：@android:color/xxx，@android:style/xxx。</p><h2 id="使用工具检查内存泄漏"><a href="#使用工具检查内存泄漏" class="headerlink" title="使用工具检查内存泄漏"></a>使用工具检查内存泄漏</h2><p>即使在编码时将上述情况都考虑了，往往会有疏忽的地方，更何况通常情况下是团队开发。 所以不仅仅要在编码时考虑内存优化的情况，当出现内存泄漏时，更有效更准确的定位问题才是最重要的方式。 内存泄漏不像 bug，排查起来相对复杂一些，下面介绍下常用的检查方式。</p><h2 id="使用-Lint-代码静态检查"><a href="#使用-Lint-代码静态检查" class="headerlink" title="使用 Lint 代码静态检查"></a>使用 Lint 代码静态检查</h2><p>Lint 是 Android Studio 自带的工具，使用很简单找到 <strong>Analyze</strong> -&gt; <strong>Inspect Code</strong> 然后选择想要扫面的区域即可。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_lint1.jpg?raw=true?raw=true" alt="memory_lint1"></p><p>选择 Lint 扫描区域。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_lint2.jpg?raw=true" alt="memory_lint2"></p><p>对可能引起性能问题的代码，Lint 都会进行提示。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_lint3.jpg?raw=true" alt="memory_lint3"></p><h2 id="使用-Android-Studio-自带的-Monitor-Memory-检查"><a href="#使用-Android-Studio-自带的-Monitor-Memory-检查" class="headerlink" title="使用 Android Studio 自带的 Monitor Memory 检查"></a>使用 Android Studio 自带的 Monitor Memory 检查</h2><p>一般在 Android Studio 的底部可以找到 Android Monitor。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_ast_1.jpg?raw=true" alt="Monitor Memory 1"></p><p>可以看到当前 App的内存变动比较大，很有可能出现了内存泄漏。 点击 Dump Java Heap，等一段时间会自动生成 Heap Snapshot 文件。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_ast_2.jpg?raw=true" alt="Monitor Memory 2"></p><p>在 Captures 中可以找到 hprof 文件。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_ast_3.jpg?raw=true" alt="Monitor Memory 3"></p><p>在右侧找到 Analyzer Tasks 并打开，点击图中 Perform Analysis 按钮开始分析。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_ast_4.jpg?raw=true" alt="Monitor Memory 4"></p><p>通过分析结果可以看到 TestActivity 泄漏了，从左侧 Reference Tree 中可以看到是 TestActivity 中的 context 泄露了。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_ast_5.jpg?raw=true" alt="Monitor Memory 5"></p><p>我们来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context context;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test);</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中 context 为静态的引用了当前 Activity 造成了当前 Activity 无法释放。</p><p>一般的通过 使用 Android Studio 自带的 Monitor Memory 可以定位到内存泄漏所在的类，更详细的信息需要借助 Memory Analyzer Tool（MAT）工具。</p><h2 id="使用-Memory-Analyzer-Tool-检查"><a href="#使用-Memory-Analyzer-Tool-检查" class="headerlink" title="使用 Memory Analyzer Tool 检查"></a>使用 Memory Analyzer Tool 检查</h2><p>首先下载 Memory Analyzer Tool <a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载地址</a></p><p>在 Android Studio 中先将 hprof 文件导出为 MAT 可以识别的 hprof 文件。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat1.jpg?raw=true" alt="MAT1"></p><p>打开刚才导出的文件。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat2.jpg?raw=true" alt="MAT2"></p><p>经过分析后会显示如下，Leak Suspectss 是一个关于内存泄露猜想的饼图，Problem Suspect 1 是泄露猜想的描述。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat3.jpg?raw=true" alt="MAT3"></p><p>Overview 是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在 Inspector 栏目显示这块区域的相关信息。 MAT 从多角度提供了内存分析，其中包括 Histogram、 Dominator Tree、 Leak Suspects 和 Top consumers 等。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat4.jpg?raw=true" alt="MAT4"></p><p>这里我们使用 Histogram 进行分析，切换到 Histogram 页面。 这个页面主要有 4 个列，Class Name、 Objects、 Shallow Heap 和 Retained Heap。 其中 Class Name 是全类名，Objects 是这个类的对象实例个数。 Shallow Heap 是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。 Retained Heap 指当前对象大小和当前对象能直接或间接引用的对象大小的总和，这个栏目是分析重点。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat5.jpg?raw=true" alt="MAT5"></p><p>内存分析是分析的整个系统的内存泄露，而我们只要查找我们 App 的内存泄露情况。 这无疑增加了很多工作，不过幸亏 Histogram 支持正则表达式查找，在 Regex 中输入我们的包名进行过滤，直奔和我们 App 有关的内存泄露。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat6.jpg?raw=true" alt="MAT6"></p><p>过滤后就显示了我们 App 相关内存信息，按 Retained Heap 大小排列下，发现 MainActivity 和 TestActivity 这两个类问题比较大。 TestActivity 的问题更突出些，所以先从 TestActivity 下手。</p><p>首先看下是哪里的引用导致了 TestActivity 不能被 GC 回收。 右键使用 <strong>Merge Shortest Paths to GC Roots</strong> 显示距 GC Root 最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat7.jpg?raw=true" alt="MAT7"></p><p>进入结果页查看。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_mat8.jpg?raw=true" alt="MAT8"></p><p>可以看到 TestActivity 不能被 GC 回收是因为 context 没有释放的原因。 我们再来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context context;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test);</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-LeakCanary-检查"><a href="#使用-LeakCanary-检查" class="headerlink" title="使用 LeakCanary 检查"></a>使用 LeakCanary 检查</h2><p>项目地址：<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a></p><p>使用方式很简单，参考项目里面的介绍即可。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/memory_leak_test.jpg?raw=true" alt="LeakCanary"></p><h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><ul><li>什么是 ANR</li></ul><ol><li>ANR:Application Not Responding，即应用无响应。</li><li>为用户在主线程长时间被阻塞是提供交互，提高用户体验。</li><li>Android 系统自身的一种检测机制。</li></ol><ul><li>ANR 的类型</li></ul><p>ANR 一般有三种类型：</p><ol><li>KeyDispatchTimeout(5 seconds) : 主要类型按键或触摸事件在特定时间内无响应</li><li>BroadcastTimeout(10 seconds) : BroadcastReceiver 在特定时间内无法处理完成</li><li>ServiceTimeout(20 seconds) : 小概率类型 Service 在特定的时间内无法处理完成</li></ol><ul><li>ANR 产生的原因</li></ul><p>超时时间的计数一般是从按键分发给 app 开始。 超时的原因一般有两种：</p><ol><li>当前的事件没有机会得到处理（即 UI 线程正在处理前一个事件，没有及时的完成或者 looper 被某种原因阻塞住了）</li><li>当前的事件正在处理，但没有及时完成。</li></ol><ul><li>ANR 出现流程分析</li></ul><ol><li>输入时间响应超时导致ANR流程</li></ol><p>在系统输入管理服务进程（InputManagerService）中有一个线程（InputDispathcerThread）专门管理输入事件的分发，在该线程处理输入事件的过程中，回调用 InputDispatcher 对象方法不断的检测处理过程是否超时，一旦超时，则会通过一些列的回调调用 InputMethod 对象的 notifyANR 方法，其会最终出发 AMS 中 handler 对象的 SHOW_NOT_RESPONDING_MSG 这个事件，显示ANR对话框。</p><ol start="2"><li>广播发生ANR流程</li></ol><p>广播分为三类：普通的，有序的，异步的。 只有有序（ordered）的广播才会发生超时，而在 AndroidManifest 中注册的广播都会被当做有序广播来处理，会被放在广播的队列中串行处理。 AMS 在处理广播队列时，会设置一个超时时间，当处理一个广播达到超时时间的限制时，就会触发 BroadcastQueue 类对象的 processNextBroadcast 方法来判断是否超时，如果超时，就会终止该广播，触发ANR对话框。</p><ol start="3"><li>UI线程</li></ol><p>UI 线程主要包括如下：</p><p>Activity : onCreate(), onResume(), onDestroy(), onKeyDown(), onClick(), etc 生命周期方法里。<br>AsyncTask : onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel, etc 这些异步更改 UI 界面的方法里。<br>Mainthread handler : handleMessage(), post*(runnable r), getMainLooper(), etc 通过 handler 发送消息到主线程的 looper，即占用主线程 looper 的。</p><ul><li>ANR 执行流程</li></ul><p>了解 ANR 执行流程有利于我们制定 ANR 监控策略和获取 ANR 的相关信息，ANR 的执行步骤如下：</p><ol><li>系统捕获到 ANR 发生；</li><li>Process 依次向本进程及其他正在运行的进程发送 Linux 信号量 3；</li><li>进程接收到 Linux 信号量，并向 /data/anr/traces.txt 中写入进程信息；</li><li>Log 日志打印 ANR 信息；</li><li>进程进入 ANR 状态（此时可以获取到进程 ANR 信息);</li><li>弹出 ANR 提示框；</li><li>提示框消失，进程回归正常状态。</li></ol><p>由于向 /data/anr/traces.txt 文件中写入信息耗时较长，从 Input ANR 触发到弹出 ANR 提示框一般在 10s 左右（不同 rom 时间不同）。</p><ul><li>发生 ANR 如何定位</li></ul><p>当 App 的进程发生 ANR 时，系统让活跃的 Top 进程都进行了一下 dump，进程中的各种 Thread 就都 dump 到这个 trace 文件里了，所以 trace 文件中包含了每一条线程的运行时状态。 traces.txt 的文件放在 /data/anr/ 下. 可以通过 adb 命令将其导出到本地:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb pull data/anr/traces.txt .</span><br></pre></td></tr></table></figure><p>通过分析 traces.txt 文件，查找 App 包名关键信息来定位 ANR。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/" target="_blank" rel="noopener">Android Bitmap的内存大小是如何计算的？</a></li><li><a href="http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏/" target="_blank" rel="noopener">Android性能优化之常见的内存泄漏</a></li><li><a href="http://www.jianshu.com/p/216b03c22bb8" target="_blank" rel="noopener">使用新版Android Studio检测内存泄露和性能</a></li><li><a href="https://www.diycode.cc/topics/475" target="_blank" rel="noopener">Android 应用内存泄漏的定位、分析与解决策略</a></li><li><a href="http://rayleeya.iteye.com/blog/1955657" target="_blank" rel="noopener">Android 系统稳定性 - ANR</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 内存优化 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - 性能优化 UI优化</title>
      <link href="/2017/10/01/android-performance-optimization-ui/"/>
      <url>/2017/10/01/android-performance-optimization-ui/</url>
      <content type="html"><![CDATA[<h1 id="Android-性能优化-UI优化"><a href="#Android-性能优化-UI优化" class="headerlink" title="Android - 性能优化 UI优化"></a>Android - 性能优化 UI优化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android 应用的卡顿，丢帧等，这些影响用户体验的因素绝大部分都与 16ms 这个值有关。 下面我们来讨论下 UI 渲染方面影响应用流畅性的因素。</p><h2 id="16ms"><a href="#16ms" class="headerlink" title="16ms"></a>16ms</h2><ul><li>12 fps（帧/秒）：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约 10-12 fps 的时候，就会认为是连贯的。 早期的无声电影的帧率介于 16-24 fps 之间，虽然帧率足以让人感觉到运动，但往往被认为是在快放幻灯片。 在1920年代中后期，无声电影的帧率提高到 20-26 fps 之间。</li><li>24 fps：1926 年有声电影推出，人耳对音频的变化更敏感，反而削弱了人对电影帧率的关注。因为许多无声电影使用 20-26 fps 播放，所以选择了中间值 24 fps 作为有声电影的帧率。 之后 24 fps 成为35mm有声电影的标准。</li><li>30 fps：早期的高动态电子游戏，帧率少于每秒 30 fps 的话就会显得不连贯。这是因为没有动态模糊使流畅度降低。 （注:如果需要了解动态模糊技术相关知识，可以查阅 <a href="https://www.zhihu.com/question/21081976" target="_blank" rel="noopener">这里</a>）</li><li>60 fps：在实际体验中，60 fps 相对于30 fps 有着更好的体验。</li><li>85 fps：一般而言，大脑处理视频的极限。</li></ul><p>所以，总体而言，帧率越高体验越好。 一般的电影拍摄及播放帧率均为每秒 24 帧，但是据称《霍比特人：意外旅程》是第一部以每秒 48 帧拍摄及播放的电影，观众认为其逼真度得到了显著的提示。</p><p>目前，大多数显示器根据其设定按 30Hz、 60Hz、 120Hz 或者 144Hz 的频率进行刷新。 而其中最常见的刷新频率是 60Hz。 这样做是为了继承以前电视机刷新频率为 60Hz 的设定。 而 60Hz 是美国交流电的频率，电视机如果匹配交流电的刷新频率就可以有效的预防屏幕中出现滚动条，即互调失真。</p><p>正如上面所述目前大多数显示器的刷新率是 60Hz，Android 设备的刷新率也是 60Hz。只有当画面达到 60fps 时 App 应用才不会让用户感觉到卡顿。那么 60fps 也就意味着 1000ms/60Hz = 16ms。也就是说 16ms 渲染一次画面才不会卡顿。</p><h2 id="V-Sync（垂直同步）"><a href="#V-Sync（垂直同步）" class="headerlink" title="V-Sync（垂直同步）"></a>V-Sync（垂直同步）</h2><p>玩游戏的同学，尤其是大型 FPS 游戏应该都见过“垂直同步”这个选项。因为 GPU 的生成图像的频率与显示器的刷新频率是相互独立的，所以就涉及到了一个配合的问题。</p><p>最理想的情况是两者之间的频率是相同且协同进行工作的，在这样的理想条件下，达到了最优解。但实际中 GPU 的生成图像的频率是变化的，如果没有有效的技术手段进行保证，两者之间很容易出现这样的情况：当 GPU 还在渲染下一帧图像时，显示器却已经开始进行绘制，这样就会导致屏幕撕裂（Tear）。这会使得屏幕的一部分显示的是前一帧的内容，而另一部分却在显示下一帧的内容。如下图所示：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tearing_simulated.jpg" alt="撕裂的图像"></p><p>屏幕撕裂（Tear）的问题，早在 PC 游戏时代就被发现， 并不停的在尝试进行解决。 其中最知名可能也是最古老的解决方案就是 V-Sync 技术。</p><p>V-Sync 的原理简单而直观：产生屏幕撕裂的原因是 GPU 在屏幕刷新时进行了渲染，而 V-Sync 通过同步渲染/刷新时间的方式来解决这个问题。显示器的刷新频率为 60Hz，若此时开启 V-Sync，将控制 GPU 渲染速度在 60Hz 以内以匹配显示器刷新频率。这也意味着，在 V-Sync 的限制下，GPU 显示性能的极限就限制为 60Hz 以内。这样就能很好的避免图像撕裂的问题。</p><h2 id="Android-中的-GPU-渲染机制"><a href="#Android-中的-GPU-渲染机制" class="headerlink" title="Android 中的 GPU 渲染机制"></a>Android 中的 GPU 渲染机制</h2><p>大多数的 App 界面卡顿（Jank）现象都与 GPU 渲染有关，尤其是存在多层次布局嵌套，存在不必要的绘制，或者在 onDraw() 方法中执行了耗时操作，动画执行次数过多的情况下很容易出现界面卡顿。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_draw_per_16ms.png?raw=true" alt="16ms"></p><p>如上图所示，Android 系统每隔 16ms 就会发出一个 V-Sync 信号，触发对 UI 的渲染，如果每次渲染都能成功，这样就能保证画面的流畅帧率 60fps。 如果出现 16ms 内无法渲染的情况就无法响应 V-Sync 信号，就会出现丢帧现象。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_vsync_over_draw.png?raw=true" alt="vsync over draw"></p><p>如上图所示：如果某个操作耗时 24ms，系统就无法正常响应当前 V-Sync 信号，只能等待下次响应 V-Sync 信号，当前 V-Sync 信号就会丢失，也就是所谓丢帧。</p><h2 id="Overdraw-过度绘制"><a href="#Overdraw-过度绘制" class="headerlink" title="Overdraw 过度绘制"></a>Overdraw 过度绘制</h2><h3 id="什么是过度绘制？"><a href="#什么是过度绘制？" class="headerlink" title="什么是过度绘制？"></a>什么是过度绘制？</h3><p>过度绘制就是屏幕上的某个像素在同一帧的时间内被绘制了多次。 在多层次的UI结构里面，如果不可见的 UI 也在做绘制的操作，这就会导致某些像素区域被绘制了多次。 这就浪费大量的 CPU 以及 GPU 资源。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_overdraw_1.jpg?raw=true" alt="overdraw options draw"></p><h3 id="如何发现过度绘制？"><a href="#如何发现过度绘制？" class="headerlink" title="如何发现过度绘制？"></a>如何发现过度绘制？</h3><p>我们可以通过手机设置里面的 <strong>开发者选项</strong> ，打开 <strong>显示过渡绘制区域（Show GPU Overdraw</strong> 的选项，可以观察 UI 上的 Overdraw 情况。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_overdraw_options_view.png?raw=true" alt="overdraw options draw"></p><p>蓝色，淡绿，淡红，深红代表了 4 种不同程度的 Overdraw 情况，我们的目标就是尽量减少红色 Overdraw，看到更多的蓝色区域。</p><ul><li>蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。 </li><li>绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。 </li><li>淡红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。 </li><li>深红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。 </li></ul><p>Overdraw 有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。</p><blockquote><p>例如：某个 Activity 有一个背景，然后里面的 Layout 又有自己的背景，同时子 View 又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色 Overdraw 区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。</p></blockquote><h2 id="使用-Hierarchy-Viewer-分析-UI-性能"><a href="#使用-Hierarchy-Viewer-分析-UI-性能" class="headerlink" title="使用 Hierarchy Viewer 分析 UI 性能"></a>使用 Hierarchy Viewer 分析 UI 性能</h2><p>首先打开 Hierarchy Viewer，依次找到：Android Studio -&gt; Tools -&gt; Android -&gt; Android Device Monitor</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_android_device_monitor.jpg?raw=true" alt="Android Device Monitor"></p><p>启动 Android Device Monitor 成功之后，在新的窗口中点击切换视图图标，选择 Hierarchy View，如下图：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_hierarchy_view.jpg?raw=true" alt="hierarchy view"></p><p>Hierarchy View 运行界面如下：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_hierarchy_view_2.jpg?raw=true" alt="hierarchy view"></p><ul><li>一个 Activity 的 View 树，通过这个树可以分析出 View 嵌套的冗余层级；</li><li>左下角可以输入 View 的 id 直接自动跳转到中间显示；</li><li>Save as PNG 用来把左侧树保存为一张图片；</li><li>Capture Layers 用来保存 psd 的 PhotoShop 分层素材；</li><li>右侧剧中显示选中 View 的当前属性状态；</li><li>右下角显示当前 View 在 Activity 中的位置等；</li><li>Load View Hierarchy 用来手动刷新变化（不会自动刷新的）。</li></ul><p>当我们选择一个 View 后会如下图所示：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_hierarchy_view_3.jpg?raw=true" alt="hierarchy view"></p><p>类似上图可以很方便的查看到当前 View 的许多信息，上图最底那三个彩色原点代表了当前 View 的性能指标，从左到右依次代表测量、布局、绘制的渲染时间，红色和黄色的点代表速度渲染较慢的 View（当然了，有些时候较慢不代表有问题，比如 ViewGroup 子节点越多、结构越复杂，性能就越差）。</p><p>当然了，在自定义 View 的性能调试时，HierarchyViewer 上面的 invalidate Layout 和 requestLayout 按钮的功能更加强大，它可以帮助我们 debug 自定义 View 执行 invalidate() 和 requestLayout() 过程，我们只需要在代码的相关地方打上断点就行了，接下来通过它观察绘制即可。</p><p>可以发现，有了 Hierarchy View 调试工具，我们的 UI 性能分析变得十分容易，这个工具也是我们开发中调试 UI 的利器，在平时写代码时会时常伴随我们左右。</p><h2 id="使用-GPU-呈现模式考核-UI-性能"><a href="#使用-GPU-呈现模式考核-UI-性能" class="headerlink" title="使用 GPU 呈现模式考核 UI 性能"></a>使用 GPU 呈现模式考核 UI 性能</h2><p>在 Android 手机上开启这个功能：打开 <strong>开发者选项</strong> -&gt; <strong>GPU 呈现模式分析（Peofile GPU Rendering tool</strong> -&gt; <strong>在屏幕上显示为条形图（On screen as bars</strong></p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_gpu_16ms.jpg?raw=true" alt="gpu 16ms"></p><p>在 Android 系统中是以 60fps 为满帧，绿色横线为 16ms 分界线，低于绿线即为流畅。</p><p>屏幕下方的柱状图每一根代表一帧，其高度表示“渲染这一帧耗时”，随着手机屏幕界面的变化，柱状图会持续刷新每帧用时的具体情况（通过高度表示）。那么，当柱状图高于绿线，是不是就说明我卡了呢？其实这不完全正确，这里就要开始分析组成每一根柱状图不同颜色所代表的含义了。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_gpu_16ms2.jpg?raw=true" alt="gpu 16ms"></p><ul><li><p><strong>红色</strong>，代表了“执行时间”，它指的是 Android 渲染引擎执行盒子中这些绘制命令的时间，假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如我们平时刷淘宝 App 时遇到出现多张缩略图需要加载时，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但其实这可能并不意味着你卡住了。</p></li><li><p><strong>黄色</strong>，通常较短，它代表着 CPU 通知 GPU “你已经完成视图渲染了”，不过在这里 CPU 会等待 GPU 的回话，当 GPU 说“好的知道了”，才算完事儿。 假如橙色部分很高的话，说明当前 GPU 过于忙碌，有很多命令需要去处理，比如 Android 淘宝客户端，红色黄色通常会很高。</p></li><li><p><strong>蓝色</strong>，假如想通过玄学曲线来判断流畅度的话，其实蓝色的参考意义是较大的。蓝色代表了视图绘制所花费的时间，表示视图在界面发生变化（更新）的用时情况。当它越短时，即便是体验上更接近“丝滑”，当他越长时，说明当前视图较复杂或者无效需要重绘，即我们通常说的“卡了”。</p></li></ul><p>理解了玄学曲线不同颜色代表的意义，看懂玄学曲线就不难了。 一般情况下，当蓝色低于绿线时都不会出现卡顿，但是想要追求真正的丝般顺滑那当然还是三色全部处于绿线以下最为理想。</p><h2 id="使用-TraceView-从代码层面分析性能问题"><a href="#使用-TraceView-从代码层面分析性能问题" class="headerlink" title="使用 TraceView 从代码层面分析性能问题"></a>使用 TraceView 从代码层面分析性能问题</h2><p>生成 trace 文件有三种方法：</p><ol><li>使用代码</li><li>使用 Android Studio</li><li>使用 DDMS</li></ol><h2 id="1-使用代码生成-trace-文件"><a href="#1-使用代码生成-trace-文件" class="headerlink" title="1. 使用代码生成 trace 文件"></a>1. 使用代码生成 trace 文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(<span class="string">"test_trace"</span>);<span class="comment">//开始 trace，保存文件到 "/sdcard/test_trace.trace"</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Debug.stopMethodTracing();<span class="comment">//结束</span></span><br></pre></td></tr></table></figure><p>代码很简单，当你调用开始代码的时候，系统会生产 trace 文件，并且产生追踪数据，当你调用结束代码时，会将追踪数据写入到 trace 文件中。</p><p>下一步使用 adb 命令将 trace 文件导出到电脑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/test_trace.trace /tmp</span><br></pre></td></tr></table></figure><p>使用代码生成 trace 方式的好处是容易控制追踪的开始和结束，缺点就是步骤稍微多了一点。</p><h2 id="2-使用-Android-Studio-生成-trace-文件"><a href="#2-使用-Android-Studio-生成-trace-文件" class="headerlink" title="2. 使用 Android Studio 生成 trace 文件"></a>2. 使用 Android Studio 生成 trace 文件</h2><p>Android Studio 内置的 Android Monitor 可以很方便的生成 trace 文件到电脑。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing.jpg?raw=true" alt="android studio tracing"></p><p>在 CPU 监控的那栏会有一个闹钟似的的按钮，未启动应用时是灰色；<br>启动应用后，这个按钮会变亮，点击后开始追踪，相当于代码调用 startMethodTracing；</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing2.jpg?raw=true" alt="android studio tracing"></p><p>当要结束追踪时再次点击这个按钮，就会生成 trace 文件了（文件可在 Caputures 中找到）。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing4.jpg?raw=true" alt="android studio tracing"></p><p>生成 trace 后 Android Studio 自动加载的 traceview 图形如下：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing3.jpg?raw=true" alt="android studio tracing"></p><p>从这个图可以大概了解一些方法的执行时间、次数以及调用关系，也可以搜索过滤特定的内容。</p><p>左上角可以切换不同的线程，这其实也是直接用 Android Studio 查看 trace 文件的缺点：无法直观地对比不同线程的执行时间。</p><p>鼠标悬浮到黄色的矩形上，会显示对应方法的开始、结束时间，以及自己占用和调用其他方法占用的时间比例：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing5.jpg?raw=true" alt="android studio tracing"></p><h2 id="3-使用-DDMS-生成-trace-文件"><a href="#3-使用-DDMS-生成-trace-文件" class="headerlink" title="3. 使用 DDMS 生成 trace 文件"></a>3. 使用 DDMS 生成 trace 文件</h2><p>DDMS 即 Dalvik Debug Monitor Server ，是 Android 调试监控工具，它为我们提供了截图，查看 log，查看视图层级，查看内存使用等功能，可以说是如今 Android Studio 中内置的 Android Monitor 的前身。</p><p>打开 Android Device Monitor，找到 Device 选中需要测试的 app，点击 Start Method Profiling 后开始追踪，相当于代码调用 startMethodTracing；</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing6.jpg?raw=true" alt="android studio tracing"></p><p>当要结束追踪时再次点击这个按钮，就会生成 trace 文件；</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing7.jpg?raw=true" alt="android studio tracing"></p><p>停止追踪后，DDMS 会启动 TraceView 加载 trace 文件：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing8.jpg?raw=true" alt="android studio tracing"></p><p>上图介绍了 TraceView 的大致内容</p><p>面板列名含义如下:</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Incl Cpu Time</td><td style="text-align:left">CPU 执行该方法该方法及其子方法所花费的时间</td></tr><tr><td style="text-align:left">Incl Cpu Time %</td><td style="text-align:left">CPU 执行该方法该方法及其子方法所花费占 CPU 总执行时间的百分比</td></tr><tr><td style="text-align:left">Excl Cpu Time</td><td style="text-align:left">CPU 执行该方法所花费的时间</td></tr><tr><td style="text-align:left">Excl Cpu Time %</td><td style="text-align:left">CPU 执行该方法所花费的时间占Cpu总时间的百分比</td></tr><tr><td style="text-align:left">Incl Real Time</td><td style="text-align:left">该方法及其子方法执行所花费的实际时间，从执行该方法到结束一共花了多少时间</td></tr><tr><td style="text-align:left">Incl Real Time %</td><td style="text-align:left">上述时间占总的运行时间的百分比</td></tr><tr><td style="text-align:left">Excl Real Time</td><td style="text-align:left">该方法自身的实际允许时间</td></tr><tr><td style="text-align:left">Excl Real Time %</td><td style="text-align:left">上述时间占总的允许时间的百分比</td></tr><tr><td style="text-align:left">Calls+Recur</td><td style="text-align:left">调用次数+递归次数，只在方法中显示，在子展开后的父类和子类方法这一栏被下面的数据代替</td></tr><tr><td style="text-align:left">Calls/Total</td><td style="text-align:left">调用次数和总次数的占比</td></tr><tr><td style="text-align:left">Cpu Time/Call</td><td style="text-align:left">CPU 执行时间和调用次数的百分比，代表该函数消耗 CPU 的平均时间</td></tr><tr><td style="text-align:left">Real Time/Call</td><td style="text-align:left">实际时间于调用次数的百分比，该表该函数平均执行时间</td></tr></tbody></table><p>点击下面的任意一个方法，可以看到它的详细信息：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_tracing9.jpg?raw=true" alt="android studio tracing"></p><ul><li>Parents：选中方法的调用处</li><li>Children：选中方法调用的方法</li></ul><h2 id="使用-Systrace-检测-App-的性能"><a href="#使用-Systrace-检测-App-的性能" class="headerlink" title="使用 Systrace 检测 App 的性能"></a>使用 Systrace 检测 App 的性能</h2><p>经过在上面的这些优化之后，如果你的界面还有卡顿，我们还有办法。 Systrace 工具也可以测量你 App 的性能。 甚至可以帮助你定位问题产生的位置。 这个工具是作为“Project Butter”一部分同 Jelly Bean 一同发布的，它能够从内核级检测你设备的运行状态。 Systrace 可配置的参数很多。我们这里重点关注 UI 是怎么渲染的，用 Systrace 检测卡顿问题。</p><p>Systrace 和之前的工具不同的是，它记录的是整个 Android 系统的状态，并不是针对某一个 App 的。所以最好是用运行 App 比较少的设备来做检测，这样就不会受到其他 App 的干扰了。 </p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_systrace.jpg?raw=true" alt="android studio systrace"></p><p>点击开始按钮会弹出窗口选择所需要的参数，这里主要研究屏幕的交互数据，主要收集 CPU，graphics 和 view 数据。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_systrace2.jpg?raw=true" alt="android studio systrace"></p><p>trace 数据记录在一个 html 文件里，可以用浏览器打开。 点击OK之后，Systrace 会马上开始采集设备上的数据（最好马上开始操作）。 因为采集的数据非常之多，所以最好一次只针对一个问题。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_systrace3.jpg?raw=true" alt="android studio systrace"></p><p>鼠标可以控制滑动，WASD 可以用来 zoom in/out（W，S）和左右滑动（A，D）。在刚跑的 trace 数据最上面，能看到 CPU 的详细数据， CPU 数据的下面是几个可折叠的区域，分别表示不同的活跃进程。每一个色条表示系统的一个行为，色条的长度表示该行为的耗时（放大可以看到更多细节）。</p><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">w</td><td style="text-align:left">放大</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">缩小</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">左移</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">右移</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">返回选中区域，且放大选中区域</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">标记当前选定区域</td></tr><tr><td style="text-align:left">v</td><td style="text-align:left">高亮 VSync</td></tr><tr><td style="text-align:left">g</td><td style="text-align:left">切换是否显示 60hz 的网格线</td></tr><tr><td style="text-align:left">0(零)</td><td style="text-align:left">恢复trace到初始态</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">切换是否显示详情</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">搜索关键字</td></tr><tr><td style="text-align:left">enter</td><td style="text-align:left">显示搜索结果，可通过← →定位搜索结果</td></tr><tr><td style="text-align:left">`</td><td style="text-align:left">显示/隐藏脚本控制台</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">显示帮助功能</td></tr></tbody></table><p>Alerts 一栏标记了以下性能有问题的点，你可以点击该点查看详细信息,右边侧边栏还有一个 Alerts 框，点击可以查看每个类型的 Alerts 的数量。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_systrace5.jpg?raw=true" alt="android studio systrace"></p><p>在每个包下都有 Frame 一栏，该栏中都有一个一个的 F 代表每一个 Frame，用颜色来代表性能的好坏，依次为绿-黄-红(性能越来越差),点击某一个 F,会显示该 Frame 绘制过程中的一些 Alerts 信息，如果你想查看Frame的耗时，可以点击某个 F 标志，然后按 m 键:。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_performance/ui_systrace4.jpg?raw=true" alt="android studio systrace"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.jianshu.com/p/71cba1711de0" target="_blank" rel="noopener">脑洞大开：为啥帧率达到 60 fps 就流畅？</a></li><li><a href="http://hukai.me/android-performance-render/" target="_blank" rel="noopener">Android性能优化之渲染篇</a></li><li><a href="https://www.kancloud.cn/digest/itfootballprefermanc/100911" target="_blank" rel="noopener">Android性能专项测试-TraceView工具(Device Monitor)</a></li><li><a href="https://www.kancloud.cn/digest/itfootballprefermanc/100913" target="_blank" rel="noopener">Android性能专项测试-Systrace工具</a></li><li><a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="noopener">Analyzing UI Performance with Systrace</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> UI优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章看明白 Android 系统启动时都干了什么</title>
      <link href="/2017/09/09/android-bootloader/"/>
      <url>/2017/09/09/android-bootloader/</url>
      <content type="html"><![CDATA[<h1 id="Android-系统启动过程"><a href="#Android-系统启动过程" class="headerlink" title="Android - 系统启动过程"></a>Android - 系统启动过程</h1><h2 id="计算机是如何启动的？"><a href="#计算机是如何启动的？" class="headerlink" title="计算机是如何启动的？"></a>计算机是如何启动的？</h2><p>首先熟悉一些概念，计算机的硬件包括：CPU，内存，硬盘，显卡，显示器，键盘鼠标等其他输入输出设备。 所有的软件（比如：操作系统）都是存放在硬盘上，程序执行时需要将程序从硬盘上读取到内存中然后加载到 CPU 中来运行。 当我们按下开机键时，此时内存中什么都没有，因此需要借助某种方式，将操作系统加载到内存中，而完成这项任务的就是 BIOS。</p><ul><li>引导阶段</li></ul><p>BIOS: Basic Input/Output System（基本输入输出系统），在 IBM PC 兼容系统上，是一种业界标准的固件接口（来自维基百科）。 BIOS 一般是主板芯片上的一个程序，计算机通电后，第一件事就是读取它。</p><p>BIOS 程序首先检查计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为 POST。 如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。 如果没有问题，屏幕就会显示出 CPU，内存，硬盘等信息。</p><p>硬件自检完成后，BIOS 把控制权转交给下一阶段的启动程序。 这时 BIOS 需要知道，下一阶段的启动程序到底存放在哪一个设备当中。 也就是说 BIOS 需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。 这种排序叫做启动排序，也就是我们平时进入 BIOS 界面时能看到的 Boot Sequence。</p><p>如果我们没有进行特殊操作的话，那么 BIOS 就会按照这个启动顺序将控制权交给下一个存储设备。 我们在使用 U 盘光盘之类的装系统时就是在这里将启动顺序改变了，将本来要移交给硬盘的控制权交给了 U 盘或者光盘。</p><p>第一存储设备被激活后，计算机读取该设备的第一个扇区，也就是读取最前面的 512 个字节。 如果这 512 个字节的最后两个字节是 0x55 和 0xAA ，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给“启动顺序”中的下一个设备。</p><p>这最前面的 512 个字节，就叫做”主引导记录”（Master boot record，缩写为 MBR）。 主引导记录 MBR 是位于磁盘最前边的一段引导代码。它负责磁盘操作系统对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统在对硬盘进行初始化时产生的。 硬盘的主引导记录 MBR 是不属于任何一个操作系统的，它先于所有的操作系统而被调入内存，并发挥作用，然后才将控制权交给主分区内的操作系统，并用主分区信息表来管理硬盘。</p><p>MBR 只有512个字节，放不了太多东西。 它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。 我们找到可用的 MBR 后，计算机从 MBR 中读取前面 446 字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。</p><ul><li>加载内核阶段</li></ul><p>选择完操作系统后，控制权转交给操作系统，操作系统的内核首先被载入内存。</p><p>以 Linux 系统为例，先载入 /boot 目录下面的 kernel。 内核加载成功后，第一个运行的程序是 /sbin/init。 它根据配置文件（Debian 系统是 /etc/initab ）产生 init 进程。 这是 Linux 启动后的第一个进程，pid 进程编号为 1，其他进程都是它的后代。</p><p>然后，init 线程加载系统的各个模块，比如：窗口程序和网络程序，直至执行 /bin/login 程序，跳出登录界面，等待用户输入用户名和密码。</p><p>至此，全部启动过程完成。</p><h2 id="Android-手机的启动过程"><a href="#Android-手机的启动过程" class="headerlink" title="Android 手机的启动过程"></a>Android 手机的启动过程</h2><p>Android 系统虽然也是基于 Linux 系统的，但是由于 Android 属于嵌入式设备，并没有像 PC 那样的 BIOS 程序。 取而代之的是 Bootloader —— 系统启动加载器。 它类似于 BIOS，在系统加载前，用以初始化硬件设备，建立内存空间的映像图，为最终调用系统内核准备好环境。 在 Android 里没有硬盘，而是 ROM，它类似于硬盘存放操作系统，用户程序等。 ROM 跟硬盘一样也会划分为不同的区域，用于放置不同的程序，在 Android 中主要划分为一下几个分区：</p><ul><li>/boot：存放引导程序，包括内核和内存操作程序</li><li>/system：相当于电脑c盘，存放Android系统及系统应用</li><li>/recovery：恢复分区，可以进入该分区进行系统恢复</li><li>/data：用户数据区，包含了用户的数据：联系人、短信、设置、用户安装的程序</li><li>/cache：安卓系统缓存区，保存系统最常访问的数据和应用程序</li><li>/misc：包含一些杂项内容，如系统设置和系统功能启用禁用设置</li><li>/sdcard：用户自己的存储区，可以存放照片，音乐，视频等文件</li></ul><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/boot_image.png?raw=true" alt=""></p><p>那么 Bootloader 是如何被加载的呢？跟 PC 启动过程类似，当开机通电时首先会加载 Bootloader，Bootloader 会读取 ROM 找到操作系统并将 Linux 内核加载到 RAM 中。</p><p>当 Linux 内核启动后会初始化各种软硬件环境，加载驱动程序，挂载根文件系统，Linux 内核加载的最后阶段会启动执行第一个用户空间进程 init 进程。</p><h2 id="init-进程"><a href="#init-进程" class="headerlink" title="init 进程"></a>init 进程</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/android-booting.png?raw=true" alt=""></p><p>init 是 Linux 系统中用户空间的第一个进程(pid=1)，Kernel 启动后会调用 /system/core/init/Init.cpp 的 main() 方法。</p><ul><li>Init.main()</li></ul><p>首先初始化 Kernel log，创建一块共享的内存空间，加载 /default.prop 文件，解析 init.rc 文件。</p><h2 id="init-rc-文件"><a href="#init-rc-文件" class="headerlink" title="init.rc 文件"></a>init.rc 文件</h2><p>init.rc 文件是 Android 系统的重要配置文件，位于 /system/core/rootdir/ 目录中。 主要功能是定义了系统启动时需要执行的一系列 action 及执行特定动作、设置环境变量和属性和执行特定的 service。 </p><p>init.rc 脚本文件配置了一些重要的服务，init 进程通过创建子进程启动这些服务，这里创建的 service 都属于 native 服务，运行在 Linux 空间，通过 socket 向上层提供特定的服务，并以守护进程的方式运行在后台。</p><p>通过 init.rc 脚本系统启动了以下几个重要的服务：</p><ul><li>service_manager：启动 binder IPC，管理所有的 Android 系统服务</li><li>mountd：设备安装 Daemon，负责设备安装及状态通知</li><li>debuggerd：启动 debug system，处理调试进程的请求</li><li>rild：启动 radio interface layer daemon 服务，处理电话相关的事件和请求</li><li>media_server：启动 AudioFlinger，MediaPlayerService 和 CameraService，负责多媒体播放相关的功能，包括音视频解码</li><li>surface_flinger：启动 SurfaceFlinger 负责显示输出</li><li>zygote：进程孵化器，启动 Android Java VMRuntime 和启动 systemserver，负责 Android 应用进程的孵化工作</li></ul><p>在这个阶段你可以在设备的屏幕上看到 “Android” logo 了。</p><p>以上工作执行完，init 进程就会进入 loop 状态。</p><h2 id="service-manager-进程"><a href="#service-manager-进程" class="headerlink" title="service_manager 进程"></a>service_manager 进程</h2><p>ServiceManager 是 Binder IPC 通信过程中的守护进程，本身也是一个 Binder 服务。ServiceManager 进程主要是启动 Binder，提供服务的查询和注册。</p><p>具体过程详见 Binder：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Binder进程间通讯.md" target="_blank" rel="noopener">Android Binder 进程间通讯</a></p><h2 id="surface-flinger-进程"><a href="#surface-flinger-进程" class="headerlink" title="surface_flinger 进程"></a>surface_flinger 进程</h2><p>SurfaceFlinger 负责图像绘制，是应用 UI 的核心，其功能是合成所有 Surface 并渲染到显示设备。SurfaceFlinger 进程主要是启动 FrameBuffer，初始化显示系统。</p><h2 id="media-server-进程"><a href="#media-server-进程" class="headerlink" title="media_server 进程"></a>media_server 进程</h2><p>MediaServer 进程主要是启动 AudioFlinger 音频服务，CameraService 相机服务。负责处理音频解析播放，相机相关的处理。</p><h2 id="Zygote-进程"><a href="#Zygote-进程" class="headerlink" title="Zygote 进程"></a>Zygote 进程</h2><p>fork 创建进程过程：<br><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/android-process.png?raw=true" alt=""></p><p>Zygote 进程孵化了所有的 Android 应用进程，是 Android Framework 的基础，该进程的启动也标志着 Framework 框架初始化启动的开始。 </p><p>Zygote 服务进程的主要功能：</p><ul><li>注册底层功能的 JNI 函数到虚拟机</li><li>预加载 Java 类和资源</li><li>fork 并启动 system_server 核心进程</li><li>作为守护进程监听处理“孵化新进程”的请求</li></ul><p>当 Zygote 进程启动后, 便会执行到 frameworks/base/cmds/app_process/App_main.cpp 文件的 main() 方法。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">App_main.main() <span class="comment">//设置进程名，并启动 AppRuntime。</span></span><br><span class="line">AndroidRuntime::start() <span class="comment">//创建 Java 虚拟机，注册 JNI 方法，调用 ZygoteInit.main() 方法。</span></span><br><span class="line">ZygoteInit.main()   <span class="comment">//为 Zygote 注册 socket，预加载类和资源，启动 system_server 进程。</span></span><br></pre></td></tr></table></figure><p>然后 Zygote 进程会进入 loop 状态，等待下次 fork 进程。</p><h2 id="system-server-进程"><a href="#system-server-进程" class="headerlink" title="system_server 进程"></a>system_server 进程</h2><p>system_server 进程 由 Zygote 进程 fork 而来。接下来看下 system_server 启动过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先会调用 ZygoteInit.startSystemServer() 方法</span></span><br><span class="line">ZygoteInit.startSystemServer()  </span><br><span class="line"><span class="comment">//fork 子进程 system_server，进入 system_server 进程。</span></span><br><span class="line"></span><br><span class="line">ZygoteInit.handleSystemServerProcess()  </span><br><span class="line"><span class="comment">//设置当前进程名为“system_server”，创建 PathClassLoader 类加载器。</span></span><br><span class="line"></span><br><span class="line">RuntimeInit.zygoteInit()    </span><br><span class="line"><span class="comment">//重定向 log 输出，通用的初始化（设置默认异常捕捉方法，时区等），初始化 Zygote -&gt; nativeZygoteInit()。</span></span><br><span class="line"></span><br><span class="line">nativeZygoteInit()  </span><br><span class="line"><span class="comment">//方法经过层层调用，会进入 app_main.cpp 中的 onZygoteInit() 方法。</span></span><br><span class="line"></span><br><span class="line">app_main::onZygoteInit()<span class="comment">// 启动新 Binder 线程。</span></span><br><span class="line"></span><br><span class="line">applicationInit()   </span><br><span class="line"><span class="comment">//方法经过层层调用，会抛出异常 ZygoteInit.MethodAndArgsCaller(m, argv), ZygoteInit.main() 会捕捉该异常。</span></span><br><span class="line"></span><br><span class="line">ZygoteInit.main()   </span><br><span class="line"><span class="comment">//开启 DDMS 功能，preload() 加载资源，预加载 OpenGL，调用 SystemServer.main() 方法。</span></span><br><span class="line"></span><br><span class="line">SystemServer.main() </span><br><span class="line"><span class="comment">//先初始化 SystemServer 对象，再调用对象的 run() 方法。</span></span><br><span class="line"></span><br><span class="line">SystemServer.run()  </span><br><span class="line"><span class="comment">//准备主线程 looper，加载 android_servers.so 库，该库包含的源码在 frameworks/base/services/ 目录下。</span></span><br></pre></td></tr></table></figure><p>system_server 进程启动后将初始化系统上下文（设置主题），创建系统服务管理 SystemServiceManager，然后启动各种系统服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line"><span class="comment">//该方法主要启动服务 ActivityManagerService，PowerManagerService，LightsService，DisplayManagerService，PackageManagerService，UserManagerService。</span></span><br><span class="line"><span class="comment">//设置 ActivityManagerService，启动传感器服务。</span></span><br><span class="line"></span><br><span class="line">startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line"><span class="comment">//该方法主要</span></span><br><span class="line"><span class="comment">//启动服务 BatteryService 用于统计电池电量，需要 LightService。</span></span><br><span class="line"><span class="comment">//启动服务 UsageStatsService，用于统计应用使用情况。</span></span><br><span class="line"><span class="comment">//启动服务 WebViewUpdateService。</span></span><br><span class="line"></span><br><span class="line">startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line"><span class="comment">//该方法主要启动服务 InputManagerService，WindowManagerService。</span></span><br><span class="line"><span class="comment">//等待 ServiceManager，SurfaceFlinger启动完成，然后显示启动界面。</span></span><br><span class="line"><span class="comment">//启动服务 StatusBarManagerService，</span></span><br><span class="line"><span class="comment">//准备好 window, power, package, display 服务：</span></span><br><span class="line"><span class="comment">//- WindowManagerService.systemReady()</span></span><br><span class="line"><span class="comment">//- PowerManagerService.systemReady()</span></span><br><span class="line"><span class="comment">//- PackageManagerService.systemReady()</span></span><br><span class="line"><span class="comment">//- DisplayManagerService.systemReady()</span></span><br></pre></td></tr></table></figure><p>所有的服务启动完成后会注册到 ServiceManager。<br>ActivityManagerService 服务启动完成后，会进入 ActivityManagerService.systemReady()，然后启动 SystemUI，WebViewFactory，Watchdog，最后启动桌面 Launcher App。</p><p>最后会进入循环 Looper.loop()。</p><h2 id="ActivityManagerService-启动"><a href="#ActivityManagerService-启动" class="headerlink" title="ActivityManagerService 启动"></a>ActivityManagerService 启动</h2><p>启动桌面 Launcher App 需要等待 ActivityManagerService 启动完成。我们来看下 ActivityManagerService 启动过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService(Context) </span><br><span class="line"><span class="comment">//创建名为“ActivityManager”的前台线程，并获取mHandler。</span></span><br><span class="line"><span class="comment">//通过 UiThread 类，创建名为“android.ui”的线程。</span></span><br><span class="line"><span class="comment">//创建前台广播和后台广播接收器。</span></span><br><span class="line"><span class="comment">//创建目录 /data/system。</span></span><br><span class="line"><span class="comment">//创建服务 BatteryStatsService。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerService.start()  <span class="comment">//启动电池统计服务，创建 LocalService，并添加到 LocalServices。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerService.startOtherServices() -&gt; installSystemProviders()</span><br><span class="line"><span class="comment">//安装所有的系统 Provider。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerService.systemReady()</span><br><span class="line"><span class="comment">//恢复最近任务栏的 task。</span></span><br><span class="line"><span class="comment">//启动 WebView，SystemUI，开启 Watchdog，启动桌面 Launcher App。</span></span><br><span class="line"><span class="comment">//发送系统广播。</span></span><br></pre></td></tr></table></figure><p>启动桌面 Launcher App，首先会通过 Zygote 进程 fork 一个新进程作为 App 进程，然后创建 Application，创建启动 Activity，最后用户才会看到桌面。</p><h2 id="完整启动过程"><a href="#完整启动过程" class="headerlink" title="完整启动过程"></a>完整启动过程</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/android-bootloader.png?raw=true" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的？</a></li><li><a href="http://daily.zhihu.com/story/8803295" target="_blank" rel="noopener">按下电源键之后，电脑又默默干了很多事</a></li><li><a href="http://gityuan.com/2016/02/01/android-booting/" target="_blank" rel="noopener">Android系统启动-概述</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Bootloader </tag>
            
            <tag> 开机过程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇文章了解相见恨晚的 Android Binder 进程间通讯</title>
      <link href="/2017/08/08/android-binder/"/>
      <url>/2017/08/08/android-binder/</url>
      <content type="html"><![CDATA[<h1 id="Android-Binder-进程间通讯"><a href="#Android-Binder-进程间通讯" class="headerlink" title="Android - Binder 进程间通讯"></a>Android - Binder 进程间通讯</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在学习 Binder 机制，在网上查阅了大量的资料，也看了老罗的 Binder 系列的博客和 Innost 的深入理解 Binder 系列的博客，都是从底层开始讲的，全是 C 代码，虽然之前学过 C 和 C++，然而各种函数之间花式跳转，看的我都怀疑人生。 毫不夸张的讲每看一遍都是新的内容，跟没看过一样。 后来又看到了 Gityuan 的博客看到了一些图解仿佛发现了新大陆。 </p><p>下面就以图解的方式介绍下 Binder 机制，相信你看这篇文章，一定有所收获。</p><h2 id="什么是-Binder？"><a href="#什么是-Binder？" class="headerlink" title="什么是 Binder？"></a>什么是 Binder？</h2><p>Binder 是 Android 系统中进程间通讯（IPC）的一种方式，也是 Android 系统中最重要的特性之一。 Android 中的四大组件 Activity，Service，Broadcast，ContentProvider，不同的 App 等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。</p><p>理解 Binder 对于理解整个 Android 系统有着非常重要的作用，如果对 Binder 不了解，就很难对 Android 系统机制有更深入的理解。</p><h2 id="1-Binder-架构"><a href="#1-Binder-架构" class="headerlink" title="1. Binder 架构"></a>1. Binder 架构</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/binder_main.jpg?raw=true" alt="图1"></p><ul><li>Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。</li><li>Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 </li><li>Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。</li></ul><h2 id="2-Binder-机制"><a href="#2-Binder-机制" class="headerlink" title="2. Binder 机制"></a>2. Binder 机制</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/binder_main_request.jpg?raw=true" alt="图8"></p><ul><li><p>首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。</p></li><li><p>有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取WindowManager服务引用</span></span><br><span class="line">WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);</span><br></pre></td></tr></table></figure><p>  获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。</p></li><li><p>有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。</p></li></ul><p>怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。</p><h2 id="3-Binder-驱动"><a href="#3-Binder-驱动" class="headerlink" title="3. Binder 驱动"></a>3. Binder 驱动</h2><p>我们先来了解下用户空间与内核空间是怎么交互的。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/binder_device.jpg?raw=true" alt="图2"></p><p>先了解一些概念</p><h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h3><p>详细解释可以参考 <a href="http://www.linfo.org/kernel_space.html" target="_blank" rel="noopener">Kernel Space Definition</a>； 简单理解如下：</p><p>Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><p>Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p><h3 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p><blockquote><p>Kernel space can be accessed by user processes only through the use of system calls.</p></blockquote><p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p><h3 id="内核模块-驱动"><a href="#内核模块-驱动" class="headerlink" title="内核模块/驱动"></a>内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p><p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动;</p><blockquote><p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；</p></blockquote><p>驱动就是操作硬件的接口，为了支持 Binder 通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。</p><p>熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。</p><h2 id="4-Binder-进程与线程"><a href="#4-Binder-进程与线程" class="headerlink" title="4. Binder 进程与线程"></a>4. Binder 进程与线程</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/process_thread.jpg?raw=true" alt="图3"></p><p>对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。</p><p>Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。</p><h2 id="5-ServiceManager-启动"><a href="#5-ServiceManager-启动" class="headerlink" title="5. ServiceManager 启动"></a>5. ServiceManager 启动</h2><p>了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/service_manager_start.jpg?raw=true" alt="图4"></p><ul><li><p>ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。</p></li><li><p>ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。</p></li><li><p>ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。</p></li></ul><h2 id="6-ServiceManager-注册服务"><a href="#6-ServiceManager-注册服务" class="headerlink" title="6. ServiceManager 注册服务"></a>6. ServiceManager 注册服务</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/service_manager_add.jpg?raw=true" alt="图5"></p><ul><li><p>注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。</p></li><li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。</p></li><li><p>事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。</p></li></ul><h2 id="7-ServiceManager-获取服务"><a href="#7-ServiceManager-获取服务" class="headerlink" title="7. ServiceManager 获取服务"></a>7. ServiceManager 获取服务</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/service_manager_get.jpg?raw=true" alt="图6"></p><ul><li><p>获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。</p></li><li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。</p></li><li><p>Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。</p></li></ul><h2 id="8-进行一次完整通讯"><a href="#8-进行一次完整通讯" class="headerlink" title="8. 进行一次完整通讯"></a>8. 进行一次完整通讯</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_binder/binder_one_main.jpg?raw=true" alt="图7"></p><ul><li><p>我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。</p></li><li><p>首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给  ServiceManager，同时客户端线程进入等待状态。</p></li><li><p>ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。 努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。</p><p>网上资料很多，个人觉得比较好的如下：</p><ol><li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Bander设计与实现</a></li><li>老罗的 <a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a> 系列</li><li>Innost的 <a href="http://blog.csdn.net/innost/article/details/47208049" target="_blank" rel="noopener">深入理解Binder</a> 系列</li><li>Gityuan的 <a href="http://gityuan.com/2015/10/31/binder-prepare" target="_blank" rel="noopener">Binder系列</a> (基于 Android 6.0)</li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer" target="_blank" rel="noopener">Binder学习指南</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2015/10/31/binder-prepare" target="_blank" rel="noopener">Binder系列</a></li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer" target="_blank" rel="noopener">Binder学习指南</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Binder </tag>
            
            <tag> 进程间通信 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - 多渠道打包最佳实践</title>
      <link href="/2017/07/07/android-flavors/"/>
      <url>/2017/07/07/android-flavors/</url>
      <content type="html"><![CDATA[<h1 id="Android-Flavors"><a href="#Android-Flavors" class="headerlink" title="Android - Flavors"></a>Android - Flavors</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>该项目演示了在 Android Studio 中使用 gradle 构建渠道包。已更新支持 Android Studio 3.x，Gradle 4.x。</p><h2 id="渠道号"><a href="#渠道号" class="headerlink" title="渠道号"></a>渠道号</h2><p>以友盟 SDK 为例，打包多渠道：GooglePlay，小米，友盟，360，豌豆荚，应用宝。 在 AndroidManifest.xml 中加入渠道区分标识。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"UMENG_CHANNEL"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 build.gradle(Module: app) 中加入渠道打包替换对应的 UMENG_CHANNEL_VALUE 代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渠道Flavors，配置不同的渠道</span></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    GooglePlay &#123;&#125;</span><br><span class="line">    xiaomi &#123;&#125;</span><br><span class="line">    umeng &#123;&#125;</span><br><span class="line">    qihu360 &#123;&#125;</span><br><span class="line">    wandoujia &#123;&#125;</span><br><span class="line">    yingyongbao &#123;&#125;</span><br><span class="line">    <span class="comment">//其他...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量配置渠道</span></span><br><span class="line">productFlavors.all &#123;</span><br><span class="line">    flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-apk-名字"><a href="#自定义-apk-名字" class="headerlink" title="自定义 apk 名字"></a>自定义 apk 名字</h2><p>我们可以指定不同渠道号生成的 apk 的名字，这样方便打包出来区别哪个 apk 是对应哪个渠道的。</p><p>如下命名格式为：<strong>渠道名-v版本号-打包时间.apk</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打包重命名</span></span><br><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        <span class="keyword">if</span> (variant.buildType.name == <span class="string">"release"</span>) &#123;</span><br><span class="line">            variant.outputs.all &#123; output -&gt;</span><br><span class="line">                def fileName = output.outputFile.name</span><br><span class="line">                <span class="keyword">if</span> (fileName.endsWith(<span class="string">".apk"</span>)) &#123;</span><br><span class="line">                    def apkName = <span class="string">"$&#123;variant.productFlavors[0].name&#125;-v$&#123;variant.versionName&#125;-$&#123;releaseTime()&#125;.apk"</span>;</span><br><span class="line">                    outputFileName = apkName</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="渠道自定义"><a href="#渠道自定义" class="headerlink" title="渠道自定义"></a>渠道自定义</h2><p>不同的渠道定义不同的 applicationId, versionCode, versionName</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">"test"</span>,<span class="string">"test1"</span>,<span class="string">"test2"</span></span><br><span class="line"><span class="comment">//定义渠道</span></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    main_test &#123;</span><br><span class="line">        applicationId <span class="string">"com.jeanboy.app.flavors"</span></span><br><span class="line">        versionCode rootProject.ext.mainTestVersionCode</span><br><span class="line">        versionName rootProject.ext.mainTestVersionName</span><br><span class="line">        <span class="comment">//定义manifest中替换值，如：渠道号</span></span><br><span class="line">        resValue(<span class="string">"string"</span>, <span class="string">"test_app_id"</span>, <span class="string">"2017-8-14 12:09:35"</span>)</span><br><span class="line">        <span class="comment">//定义混淆文件</span></span><br><span class="line">        <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, './src/main_test/proguard-rules.pro'</span></span><br><span class="line"><span class="function">        dimension "test"</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    main_test1 </span>&#123;</span><br><span class="line">        applicationId <span class="string">"com.jeanboy.app.flavorstest1"</span></span><br><span class="line">        versionCode rootProject.ext.mainTest1VersionCode</span><br><span class="line">        versionName rootProject.ext.mainTest1VersionName</span><br><span class="line">        resValue(<span class="string">"string"</span>, <span class="string">"test_app_id"</span>, <span class="string">"2017-8-14 12:09:35"</span>)</span><br><span class="line">        <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, './src/main_test1/proguard-rules.pro'</span></span><br><span class="line"><span class="function">        dimension "test1"</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    main_test2 </span>&#123;</span><br><span class="line">        applicationId <span class="string">"com.jeanboy.app.flavorstest2"</span></span><br><span class="line">        versionCode rootProject.ext.mainTest2VersionCode</span><br><span class="line">        versionName rootProject.ext.mainTest2VersionName</span><br><span class="line">        resValue(<span class="string">"string"</span>, <span class="string">"test_app_id"</span>, <span class="string">"2017-8-14 12:09:35"</span>)</span><br><span class="line">        <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, './src/main_test2/proguard-rules.pro'</span></span><br><span class="line"><span class="function">        dimension "test2"</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="不同渠道不同签名文件"><a href="#不同渠道不同签名文件" class="headerlink" title="不同渠道不同签名文件"></a>不同渠道不同签名文件</h2><p>定义渠道包签名文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    test &#123;</span><br><span class="line">        <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'../resources/test.jks'</span>)</span><span class="comment">//密钥文件位置</span></span></span><br><span class="line"><span class="function">        storePassword 'test123'<span class="comment">//密钥密码</span></span></span><br><span class="line"><span class="function">        keyAlias 'test'<span class="comment">//密钥别名</span></span></span><br><span class="line"><span class="function">        keyPassword 'test123'<span class="comment">//别名密码</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    test1 </span>&#123;</span><br><span class="line">        <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'../resources/test1.jks'</span>)</span></span></span><br><span class="line"><span class="function">        storePassword 'test123'</span></span><br><span class="line"><span class="function">        keyAlias 'test'</span></span><br><span class="line"><span class="function">        keyPassword 'test123'</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    test2 </span>&#123;</span><br><span class="line">        <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'../resources/test2.jks'</span>)</span></span></span><br><span class="line"><span class="function">        storePassword 'test123'</span></span><br><span class="line"><span class="function">        keyAlias 'test'</span></span><br><span class="line"><span class="function">        keyPassword 'test123'</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>指定不同渠道使用的签名文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        minifyEnabled <span class="keyword">false</span></span><br><span class="line">        shrinkResources <span class="keyword">false</span></span><br><span class="line">        zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">        versionNameSuffix <span class="string">"-debug"</span><span class="comment">//版本命名后缀</span></span><br><span class="line">        buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span></span><br><span class="line">        <span class="comment">//定义debug时使用的签名文件</span></span><br><span class="line">        signingConfig signingConfigs.test</span><br><span class="line">        signingConfig signingConfigs.test1</span><br><span class="line">        signingConfig signingConfigs.test2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="keyword">true</span><span class="comment">//是否开启代码混淆</span></span><br><span class="line">        shrinkResources <span class="keyword">true</span><span class="comment">//移除无用的资源文件，依赖于minifyEnabled必须一起用</span></span><br><span class="line">        multiDexEnabled <span class="keyword">true</span><span class="comment">//解决65535</span></span><br><span class="line">        zipAlignEnabled <span class="keyword">true</span><span class="comment">//对齐zip</span></span><br><span class="line">        debuggable <span class="keyword">false</span> <span class="comment">// 是否debug</span></span><br><span class="line">        buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span></span><br><span class="line">        signingConfig signingConfigs.test</span><br><span class="line">        signingConfig signingConfigs.test1</span><br><span class="line">        signingConfig signingConfigs.test2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同渠道不同资源文件"><a href="#不同渠道不同资源文件" class="headerlink" title="不同渠道不同资源文件"></a>不同渠道不同资源文件</h2><p>例如：不同渠道需要不同的应用名</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">|-app</span><br><span class="line">    |-src</span><br><span class="line">        |-main</span><br><span class="line">        |   |-res</span><br><span class="line">        |       |-values</span><br><span class="line">        |           |-strings.xml</span><br><span class="line">        |               |-&lt;string name="app_name"&gt;Android-Flavors&lt;/string&gt;</span><br><span class="line">        |-main_test</span><br><span class="line">        |   |-res</span><br><span class="line">        |       |-values</span><br><span class="line">        |           |-strings.xml</span><br><span class="line">        |               |-&lt;string name="app_name"&gt;Android-Flavors-test&lt;/string&gt;</span><br><span class="line">        |-main_test1</span><br><span class="line">        |   |-res</span><br><span class="line">        |       |-values</span><br><span class="line">        |           |-strings.xml</span><br><span class="line">        |               |-&lt;string name="app_name"&gt;Android-Flavors-test1&lt;/string&gt;</span><br><span class="line">        |-main_test2</span><br><span class="line">        |   |-res</span><br><span class="line">        |       |-values</span><br><span class="line">        |           |-strings.xml</span><br><span class="line">        |               |-&lt;string name="app_name"&gt;Android-Flavors-test2&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>在 src 下创建与 main 同级的渠道目录，里面可创建与 main 目录下对应的目录或文件，打包时会以增量或覆盖的方式替换。</p><p>res 目录下的文件可以同名覆盖，java 或其他代码目录中类名不允许重复。</p><p>编译某个渠道包的时候遵循以下4条准则：</p><ul><li>所有的源码(src/*/java)会用来共同编译生成一个 Apk，不允许覆盖，会提示 duplicate class found</li><li>所有的 Manifests 都将会合并，这样一来就允许渠道包中可以定义不同的组件与权限，具体可参考官方 Manifest Merger</li><li>渠道中的资源会以覆盖或增量的形式与 main 合并，优先级为 Build Type &gt; Product Flavor &gt; Main sourceSet</li><li>每个 Build Variant 都会生成自己的 R 文件</li></ul><h2 id="第三方-SDK"><a href="#第三方-SDK" class="headerlink" title="第三方 SDK"></a>第三方 SDK</h2><p>例如：test1 渠道中需要使用某个 SDK，而其他渠道不需要使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        test1 &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    provided <span class="string">'com.xxx.sdk:xxx:1.0'</span><span class="comment">//提供 sdk</span></span><br><span class="line">    test1Compile <span class="string">'com.xxx.sdk:xxx:1.0'</span><span class="comment">//指定 test1 渠道编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，需要在代码中使用反射技术判断应用程序是否添加了该SDK，从而决定是否要使用 SDK。部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> useSdk;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.xxx.sdk.XXX"</span>);</span><br><span class="line">            useSdk = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/jeanboydev/Android-Flavors" target="_blank" rel="noopener">https://github.com/jeanboydev/Android-Flavors</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tech.meituan.com/mt-apk-adaptation.html" target="_blank" rel="noopener">美团Android自动化之旅—适配渠道包</a></p><p><a href="http://blog.csdn.net/codezjx/article/details/49516151" target="_blank" rel="noopener">Gradle App项目的多渠道打包实现</a></p><p><a href="http://saiwu-bigkoo.github.io/2015/10/16/android/" target="_blank" rel="noopener">多渠道打包</a></p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Flavors </tag>
            
            <tag> 多渠道 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Studio 3.0 升级指南</title>
      <link href="/2017/06/15/android-update-to-sutdio-3/"/>
      <url>/2017/06/15/android-update-to-sutdio-3/</url>
      <content type="html"><![CDATA[<h1 id="Android-Studio-3-0-升级指南"><a href="#Android-Studio-3-0-升级指南" class="headerlink" title="Android Studio 3.0 升级指南"></a>Android Studio 3.0 升级指南</h1><h2 id="Gradle-版本升级"><a href="#Gradle-版本升级" class="headerlink" title="Gradle 版本升级"></a>Gradle 版本升级</h2><ul><li>Gradle Plugin 升级到 3.0.0 及以上，修改 <code>project/build.gradle</code> 文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        google()<span class="comment">//*增加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.1.1'</span><span class="comment">//*修改</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()<span class="comment">//*增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Gradle 升级到 4.1 及以上，修改 <code>project/gradle/gradle-wrapper.properties</code> 文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//*修改</span></span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-4.4-all.zip</span></span><br></pre></td></tr></table></figure><h2 id="多渠道"><a href="#多渠道" class="headerlink" title="多渠道"></a>多渠道</h2><blockquote><p>Error:All flavors must now belong to a named flavor dimension.<br>The flavor ‘flavor_name’ is not assigned to a flavor dimension.</p></blockquote><p>3.0 后 Gradle 添加了 <code>flavorDimensions</code> 属性，用来控制多个版本的代码和资源，缺失就会报错。在项目 app 下 build.gradle 文件中，添加 flavorDimensions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   ...</span><br><span class="line">   flavorDimensions <span class="string">"tier"</span>,<span class="string">"minApi"</span></span><br><span class="line">   productFlavors&#123;</span><br><span class="line">     fees&#123;</span><br><span class="line">        dimension <span class="string">"tier"</span></span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line">     minApi23&#123;</span><br><span class="line">       dimension <span class="string">"minApi"</span></span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要多版本控制只需添加：flavorDimensions “code”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   ...</span><br><span class="line">   defaultConfig &#123;</span><br><span class="line">       ...</span><br><span class="line">      flavorDimensions <span class="string">"code"</span></span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gradle-自定义-apk-名称"><a href="#Gradle-自定义-apk-名称" class="headerlink" title="Gradle 自定义 apk 名称"></a>Gradle 自定义 apk 名称</h2><blockquote><p>Error:(88, 0) Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=appDebug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl.</p></blockquote><p>之前改 Apk 名字的代码类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.each &#123; output -&gt;</span><br><span class="line">        def file = output.outputFile</span><br><span class="line">        def apkName = <span class="string">'xxx-xxx-xxx-signed.apk'</span></span><br><span class="line">        output.outputFile = <span class="keyword">new</span> File(file.parent, apkName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 outputFile 属性变为只读，需要进行如下修改，直接对 outputFileName 属性赋值即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.all &#123;<span class="comment">//each 改为 each</span></span><br><span class="line">        def apkName = <span class="string">'xxx-xxx-xxx-signed.apk'</span></span><br><span class="line">        outputFileName = apkName<span class="comment">//output.outputFile 改为 outputFileName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖关键字变化"><a href="#依赖关键字变化" class="headerlink" title="依赖关键字变化"></a>依赖关键字变化</h2><ul><li>compile：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//3.0 之前</span></span><br><span class="line">    compile <span class="string">'com.android.support:appcompat-v7:26.1.0'</span></span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(include: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span></span></span><br><span class="line"><span class="function">    compile <span class="title">files</span><span class="params">(<span class="string">'libs/gson-2.3.1.jar'</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//3.0 之后</span></span></span><br><span class="line"><span class="function">    implementation 'com.android.support:appcompat-v7:26.1.0'</span></span><br><span class="line"><span class="function">    implementation <span class="title">fileTree</span><span class="params">(include: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span></span></span><br><span class="line"><span class="function">    implementation <span class="title">files</span><span class="params">(<span class="string">'libs/gson-2.3.1.jar'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>api</code>: 对应之前的 <code>compile</code> 关键字，功能一模一样。会传递依赖，导致 gradle 编译的时候遍历整颗依赖树</li><li><code>implementation</code>: 对应之前的 <code>compile</code> ，与 api 类似，关键区别是不会有依赖传递</li><li><code>compileOnly</code>: 对应之前的 provided，依赖仅用于编译期不会打包进最终的 apk 中</li><li><code>runtimeOnly</code>: 对应之前的 <code>apk</code>，与上面的 compileOnly 相反</li></ul><p>关于 implementation 与 api 的区别，主要在依赖是否会传递上。如：A 依赖 B，B 依赖 C，若使用api则 A 可以引用 C，而 implementation 则不能引用。</p><p>这里更推荐用 implementation，一是不会间接的暴露引用，清晰知道目前项目的依赖情况；二是可以提高编译时依赖树的查找速度，进而提升编译速度。</p><h2 id="Java-8-支持"><a href="#Java-8-支持" class="headerlink" title="Java 8 支持"></a>Java 8 支持</h2><p>Gradle 带来了新的 Java 8 兼容方案 desugar，启用方式十分简单，只要在 gradle android 层次之下加入如下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停用 desugar，在 gradle.properties 文件中加入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.enableDesugar=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://developer.android.com/studio/write/java8-support.html" target="_blank" rel="noopener">官方文档 - 使用 Java 8 语言功能</a></li></ul><h2 id="AAPT2"><a href="#AAPT2" class="headerlink" title="AAPT2"></a>AAPT2</h2><p>AAPT2 将默认启用，如果遇到离奇的问题，可以尝试禁用，只要在 gradle.properties 中加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.enableAapt2=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html" target="_blank" rel="noopener">官方文档 - 迁移到 Android Plugin for Gradle 3.0.0</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows 环境下载 Android 源码</title>
      <link href="/2017/06/06/download-android-sources-code-for-windows/"/>
      <url>/2017/06/06/download-android-sources-code-for-windows/</url>
      <content type="html"><![CDATA[<h1 id="Windows-环境下载-Android-源码"><a href="#Windows-环境下载-Android-源码" class="headerlink" title="Windows 环境下载 Android 源码"></a>Windows 环境下载 Android 源码</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android 官网（该方式不适合 Windows 平台）：<a href="https://source.android.com/source/downloading.html" target="_blank" rel="noopener">https://source.android.com/source/downloading.html</a></p><p>可是我就想在 Windows 中使用 Source Insight 看看源代码，当然可以！</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ol><li>安装 git</li><li>安装 Python</li><li>自备梯子</li><li>硬盘剩余容量最好大于 100G</li></ol><h2 id="1-安装-git"><a href="#1-安装-git" class="headerlink" title="1. 安装 git"></a>1. 安装 git</h2><p>官网：<a href="https://git-scm.com/downloads/" target="_blank" rel="noopener">https://git-scm.com/downloads/</a></p><p>图形化工具：<a href="https://tortoisegit.org/" target="_blank" rel="noopener">https://tortoisegit.org/</a></p><blockquote><p>什么？不会安装 git，那还看什么源码！自行百度！</p></blockquote><h2 id="2-安装-Python"><a href="#2-安装-Python" class="headerlink" title="2. 安装 Python"></a>2. 安装 Python</h2><p>官网：<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p><p>安装参考：<a href="http://jingyan.baidu.com/article/c910274be14d64cd361d2dd8.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/c910274be14d64cd361d2dd8.html</a></p><blockquote><p>只需要安装好运行环境即可</p></blockquote><h2 id="3-自备梯子"><a href="#3-自备梯子" class="headerlink" title="3. 自备梯子"></a>3. 自备梯子</h2><p>没有梯子？那就使用清华源：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a></p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><h3 id="1-打开-Git-Bash，用-git-克隆源代码仓库"><a href="#1-打开-Git-Bash，用-git-克隆源代码仓库" class="headerlink" title="1. 打开 Git Bash，用 git 克隆源代码仓库"></a>1. 打开 Git Bash，用 git 克隆源代码仓库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//android.googlesource.com/platform/manifest.git</span></span><br><span class="line"><span class="comment">//没有梯子使用清华源</span></span><br><span class="line">git clone https:<span class="comment">//aosp.tuna.tsinghua.edu.cn/platform/manifest.git</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_download_source/1.png?raw=true" alt="图1"></p><blockquote><p>这时 D:/android_source_code/ 目录下会出现一个 manifest 目录，进入此目录，里面除了 git 的配置目录外，clone 下来了一个 default.xml 文件。</p></blockquote><h3 id="2-切换到想要的源码版本分支"><a href="#2-切换到想要的源码版本分支" class="headerlink" title="2. 切换到想要的源码版本分支"></a>2. 切换到想要的源码版本分支</h3><p>去这里 <a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="noopener">https://source.android.com/source/build-numbers.html#source-code-tags-and-builds</a></p><p>找到想要的版本分支，并复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd manifest</span><br><span class="line"><span class="comment">//没有梯子，使用 git branch -a 查看所有分支，找到想要的分支</span></span><br><span class="line">git branch -a</span><br><span class="line">git checkout android-<span class="number">6.0</span>.1_r79 <span class="comment">//这里以 6.0 最后一个版本下载</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_download_source/2.png?raw=true" alt="图2"></p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_download_source/3.png?raw=true" alt="图3"></p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_download_source/4.png?raw=true" alt="图4"></p><h3 id="3-使用-Python-执行脚本进行源代码下载"><a href="#3-使用-Python-执行脚本进行源代码下载" class="headerlink" title="3. 使用 Python 执行脚本进行源代码下载"></a>3. 使用 Python 执行脚本进行源代码下载</h3><p>将下面的代码复制，创建文件 python_download.py，并保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1. 修改为源码要保存的路径</span></span><br><span class="line">rootdir = <span class="string">"D:/android_source_code/Android_6_0_1"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2. 设置 git 安装的路径</span></span><br><span class="line">git = <span class="string">"C:/Develop/Git/bin/git.exe"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 修改为第一步中 manifest 中 default.xml 保存的路径</span></span><br><span class="line">dom = xml.dom.minidom.parse(<span class="string">"D:/android_source_code/manifest/default.xml"</span>)</span><br><span class="line">root = dom.documentElement</span><br><span class="line"> </span><br><span class="line"><span class="comment">#prefix = git + " clone https://android.googlesource.com/"</span></span><br><span class="line"><span class="comment"># 4. 没有梯子使用清华源下载</span></span><br><span class="line">prefix = git + <span class="string">" clone https://aosp.tuna.tsinghua.edu.cn/"</span></span><br><span class="line">suffix = <span class="string">".git"</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(rootdir):  </span><br><span class="line">    os.mkdir(rootdir)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.getElementsByTagName(<span class="string">"project"</span>):  </span><br><span class="line">    os.chdir(rootdir)  </span><br><span class="line">    d = node.getAttribute(<span class="string">"path"</span>)  </span><br><span class="line">    last = d.rfind(<span class="string">"/"</span>)  </span><br><span class="line">    <span class="keyword">if</span> last != <span class="number">-1</span>:  </span><br><span class="line">        d = rootdir + <span class="string">"/"</span> + d[:last]  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(d):  </span><br><span class="line">            os.makedirs(d)  </span><br><span class="line">        os.chdir(d)  </span><br><span class="line">    cmd = prefix + node.getAttribute(<span class="string">"name"</span>) + suffix  </span><br><span class="line">    call(cmd)</span><br></pre></td></tr></table></figure><h3 id="4-执行-Python-脚本开始下载"><a href="#4-执行-Python-脚本开始下载" class="headerlink" title="4. 执行 Python 脚本开始下载"></a>4. 执行 Python 脚本开始下载</h3><p>打开 Python 客户端</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_download_source/5.png?raw=true" alt="图5"></p><p>打开上一步保存的 python_download.py 脚本文件</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_download_source/6.png?raw=true" alt="图6"></p><p>点击 Run-&gt;Run Module 来运行脚本，或直接按F5运行。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_download_source/7.png?raw=true" alt="图7"></p><p>静静地等待下载完成吧。</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Source Code </tag>
            
            <tag> Download </tag>
            
            <tag> 源码下载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - Handler 消息机制</title>
      <link href="/2017/05/15/android-handler/"/>
      <url>/2017/05/15/android-handler/</url>
      <content type="html"><![CDATA[<h1 id="Android-Handler-消息机制"><a href="#Android-Handler-消息机制" class="headerlink" title="Android - Handler 消息机制"></a>Android - Handler 消息机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android 的消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。 Handler 的主要作用是将某个任务切换到 Handler 所在的线程中去执行。</p><h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><p>Handler工作流程</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_handler/01.jpg?raw=true" alt="图1"></p><p>Looper</p><blockquote><p><strong>每个线程中最多只能有一个 Looper 对象</strong>，由 Looper 来管理此线程里的 MessageQueue (消息队列)。</p><p>可以通过 <strong>Looper.myLooper()</strong> 获取当前线程的 Looper 实例，通过 <strong>Looper.getMainLooper()</strong> 获取主（UI）线程的 Looper 实例。</p><p>Lopper 会以无限循环的形式去查找是否有新消息，如果有就处理消息，否则就一直等待着。</p></blockquote><p>Handler</p><blockquote><p>你可以构造 Handler 对象来与 Looper 沟通，通过 <strong>push</strong> 发送新消息到 MessageQueue 里；或者通过 <strong>handleMessage</strong> 接收 Looper 从 MessageQueue 取出来消息。</p></blockquote><p>MessageQueue</p><blockquote><p>MessageQueue是一个消息队列，内部存储了一组消息，以队列的形式对外提供插入和<br>删除的工作，内部采用单链表的数据结构来存储消息列表。</p></blockquote><p>ActivityThread</p><blockquote><p>我们经常提到的主线程，也叫UI线程，它就是 ActivityThread，主线程启动会<strong>默认初始化一个 Looper 并创建 Handler</strong>。</p><p><strong>一个线程中只有一个 Looper 实例，一个 MessageQueue 实例，可以有多个 Handler 实例。</strong></p></blockquote><p>ThreadLocal</p><blockquote><p>一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获得数据。</p><p>对于 Handler 来说，它需要获取当前线程的 Looper ,而 Looper 的作用于就是线程并且不同的线程具有不同的 Looper ，通过 ThreadLocal 可以轻松实现线程中的存取。</p><p>ThreadLocal原理：不同线程访问同一个ThreadLoacl的get方法，ThreadLocal的get方法会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找对应的Value值。</p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>通过上面分析我们知道使用 Handler 之前必须先调用 <strong>Looper.prepare();</strong> 进行初始化，我们先看下 Looper 的源码。</p><h4 id="1-Looper-工作原理"><a href="#1-Looper-工作原理" class="headerlink" title="1. Looper 工作原理"></a>1. Looper 工作原理</h4><p>先看一下 Looper 工作流程</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_handler/03.png?raw=true" alt="图3"></p><p>Looper 源码最上面的注释里有一个使用示例如下，可以清晰的看出 Looper 的使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Looper.prepare();<span class="comment">//先初始化 Looper</span></span><br><span class="line">         mHandler = <span class="keyword">new</span> Handler() &#123;<span class="comment">//创建 Handler</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// process incoming messages here</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         Looper.loop();<span class="comment">//启用 Looper 的 loop 方法开启消息轮询</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接续看一下 Looper 的完整源码，分析下工作过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="comment">//每个线程都会有一个ThreadLocal 用来保存 Looper对象（里面包含了主线程和 MessageQueue）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// 主线程的 Looper</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;<span class="comment">//保存消息队列</span></span><br><span class="line">    <span class="keyword">final</span> Thread mThread;<span class="comment">//保存主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;<span class="comment">//为当前线程创建 Looper</span></span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//一个线程只能有一个 Looper， 否则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//将创建的 Looper 放入 ThreadLocal</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化主线程的 Looper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取主线程的 Looper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> sMainLooper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在当前线程中开启轮询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//从 ThreadLocal 中取出当前线程的 Looper 对象</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//Looper 没有调用 Looper.prepare() 初始化，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//从 Looper 对象中取出消息队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// 不断的取出消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line"><span class="comment">//取出消息的 target (也就是 Handler)，执行分发消息的操作</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();<span class="comment">//消息已经分发，进行回收操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();<span class="comment">//从 ThreadLocal 中取出当前线程的 Looper 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建消息队列</span></span><br><span class="line">        mThread = Thread.currentThread();<span class="comment">//保存当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">false</span>);<span class="comment">//直接退出消息循环，不管是否还有消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">true</span>);<span class="comment">//执行完所有的消息，退出消息循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-MessageQueue-工作原理"><a href="#2-MessageQueue-工作原理" class="headerlink" title="2. MessageQueue 工作原理"></a>2. MessageQueue 工作原理</h4><p>在 Looper 中创建了 MessageQueue，我们接着看下 MessageQueue 是怎么工作的。</p><p>MessageQueue 工作流程</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_handler/02.png?raw=true" alt="图2"></p><p>MessageQueue的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line"><span class="comment">//构造函数，quitAllowed 用来标识是否允许退出。</span></span><br><span class="line"><span class="comment">//主线程是不允许退出的（不然会退出整个程序），子线程可以退出。</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再看一下 MessageQueue.enqueueMessage() 的源码，分析下是怎么添加消息的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 如果消息队列里面没有消息，或者消息的执行时间比里面的消息早，就把这条消息设置成第一条消息。</span></span><br><span class="line"><span class="comment">//一般不会出现这种情况，因为系统一定会有很多消息。</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果消息队列里面有消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//找到消息队列里面的最后一条消息</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;<span class="comment">//把消息添加到最后</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了怎么添加消息，我们再看下 MessageQueue.next() 方法是怎么取出消息的，也就是 Looper.loop() 方法中不断取消息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;<span class="comment">//拿到当前的消息队列</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//处理异步的消息，暂不讨论</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//取出一条消息，消息队列往后移动一个</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();<span class="comment">//标记为已使用</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 MessageQueue 是个链表结构，里面保存的是 Message，我们再看下 Message 是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;<span class="comment">//消息类型，标识消息的作用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;<span class="comment">//整型参数1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;<span class="comment">//整型参数2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object obj;<span class="comment">//复杂对象参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IN_USE = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//标记消息已使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** If set message is asynchronous */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ASYNCHRONOUS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;<span class="comment">//标记消息是否异步</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Flags to clear in the copyFrom method */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags;<span class="comment">//消息当前标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">long</span> when;<span class="comment">//消息执行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Bundle data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Handler target;<span class="comment">//Handler 用于执行 handleMessage();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Runnable callback;<span class="comment">//消息是一个Runnable</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;<span class="comment">//下一个消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//控制并发访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//消息池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//消息池数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//消息最大数量</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Handler-工作原理"><a href="#3-Handler-工作原理" class="headerlink" title="3. Handler 工作原理"></a>3. Handler 工作原理</h4><p>在 Message 中我们看到了 target 是一个 Handler，我们看下 Handler 是怎么与 Looper 和 MessageQueue 一起搭配工作的。</p><p>看一下 Handler 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;<span class="comment">//如果消息体是 Runnable 就执行 run()</span></span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果创建 Handler 时传入了 Callback，就执行 Callback 里面的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);<span class="comment">//如果上述两种都没有实现，就执行 handleMessage 的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;<span class="comment">//可以指定关联哪个线程的 Looper</span></span><br><span class="line">        <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程调用的构造方法，主线程已经调用了 Looper.prepareMainLooper();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();<span class="comment">//取出主线程的 Looper</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;<span class="comment">//把 Handler 的 mQueue 指向 Looper 中的 mQueue</span></span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种构造方法，专门给子线程中创建 Handler 时使用的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送 Runnable 消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//一般更新 UI 时发送的消息，延时时间为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送延时消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送指定时间发送的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//把字节传入 Message 中一起发送</span></span><br><span class="line"><span class="comment">//Looper 中需要使用 Handler 来执行 dispatchMessage 方法</span></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-ActivityThread-创建默认的-Handler"><a href="#4-ActivityThread-创建默认的-Handler" class="headerlink" title="4. ActivityThread 创建默认的 Handler"></a>4. ActivityThread 创建默认的 Handler</h4><p>上面说过，ActivityThread 主线程默认是有一个 Handler 的，我们来看一下主线程是怎么创建默认的 Handler 的。</p><p>我们看一下 ActivityThread 类中的 main 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();<span class="comment">//准备一些相关环境，给我们的组件启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();<span class="comment">//初始化主线程 Looper</span></span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();<span class="comment">//开启消息轮询，不断取出消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Activity 可以直接用 runOnUiThread() 来使用默认的 Handler 发送消息，我们来看下它是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;<span class="comment">//非主线程，发送 Runnable 消息</span></span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//在主线程中直接执行 run()</span></span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-HandlerThread-异步消息处理机制"><a href="#5-HandlerThread-异步消息处理机制" class="headerlink" title="5. HandlerThread 异步消息处理机制"></a>5. HandlerThread 异步消息处理机制</h4><blockquote><ol><li>HandlerThread 继承了 Thread，是一种可以使用 Handler 的 Thread；</li><li>在 run 方法中通过 looper.prepare() 来开启消息循环，这样就可以在 HandlerThread 中创<br>建Handler了；</li><li>外界可以通过一个 Handler 的消息方式来通知 HandlerThread 来执行具体任务；确定不使<br>用之后，可以通过 quit 或 quitSafely 方法来终止线程执行。</li></ol></blockquote><p>先分析一下 HandlerThread 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程的优先级</span></span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="comment">//线程的id</span></span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一个与Handler关联的Looper对象</span></span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="comment">//设置优先级为默认线程</span></span><br><span class="line">        mPriority = android.os.Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可重写方法，Looper.loop之前在线程中需要处理的其他逻辑在这里实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//HandlerThread线程的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程的id</span></span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        <span class="comment">//创建Looper对象</span></span><br><span class="line">        <span class="comment">//这就是为什么我们要在调用线程的start()方法后才能得到Looper(Looper.myLooper不为Null)</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="comment">//同步代码块，当获得mLooper对象后，唤醒所有线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置线程优先级</span></span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        <span class="comment">//Looper.loop之前在线程中需要处理的其他逻辑</span></span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        <span class="comment">//建立了消息循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="comment">//一般执行不到这句，除非quit消息队列</span></span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="comment">//线程死了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步代码块，正好和上面run方法中同步块对应</span></span><br><span class="line">        <span class="comment">//只要线程活着并且mLooper为null，则一直等待</span></span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出消息循环</span></span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出消息循环</span></span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回线程id</span></span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerThread 使用代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerThread mHandlerThread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mThreadHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mUiHandler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"HandlerWorkThread"</span>);</span><br><span class="line">        <span class="comment">//必须在实例化mThreadHandler之前调运start方法，原因上面源码已经分析了</span></span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        <span class="comment">//将当前mHandlerThread子线程的Looper传入mThreadHandler，使得</span></span><br><span class="line">        <span class="comment">//mThreadHandler的消息队列依赖于子线程（在子线程中执行）</span></span><br><span class="line">        mThreadHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                Log.i(<span class="keyword">null</span>, <span class="string">"在子线程中处理！id="</span>+Thread.currentThread().getId());</span><br><span class="line">                <span class="comment">//从子线程往主线程发送消息</span></span><br><span class="line">                mUiHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mUiHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                Log.i(<span class="keyword">null</span>, <span class="string">"在UI主线程中处理！id="</span>+Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//从主线程往子线程发送消息</span></span><br><span class="line">        mThreadHandler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此 Handler 消息机制的源码已经分析完了，相信你一定明白了 Handler 消息机制。<br><br>一句话，每个线程可以创建一个 Looper ，每个 Looper 轮询着一个 MessageQueue 不断取出消息，有消息则回调给 Handler，Handler 负责向 MessageQueue 中发送消息和处理回调的消息来完成线程之间的转换。</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - IPC 多进程</title>
      <link href="/2017/05/08/android-ipc/"/>
      <url>/2017/05/08/android-ipc/</url>
      <content type="html"><![CDATA[<h1 id="Android-IPC-多进程"><a href="#Android-IPC-多进程" class="headerlink" title="Android - IPC 多进程"></a>Android - IPC 多进程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IPC 即 Inter-Process Communication，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。</p><p>线程是 CPU 调度的最小单元，是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上是指一个程序或者应用。进程与线程是包含与被包含的关系。一个进程可以包含多个线程。最简单的情况下一个进程只有一个线程，即主线程（例如 Android 的 UI 线程）。</p><p>任何操作系统都需要有相应的 IPC 机制。在 Android 中，IPC 的使用场景大概有以下：</p><ol><li>有些模块由于特殊原因需要运行在单独的进程中。</li><li>通过多进程来获取多份内存空间。</li><li>当前应用需要向其他应用获取数据。</li></ol><h2 id="1-开启多进程模式"><a href="#1-开启多进程模式" class="headerlink" title="1. 开启多进程模式"></a>1. 开启多进程模式</h2><p>给四大组件在Manifest中指定 android:process 属性。这个属性的值就是进程名。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=<span class="string">".service.RemoteService"</span></span><br><span class="line">    android:process=<span class="string">":remote"</span>&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>tips：使用 adb shell ps 或 adb shell ps|grep 包名 查看当前所存在的进程信息。</p></blockquote><h2 id="2-多线程模式的运行机制"><a href="#2-多线程模式的运行机制" class="headerlink" title="2. 多线程模式的运行机制"></a>2. 多线程模式的运行机制</h2><p>Android 为每个进程都分配了一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，导致不同的虚拟机访问同一个类的对象会产生多份副本。例如不同进程的 Activity 对静态变量的修改，对其他进程不会造成任何影响。所有运行在不同进程的四大组件，只要它们之间需要通过内存在共享数据，都会共享失败。四大组件之间不可能不通过中间层来共享数据。</p><p>多进程会带来以下问题：</p><ol><li>静态成员和单例模式完全失效。</li><li>线程同步锁机制完全失效。这两点都是因为不同进程不在同一个内存空间下，锁的对象也不是同一个对象。</li><li>SharedPreferences 的可靠性下降。SharedPreferences 底层是 通过读/写 XML 文件实现的，并发读/写会导致一定几率的数据丢失。</li><li>Application 会多次创建。</li></ol><p>由于系统创建新的进程的同时分配独立虚拟机，其实这就是启动一个应用的过程。在多进程模式中，不同进程的组件拥有独立的虚拟机、Application以及内存空间。实现跨进程的方式有很多：</p><ol><li>Intent传递数据。</li><li>共享文件和SharedPreferences。</li><li>基于Binder的Messenger和AIDL。</li><li>Socket。</li></ol><h2 id="3-Binder"><a href="#3-Binder" class="headerlink" title="3. Binder"></a>3. Binder</h2><p>Android 中进程间通讯的核心就是 Binder 机制，强烈建议了解一下 Binder 机制。</p><p><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Binder进程间通讯.md" target="_blank" rel="noopener">Android Binder 进程间通讯</a></p><h2 id="4-Android-中的-IPC-方式"><a href="#4-Android-中的-IPC-方式" class="headerlink" title="4. Android 中的 IPC 方式"></a>4. Android 中的 IPC 方式</h2><p>主要有以下方式：</p><ol><li>Intent 中附加 extras 来传递消息</li><li>共享文件</li><li>Binder 方式</li><li>四大组件之一的 ContentProvider</li><li>Socket</li></ol><h3 id="1-使用Bundle"><a href="#1-使用Bundle" class="headerlink" title="1. 使用Bundle"></a>1. 使用Bundle</h3><p>四大组件中的三大组件（Activity、Service、Receiver）都支持在 Intent 中传递 Bundle 数据。Bundle 实现了 Parcelable 接口，**当我们在一个进程中启动了另一个进程的 Activity、Service、Receiver，可以再 Bundle 中附加我们需要传输给远程进程的消息并通过 Intent 发送出去。被传输的数据必须能够被序列化。</p><h3 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2. 使用文件共享"></a>2. 使用文件共享</h3><p>一些概念：</p><ol><li><p>两个进程通过读写同一个文件来交换数据。还可以通过 ObjectOutputStream / ObjectInputStream 序列化一个对象到文件中，或者在另一个进程从文件中反序列这个对象。</p><blockquote><p>注意：反序列化得到的对象只是内容上和序列化之前的对象一样，本质是两个对象。</p></blockquote></li><li>文件并发读写会导致读出的对象可能不是最新的，并发写的话那就更严重了。所以文件共享方式适合对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写问题。</li><li>SharedPreferences 底层实现采用XML文件来存储键值对。系统对它的读/写有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对它的读/写变得不可靠，面对高并发读/写时 SharedPreferences 有很大几率丢失数据，因此不建议在IPC中使用 SharedPreferences 。</li></ol><h3 id="3-使用-Messenger"><a href="#3-使用-Messenger" class="headerlink" title="3. 使用 Messenger"></a>3. 使用 Messenger</h3><p>Messenger 可以在不同进程间传递 Message 对象。是一种轻量级的 IPC 方案，底层实现是 AIDL。</p><p>具体使用时，分为服务端和客户端：</p><ol><li><p>服务端：创建一个 Service 来处理客户端请求，同时创建一个 Handler 并通过它来创建一个Messenger，然后再 Service 的 onBind 中返回 Messenger 对象底层的 Binder 即可。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger (<span class="keyword">new</span> xxxHandler());</span><br></pre></td></tr></table></figure></li><li><p>客户端：绑定服务端的 Sevice，利用服务端返回的 IBinder 对象来创建一个 Messenger，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。</p></li><li>总而言之，就是客户端和服务端 拿到对方的 Messenger 来发送 Message 。只不过客户端通过 bindService 而服务端通过 message.replyTo 来获得对方的Messenger。</li><li>Messenger中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。</li></ol><h3 id="4-使用-AIDL"><a href="#4-使用-AIDL" class="headerlink" title="4. 使用 AIDL"></a>4. 使用 AIDL</h3><p>如果有大量的并发请求，使用 Messenger 就不太适合，同时如果需要跨进程调用服务端的方法，Messenger 就无法做到了。这时我们可以使用AIDL。</p><p>流程如下：</p><ol><li>服务端需要创建 Service来监听客户端请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在AIDL文件中声明，最后在Service中实现这个AIDL接口即可。</li><li>客户端首先绑定服务端的 Service，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，接着就可以调用 AIDL 中的方法了。</li></ol><p>注意事项：</p><ol><li>AIDL 支持的数据类型：</li></ol><ul><li>基本数据类型、String、CharSequence</li><li>List：只支持 ArrayList，里面的每个元素必须被AIDL支持</li><li>Map：只支持 HashMap，里面的每个元素必须被AIDL支持</li><li>Parcelable</li><li>所有的AIDL接口本身也可以在AIDL文件中使用</li></ul><ol start="2"><li>自定义的 Parcelable 对象和 AIDL 对象，不管它们与当前的 AIDL 文件是否位于同一个包，都必须显式 import 进来。</li><li><p>如果 AIDL 文件中使用了自定义的 Parcelable 对象，就必须新建一个和它同名的 AIDL 文件，并在其中声明它为 Parcelable 类型。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure></li><li><p>AIDL接口中的参数除了基本类型以外都必须表明方向in/out。AIDL接口文件中只支持方法，不支持声明静态常量。建议把所有和AIDL相关的类和文件放在同一个包中，方便管理。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接时，管理数据的集合直接采用 CopyOnWriteArrayList 来进行自动线程同步。类似的还有 ConcurrentHashMap 。</p></li><li>因为客户端的 listener 和服务端的 listener 不是同一个对象，所以 RecmoteCallbackList 是系统专门提供用于删除跨进程 listener 的接口，支持管理任意的 AIDL 接口，因为所有 AIDL 接口都继承自 IInterface 接口。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteCallbackList</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">IInterface</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>它内部通过一个Map接口来保存所有的 AIDL 回调，这个Map的key是 IBinder 类型，value是 Callback 类型。当客户端解除注册时，遍历服务端所有listener，找到和客户端 listener 具有相同 Binder 对象的服务端 listenr 并把它删掉。</p><ol start="7"><li>客户端 RPC 的时候线程会被挂起，由于被调用的方法运行在服务端的 Binder 线程池中，可能很耗时，不能在主线程中去调用服务端的方法。</li></ol><h3 id="5-使用ContentProvider"><a href="#5-使用ContentProvider" class="headerlink" title="5. 使用ContentProvider"></a>5. 使用ContentProvider</h3><ol><li>ContentProvider 是四大组件之一，其底层实现和 Messenger 一样是 Binder。ContentProvider 天生就是用来进程间通信，只需要实现一个自定义或者系统预设置的 ContentProvider，通过 ContentResolver 的 query、update、insert 和 delete 方法即可。</li><li>创建 ContentProvider，只需继承 ContentProvider 实现 onCreate 、 query 、 update 、 insert 、 getType 六个抽象方法即可。除了 onCreate 由系统回调并运行在主线程，其他五个方法都由外界调用并运行在Binder线程池中。</li></ol><h3 id="6-使用Socket"><a href="#6-使用Socket" class="headerlink" title="6. 使用Socket"></a>6. 使用Socket</h3><p>Socket 可以实现计算机网络中的两个进程间的通信，当然也可以在本地实现进程间的通信。服务端 Service 监听本地端口，客户端连接指定的端口，建立连接成功后，拿到 Socket 对象就可以向服务端发送消息或者接受服务端发送的消息。</p><h2 id="5-具体实现"><a href="#5-具体实现" class="headerlink" title="5. 具体实现"></a>5. 具体实现</h2><p>参考代码：</p><p><a href="https://github.com/jeanboydev/Android-AIDLTest" target="_blank" rel="noopener">https://github.com/jeanboydev/Android-AIDLTest</a></p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> IPC </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - Activity LaunchMode 启动模式 &amp; IntentFilter 匹配规则</title>
      <link href="/2017/05/01/android-launch-mode-and-intent-filter/"/>
      <url>/2017/05/01/android-launch-mode-and-intent-filter/</url>
      <content type="html"><![CDATA[<h1 id="Android-Activity-LaunchMode-启动模式-amp-IntentFilter-匹配规则"><a href="#Android-Activity-LaunchMode-启动模式-amp-IntentFilter-匹配规则" class="headerlink" title="Android - Activity LaunchMode 启动模式 &amp; IntentFilter 匹配规则"></a>Android - Activity LaunchMode 启动模式 &amp; IntentFilter 匹配规则</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个应用都会有多个 Activity，Android 中使用栈来管理 Activity。 Activity 的启动模式目前有四种：standard、singleTop、singleTask、singleIntance。</p><h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><h3 id="1-standard"><a href="#1-standard" class="headerlink" title="1. standard"></a>1. standard</h3><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_task_launch_modes/01.jpg?raw=true" alt="图1"></p><ul><li>标准模式，也就是系统的默认模式。</li><li>每次启动都会重新创建一个实例，不管这个 Activity 在栈中是否已经存在。</li><li><p>谁启动了这个 Activity，那么 Activity 就运行在启动它的那个 Activity 所在的栈中。</p><blockquote><p>用 Application 去启动 Activity 时会报错，提示非 Activity 的 Context没有所谓的任务栈。<br>解决办法是为需要启动的 Activity 指定 <strong>FLAG_ACTIVITY_NEW_TASK</strong> 标志位，这样就会为它创建一个新的任务栈。</p></blockquote></li></ul><h3 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="2. singleTop"></a>2. singleTop</h3><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_task_launch_modes/02.jpg?raw=true" alt="图2"></p><ul><li>栈顶复用模式，在这种模式下，如果新 Activity 位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时回调 <strong>onNewIntent</strong> 方法。</li><li>如果新 Activity 已经存在但不是位于栈顶，那么新 Activity 仍然会被创建。</li></ul><h3 id="3-singleTask-amp-singleIntance"><a href="#3-singleTask-amp-singleIntance" class="headerlink" title="3. singleTask &amp; singleIntance"></a>3. singleTask &amp; singleIntance</h3><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_task_launch_modes/03.jpg?raw=true" alt="图3"></p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><ul><li>栈内复用模式，这是一种单实例模式，在这种模式下，只要 Activity 在栈中存在，那么多次启动这个 Activity 都不会重新创建实例，同时也会回调 <strong>onNewIntent</strong> 方法。 同时会导致在 Activity 之上的栈内 Activity 出栈。</li><li>如果 Activity 不存在重新创建。</li></ul><h4 id="singleIntance"><a href="#singleIntance" class="headerlink" title="singleIntance"></a>singleIntance</h4><ul><li>单实例模式，这是一种加强的 singleTask 模式。 具有 singleTask 模式的所有特性外，同时具有此模式的 Activity 只能单独的位于一个任务栈中。</li></ul><h3 id="4-其他情况"><a href="#4-其他情况" class="headerlink" title="4. 其他情况"></a>4. 其他情况</h3><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_task_launch_modes/04.jpg?raw=true" alt="图4"><br>假设目前有2个任务栈，前台任务栈的情况为 AB，而后台任务栈的情况为 CD，这里假设 CD 的启动模式为 singleTask。 现在请求启动 D，那么整个后台的任务栈都会被切换到前台，这个时候整个后退列表变成了 ABCD。 当用户按 back 键的时候，列表中的 Activity 会一一出栈。</p><h3 id="5-TaskAffinity-属性"><a href="#5-TaskAffinity-属性" class="headerlink" title="5. TaskAffinity 属性"></a>5. TaskAffinity 属性</h3><p>TaskAffinity 参数标识了一个 Activity 所需要的任务栈的名字。 为字符串，且中间必须包含包名分隔符“.”。默认情况下，所有 Activity 所需的任务栈名字为应用包名。</p><p>TashAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用，其他情况下没有意义。</p><blockquote><p>应用 A 启动了应用 B 的某个 Activity 后，如果 Activity 的 allowTaskReparenting 属性为 true 的话，那么当应用 B 被启动后，此 Activity 会直接从应用 A 的任务栈转移到应用 B 的任务栈中。</p></blockquote><p>打个比方就是，应用 A 启动了应用 B 的 ActivityX，然后按 Home 回到桌面，单击应用 B 的图标，这时并不会启动 B 的主 Activity，而是重新显示已经被应用 A 启动的 ActivityX。 这是因为 ActivityX 的 TaskAffinity 值肯定不和应用 A 的任务栈相同（因为包名不同）。 所以当应用  B被启动以后，发现 ActivityX 原本所需的任务栈已经被创建了，所以把 ActivityX 从 A 的任务栈中转移过来了。</p><h3 id="6-设置启动模式"><a href="#6-设置启动模式" class="headerlink" title="6. 设置启动模式"></a>6. 设置启动模式</h3><ol><li>manifest中 设置下的 android:<strong>launchMode</strong> 属性。</li><li>启动 Activity 的 <strong>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</strong> 。</li><li>两种同时存在时，以第二种为准。 第一种方式无法直接为 Activity 添加 <strong>FLAG_ACTIVITY_CLEAR_TOP</strong> 标识，第二种方式无法指定 singleInstance 模式。</li><li>可以通过命令行 adb shell dumpsys activity 命令查看栈中的 Activity 信息。</li></ol><h4 id="Activity-的-Flags"><a href="#Activity-的-Flags" class="headerlink" title="Activity 的 Flags"></a>Activity 的 Flags</h4><p>这些FLAG可以设定启动模式、可以影响Activity的运行状态。</p><ul><li><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><br>具有此标记位的 Activity 启动时，同一个任务栈中位于它上面的 Activity 都要出栈，一般和 FLAG_ACTIVITY_NEW_TASK 配合使用。效果和 singleTask 一样。</p></li><li><p><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</strong><br>如果设置，新的 Activity 不会在最近启动的 Activity 的列表（就是安卓手机里显示最近打开的 Activity 那个系统级的UI）中保存。</p></li></ul><p><br><br></p><h2 id="IntentFilter-匹配规则"><a href="#IntentFilter-匹配规则" class="headerlink" title="IntentFilter 匹配规则"></a>IntentFilter 匹配规则</h2><p>启动Activity分为两种：<br></p><ol><li>显示调用明确指定被启动对象的组件信息，包括包名和类名。<br></li><li>隐式调用不需要明确指定组件信息，需要 Intent 能够匹配目标组件中的 IntentFilter 中所设置的过滤信息。<br></li><li>IntentFilter 中的过滤信息有 action、 category、 data。<br></li><li>只有一个 Intent 同时匹配 action类别、 category类别、 data类别才能成功启动目标 Activity。<br></li><li>一个 Activity 可以有多个 intent-filter ，一个 Intent 只要能匹配任何一组 intent-filter 即可成功启动对应的 Activity。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity is the main entry, should appear in app launcher --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity handles "SEND" actions with text data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND_MULTIPLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.google.panorama360+jpg"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开：</p><ul><li><strong>ACTION_MAIN</strong> 操作指示这是主要入口点，且不要求输入任何 Intent 数据。</li><li><strong>CATEGORY_LAUNCHER</strong> 类别指示此 Activity 的图标应放入系统的应用启动器。 如果 <activity> 元素未使用 icon 指定图标，则系统将使用 <application> 元素中的图标。</application></activity></li></ul><p>这两个元素必须配对使用，Activity 才会显示在应用启动器中。</p><p>第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。 尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent 过滤器之一匹配）的另一应用中直接进入 ShareActivity。</p></blockquote><h3 id="1-action"><a href="#1-action" class="headerlink" title="1. action"></a>1. action</h3><ul><li>action 是一个字符串。 系统预定义了一些，也可自己定义，区分大小写，例如 android.intent.action.SEND。</li><li>一个 intent-filter 可以有多个 aciton，只要 Intent 中的 action 能够和任何一个 action 相同即可成功匹配。匹配是指与 action 的字符串完全一样。</li><li>Intent 中如果没有指定 action，那么匹配失败。</li></ul><h3 id="2-category"><a href="#2-category" class="headerlink" title="2. category"></a>2. category</h3><ul><li>category 是一个字符串。</li><li>Intent 可以没有 category，但是如果你一旦有 category，不管有几个，每个都能够与 intent-filter 中的其中一个 category 相同。</li><li>系统在 startActivity 和 startActivityForResult 的时候，会默认为 Intent 加上 android.intent.category.DEFAULT 这个 category，所以为了我们的 activity能够接收隐式调用，就必须在intent-filter 中加上 android.intent.category.DEFAULT 这个 category。</li></ul><h3 id="3-data"><a href="#3-data" class="headerlink" title="3. data"></a>3. data</h3><ul><li>data 的匹配规则与 action一样，如果 intent-filter 中定义了 data，那么 Intent 中必须要定义可匹配的 data。</li><li><p>intent-filter 中 data 的语法：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:host</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:port</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:pathPrefix</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:mimeType</span>=<span class="string">"string"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Intent中 的 data 有两部分组成： mimeType 和 URI。 mimeType 是指媒体类型，比如 image/jpeg、audio/mpeg4-generic 和 video/* 等，可以表示图片、文本、视频等不同的媒体格式。</p><ul><li><p>URI 的结构： <figure class="highlight xml"><figcaption><span><scheme>://<host>:<port>/[<path></path>|<pathprefix>|<pathpattern>] ```</pathpattern></pathprefix></port></host></scheme></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```Java</span><br><span class="line">//实际例子</span><br><span class="line">content://com.example.project:200/folder/subfolder/etc</span><br><span class="line">http://www.baidu.com:80/search/info</span><br></pre></td></tr></table></figure></p><ol><li>scheme：URI 的模式，比如 http、 file、 content 等，默认值是 file 。</li><li>host：URI 的主机名</li><li>port：URI 的端口号</li><li>path、 pathPattern 和 pathPrefix：这三个参数描述路径信息。<ul><li>path、 pathPattern 可以表示完整的路径信息，其中 pathPattern 可以包含通配符 * ，表示0个或者多个任意字符。</li><li>pathPrefix 只表示路径的前缀信息。</li></ul></li></ol></li><li><p>Intent 指定 data 时，必须调用 setDataAndType 方法， setData 和 setType 会清除另一方的值。</p></li></ul></li></ul><h3 id="4-隐式调用需注意"><a href="#4-隐式调用需注意" class="headerlink" title="4. 隐式调用需注意"></a>4. 隐式调用需注意</h3><ol><li><p>当通过隐式调用启动 Activity 时，没找到对应的 Activity 系统就会抛出 android.content.ActivityNotFoundException 异常，所以需要判断是否有 Activity 能够匹配我们的隐式 Intent。</p><ul><li><p>采用 PackageManager 的 resloveActivity 方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;ResolveInfo&gt; <span class="title">queryIntentActivityies</span><span class="params">(Intent intent, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ResolveInfo <span class="title">resloveActivity</span><span class="params">(Intent intent, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>以上的第二个参数使用 MATCH_DEFAULT_ONLY ，这个标志位的含义是仅仅匹配那些在 intent-filter 中声明了 android.intent.category.DEFAULT 这个 category 的 Activity。 因为如果把不含这个 category 的 Activity 匹配出来了，由于不含 DEFAULT 这个 category 的 Activity 是无法接受隐式 Intent 的从而导致 startActivity 失败。</p></blockquote></li><li><p>采用 Intent 的 resloveActivity 方法</p></li></ul></li><li><p>下面的 action 和 category 用来表明这是一个入口 Activity 并且会出现在系统的应用列表中，二者缺一不可。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html?hl=zh-cn#TaskLaunchModes" target="_blank" rel="noopener">Google官方开发文档-任务和返回栈</a><br><br><a href="https://developer.android.com/guide/components/intents-filters.html" target="_blank" rel="noopener">Google官方开发文档-Intent 和 Intent 过滤器</a><br><br>《Android 开发艺术探索》</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
            <tag> LaunchMode </tag>
            
            <tag> 启动模式 </tag>
            
            <tag> IntentFilter </tag>
            
            <tag> 匹配规则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - Activity 生命周期</title>
      <link href="/2017/04/30/android-life-cycle/"/>
      <url>/2017/04/30/android-life-cycle/</url>
      <content type="html"><![CDATA[<h1 id="Android-Activity-生命周期"><a href="#Android-Activity-生命周期" class="headerlink" title="Android - Activity 生命周期"></a>Android - Activity 生命周期</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为四大组件中我们使用最频繁的 Activity，它的生命周期大家都了解。 然而面试中经常问到可见它的重要性。下面从两个方面来分析一下 Activity 的生命周期和一些需要注意的细节。</p><p>Activity 生命周期图</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_activity_life_cycle/Android-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true" alt="图1"></p><h2 id="典型情况下生命周期分析"><a href="#典型情况下生命周期分析" class="headerlink" title="典型情况下生命周期分析"></a>典型情况下生命周期分析</h2><ol><li><p>一般情况下，当当前 Activity 从<strong>不可见</strong>重新变为<strong>可见</strong>状态时，<strong>onRestart</strong> 方法就会被调用。</p></li><li><p>当用户打开<strong>新的 Activity</strong> 或者<strong>切换到桌面</strong>的时候，回调如下：<strong>onPause</strong> -&gt; <strong>onStop</strong>，但是如果新 Activity 采用了<strong>透明主题</strong>，那么 <strong>onStop</strong> 方法不会被回调。<br>当用户<strong>再次回到原来的 Activity</strong> 时，回调如下：<strong>onRestart</strong> -&gt; <strong>onStart</strong> -&gt; <strong>onResume</strong>。</p></li><li><p><strong>onStart</strong> 和 <strong>onStop</strong> 对应，它们是从 <strong>Activity 是否可见</strong>这个角度来回调的；<br><strong>onPause</strong> 和 <strong>onResume</strong> 方法对应，它们是从 <strong>Activity 是否位于前台</strong>这个角度来回调的。</p></li><li><p>从 Activity A 进入到 Activity B ，回调顺序是 onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在 onPause 方法中做重量级的操作。</p></li></ol><h2 id="异常情况下生命周期分析"><a href="#异常情况下生命周期分析" class="headerlink" title="异常情况下生命周期分析"></a>异常情况下生命周期分析</h2><ol><li><p><strong>onSaveInstanceState</strong> 方法只会出现在 <strong>Activity 被异常终止</strong>的情况下，它的调用时机是在 onStop 之前，它和 onPause 方法没有既定的时序关系，可能在它之前，也可能在它之后。 当 Activity 被重新创建的时候，<strong>onRestoreInstanceState</strong> 会被回调，它的调用时机是 onStart 之后。<br><br>系统只会在 Activity 即将被销毁并且有机会重新显示的情况下才会去调用 onSaveInstanceState 方法。 <br>当 Activity 在异常情况下需要重新创建时，系统会默认为我们保存当前 Activity 的视图结构，并且在 Activity 重启后为我们恢复这些数据。 </p><blockquote><p>比如：文本框中用户输入的数据、 listview 滚动的位置等，这些 view 相关的状态系统都会默认为我们恢复。 </p></blockquote><p>具体针对某一个 view 系统能为我们恢复哪些数据可以查看 view 的源码中的 onSaveInstanceState 和 onRestoreInstanceState 方法。</p></li><li><p>Activity按优先级的分类</p><p> 前台 Activity &gt; 可见但非前台 Activity &gt; 后台 Activity</p></li><li><p>android:configChanges=”xxx” 属性，常用的主要有下面三个选项：</p><blockquote><p>local：设备的本地位置发生了变化，一般指切换了系统语言；</p><p>keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘；</p><p>orientation：屏幕方向发生了变化，比如旋转了手机屏幕。</p></blockquote><p> 配置了 android:<strong>configChanges</strong>=”xxx” 属性之后，Activity就不会在对应变化发生时重新创建，而是调用 Activity 的 <strong>onConfigurationChanged</strong> 方法。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.com/guide/components/activities.html?hl=zh-cn#Lifecycle" target="_blank" rel="noopener">Google官方开发文档-Activity</a><br><br>《Android 开发艺术探索》</p><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
            <tag> LifeCycle </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - 反编译指南</title>
      <link href="/2017/04/28/decompile/"/>
      <url>/2017/04/28/decompile/</url>
      <content type="html"><![CDATA[<h1 id="Android-反编译指南"><a href="#Android-反编译指南" class="headerlink" title="Android - 反编译指南"></a>Android - 反编译指南</h1><h2 id="反编译源码"><a href="#反编译源码" class="headerlink" title="反编译源码"></a>反编译源码</h2><h3 id="1-使用-dex2jar"><a href="#1-使用-dex2jar" class="headerlink" title="1. 使用 dex2jar"></a>1. 使用 dex2jar</h3><p>作用：将 apk 反编译成 java 源码（classes.dex 转化成 jar 文件）</p><p>dex2jar 下载：<a href="https://sourceforge.net/projects/dex2jar" target="_blank" rel="noopener">https://sourceforge.net/projects/dex2jar</a></p><p>下载最新的 dex2jar 并解压</p><h3 id="2-解压-apk-安装包，将-classes-dex-复制-dex2jar-目录下，执行下面命令"><a href="#2-解压-apk-安装包，将-classes-dex-复制-dex2jar-目录下，执行下面命令" class="headerlink" title="2. 解压 apk 安装包，将 classes.dex 复制 dex2jar 目录下，执行下面命令"></a>2. 解压 apk 安装包，将 classes.dex 复制 dex2jar 目录下，执行下面命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2j-dex2jar classes.dex</span><br></pre></td></tr></table></figure><p>Win10 最新 PowerShell 窗口尝试下面命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\d2j-dex2jar.bat .\classes.dex</span><br></pre></td></tr></table></figure><h3 id="3-得到-classes-dex2jar-jar-使用-jd-gui-exe-打开"><a href="#3-得到-classes-dex2jar-jar-使用-jd-gui-exe-打开" class="headerlink" title="3. 得到 classes-dex2jar.jar 使用 jd-gui.exe 打开"></a>3. 得到 classes-dex2jar.jar 使用 jd-gui.exe 打开</h3><p>作用：查看 APK 中 classes.dex 转化成出的 jar 文件，即源码文件</p><p>dex2jar 下载：<a href="http://jd.benow.ca/" target="_blank" rel="noopener">http://jd.benow.ca/</a></p><h2 id="反编译资源文件"><a href="#反编译资源文件" class="headerlink" title="反编译资源文件"></a>反编译资源文件</h2><h3 id="1-使用-apktool"><a href="#1-使用-apktool" class="headerlink" title="1. 使用 apktool"></a>1. 使用 apktool</h3><p>作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看</p><p>apktool 下载：<a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">https://bitbucket.org/iBotPeaches/apktool/downloads/</a></p><p>下载最新的 apktool 并解压</p><h3 id="2-将-apk-安装包复制到-apktool-目录下，执行命令"><a href="#2-将-apk-安装包复制到-apktool-目录下，执行命令" class="headerlink" title="2. 将 apk 安装包复制到 apktool 目录下，执行命令"></a>2. 将 apk 安装包复制到 apktool 目录下，执行命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool.jar d -f xxx.apk -o res</span><br></pre></td></tr></table></figure><blockquote><p>注意：apktool.bat 与 apktool.jar 文件名为 apktool</p></blockquote><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 逆向 </tag>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - 屏幕适配全攻略</title>
      <link href="/2017/04/26/multi-screen-support/"/>
      <url>/2017/04/26/multi-screen-support/</url>
      <content type="html"><![CDATA[<h1 id="Android-屏幕适配全攻略"><a href="#Android-屏幕适配全攻略" class="headerlink" title="Android - 屏幕适配全攻略"></a>Android - 屏幕适配全攻略</h1><h2 id="一、Android-屏幕碎片化"><a href="#一、Android-屏幕碎片化" class="headerlink" title="一、Android 屏幕碎片化"></a>一、Android 屏幕碎片化</h2><p>由于 Android 系统的开发性，任何用户、开发者、OEM厂商、运营商都可以对 Android 进行定制，修改成他们想要的样子。各大厂商、开发者的标准不统一，所以就造成了 Android 系统碎片化。</p><p>但是这种“碎片化”到底到达什么程度呢？</p><p>下面这张图片所显示的内容足以充分说明当今 Android 系统碎片化问题的严重性，因为该图片中的每一个矩形都代表着一种 Android 设备。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/08.png?raw=true" alt="图08"></p><p>而随着支持 Android 系统的设备(手机、平板、电视、手表)的增多，设备碎片化、品牌碎片化、系统碎片化、传感器碎片化和屏幕碎片化的程度也在不断地加深。而我们今天要探讨的，则是对我们开发影响比较大的——屏幕的碎片化。</p><p>下面这张图是 Android 屏幕尺寸的示意图，在这张图里面，蓝色矩形的大小代表不同尺寸，颜色深浅则代表所占百分比的大小。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/06.png?raw=true" alt="图06"></p><p>而与之相对应的，则是下面这张图。这张图显示了 IOS 设备所需要进行适配的屏幕尺寸和占比。</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/07.png?raw=true" alt="图07"></p><p>当然，这张图片只是 4, 4s, 5, 5c, 5s 和平板的尺寸，现在还应该加上新推出的 iphone6 和 plus，但是和 Android 的屏幕碎片化程度相比而言，还是差的太远。</p><blockquote><p>Android屏幕的碎片化如此严重，所以我们不得不进行屏幕的适配，如何面对如此多的屏幕进行适配？下面结合Google官方开发文档讨论下最优的解决方案。</p></blockquote><h2 id="二、术语和概念"><a href="#二、术语和概念" class="headerlink" title="二、术语和概念"></a>二、术语和概念</h2><h4 id="1-什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？"><a href="#1-什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？" class="headerlink" title="1. 什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？"></a>1. 什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？</h4><p>屏幕尺寸</p><blockquote><p><strong>按屏幕对角测量的实际物理尺寸。</strong>单位是英寸(inch)，1英寸 = 2.54厘米。</p></blockquote><p>屏幕分辨率</p><blockquote><p><strong>屏幕上物理像素的总数。</strong>单位是 px，1px = 1像素点，一般是纵向像素×横向像素，如1280×720。</p></blockquote><p>每英寸点数</p><blockquote><p>是指每英寸多少点。单位是 dpi，即 “dot per inch” 的缩写，是打印机、鼠标等设备分辨率的单位。</p></blockquote><p>屏幕像素密度</p><blockquote><p><strong>所表示的是每英寸所拥有的像素数量。</strong>单位是ppi，即 “Pixel per inch“ 的缩写，每英寸像素点数。<strong>针对显示器的设计时，dpi = ppi。</strong></p></blockquote><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/01.png?raw=true" alt="图01"></p><blockquote><p>例如：计算Nexus5的屏幕像素密度：屏幕尺寸：4.95 inch、分辨率：1920×1080，屏幕像素密度(ppi)：445</p></blockquote><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/02.png?raw=true" alt="图02"></p><h4 id="2-什么是-dp、dip、dpi、sp、px？之间的关系是什么？"><a href="#2-什么是-dp、dip、dpi、sp、px？之间的关系是什么？" class="headerlink" title="2. 什么是 dp、dip、dpi、sp、px？之间的关系是什么？"></a>2. 什么是 dp、dip、dpi、sp、px？之间的关系是什么？</h4><p>dip/dp</p><blockquote><p>在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。</p><p>Density Independent Pixels(密度无关像素)的缩写。<br>以160dpi为基准，1dp = 1px。单位转换： px = dp * (dpi / 160)。</p></blockquote><p>dpi</p><blockquote><p>屏幕像素密度的单位，“dot per inch” 的缩写</p></blockquote><p>px</p><blockquote><p>像素，物理上的绝对单位</p></blockquote><p>sp</p><blockquote><p>Scale-Independent Pixels 的缩写，可以根据文字大小首选项自动进行缩放。</p><p>Google 推荐我们使用 12s p以上的大小，通常可以使用 12sp，14sp，18sp，22sp，最好不要使用<strong>奇数</strong>和<strong>小数</strong>。</p></blockquote><h4 id="3-什么是-mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？"><a href="#3-什么是-mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？" class="headerlink" title="3. 什么是 mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？"></a>3. 什么是 mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？</h4><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">像素密度范围</th><th style="text-align:left">图片大小</th></tr></thead><tbody><tr><td style="text-align:left">mdpi(中)</td><td style="text-align:left">120dp~160dp</td><td style="text-align:left">48×48px</td></tr><tr><td style="text-align:left">hdpi(高)</td><td style="text-align:left">160dp~240dp</td><td style="text-align:left">72×72px</td></tr><tr><td style="text-align:left">xhdpi(超高)</td><td style="text-align:left">240dp~320dp</td><td style="text-align:left">96×96px</td></tr><tr><td style="text-align:left">xxhdpi(超超高)</td><td style="text-align:left">320dp~480dp</td><td style="text-align:left">144×144px</td></tr><tr><td style="text-align:left">xxxhdpi(超超超高)</td><td style="text-align:left">480dp~640dp</td><td style="text-align:left">192×192px</td></tr></tbody></table><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/03.png?raw=true" alt="图03"></p><blockquote><p>在Google官方开发文档中，说明了 mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi = 2：3：4：6：8 的尺寸比例进行缩放。例如，一个图标的大小为 48×48dp，表示在mdpi上，实际大小为 48×48px，在 hdpi 像素密度上，实际尺寸为 mdpi 上的1.5倍，即 72×72px，以此类推。</p></blockquote><h4 id="4-支持的屏幕范围"><a href="#4-支持的屏幕范围" class="headerlink" title="4. 支持的屏幕范围"></a>4. 支持的屏幕范围</h4><p>四种通用尺寸：小、正常、 大 和超大。</p><p>六种通用的密度：</p><ul><li>ldpi（低）~120dpi<br></li><li>mdpi（中）~160dpi<br></li><li>hdpi（高）~240dpi<br></li><li>xhdpi（超高）~320dpi<br></li><li>xxhdpi（超超高）~480dpi<br></li><li>xxxhdpi（超超超高）~640dpi</li></ul><p>屏幕尺寸与屏幕密度对比：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/04.png?raw=true" alt="图04"><br></p><ul><li>超大屏幕至少为 960dp x 720dp<br></li><li>大屏幕至少为 640dp x 480dp<br></li><li>正常屏幕至少为 470dp x 320dp<br></li><li>小屏幕至少为 426dp x 320dp</li></ul><h2 id="三、解决方案-支持各种屏幕尺寸"><a href="#三、解决方案-支持各种屏幕尺寸" class="headerlink" title="三、解决方案 - 支持各种屏幕尺寸"></a>三、解决方案 - 支持各种屏幕尺寸</h2><h4 id="1-使用配置限定符"><a href="#1-使用配置限定符" class="headerlink" title="1.  使用配置限定符"></a>1.  使用配置限定符</h4><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/05.jpg?raw=true" alt="图05"></p><blockquote><p>这里只是展示了常用的一些配置限定符，具体用法和详情请参阅：<a href="https://developer.android.com/guide/practices/screens_support.html?hl=zh-cn#qualifiers" target="_blank" rel="noopener">Google官方开发文档-使用配置限定符</a></p></blockquote><h4 id="2-使用-NinePatch-9-图片"><a href="#2-使用-NinePatch-9-图片" class="headerlink" title="2. 使用 NinePatch(.9) 图片"></a>2. 使用 NinePatch(.9) 图片</h4><p>什么是.9图？</p><blockquote><p>NinePatch 是一种 PNG 图像，在其中可定义当视图中的内容超出正常图像边界时 Android 缩放的可拉伸区域。 后缀以 <strong>.9.png</strong> 结尾，命名格式为：xxx.9.png。<br><br>如：普通图：ic_launcher<strong>.png</strong> <br><br>.9图 为：ic_launcher<strong>.9.png</strong> <br><br>文件位置： res/drawable/filename.9.png 文件名用作资源 ID。</p></blockquote><p>怎么制作.9图？</p><blockquote><p>使用 Photoshop（不推荐）<br><br>使用 Android SDK 自带工具，在 …\Android\SDK\tools\ 下名字为 draw9patch 的文件。<br><br>使用 Android Studio 同上。</p></blockquote><p>draw9patch如图 ：</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/09.png?raw=true" alt="图09"><br><br><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/10.png?raw=true" alt="图10"><br></p><p>拉伸区域</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/11.png?raw=true" alt="图11"><br></p><blockquote><p><strong>红色框区域</strong>：表示纵向拉伸的区域，也就是说，当图片需要纵向拉伸的时候它会只指定拉伸红色区域，其他区域在纵向是不会拉伸的。</p><p><strong>绿色框区域</strong>：表示横向拉伸的区域，也就是说，当图片需要横向拉伸的时候它会只指定拉伸绿色区域，其他区域在横向是不会拉伸的。</p><p>显然红色和绿色相交的部分是既会进行横向拉伸也会进行纵向拉伸的。</p></blockquote><p>前景的显示区域</p><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/12.png?raw=true" alt="图12"><br></p><blockquote><p><strong>蓝色区域</strong>：表示前景能显示的纵向范围。即前景的最上面可以显示到什么地方，最下面可以显示的什么地方。</p><p><strong>黄色区域</strong>：表示前景能显示的横向范围。即前景的最左边可以显示到什么地方，最右边可以显示的什么地方。</p><p>蓝色和黄色相交部分：表示整个前景能显示的区域。一个区域是矩形的，蓝色规定了上下边界，黄色规定了左右边界，两者共同当然也就规定了一个矩形区域。</p></blockquote><h4 id="3-可绘制的资源文件-Drawable"><a href="#3-可绘制的资源文件-Drawable" class="headerlink" title="3.可绘制的资源文件 Drawable"></a>3.可绘制的资源文件 Drawable</h4><blockquote><p>请参考：<a href="https://developer.android.com/guide/topics/resources/drawable-resource.html" target="_blank" rel="noopener">Google官方开发文档-可绘制对象资源</a></p></blockquote><h4 id="4-最佳做法"><a href="#4-最佳做法" class="headerlink" title="4. 最佳做法"></a>4. 最佳做法</h4><ol><li>在 XML 布局文件中指定尺寸时使用 wrap_content、 match_parent 或 dp 单位 。</li><li>不要在应用代码中使用硬编码的像素值 。</li><li>不要使用 AbsoluteLayout（已弃用） 。</li><li>为不同屏幕密度提供替代位图可绘制对象 。</li></ol><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_screens_support/13.png?raw=true" alt="图13"><br></p><blockquote><p>表格里面列出了目前主流的 Android 手机设备分辨率对应的 dpi 缩放级别。<br><br>一般设计师会以 <strong>1920 x 1080</strong> 来设计效果图，那么<strong>只需要将效果图测量出来的 px值 填入 第6行-px列</strong> 中即可自动计算出所需的 <strong>dp/sp 的值</strong>。<br><br>通常情况下以 <strong>1280 x 720</strong> 的效果图来写布局是比较好的方式，因为<strong>测量出来的 px值是 dp/sp 的两倍</strong>，方便计算。<br><br>表格下载：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2.xls" target="_blank" rel="noopener">Android屏幕适配单位转换.xls</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/guide/practices/screens_support.html?hl=zh-cn#DeclaringTabletLayouts" target="_blank" rel="noopener">https://developer.android.com/guide/practices/screens_support.html?hl=zh-cn#DeclaringTabletLayouts</a></li><li><a href="http://blog.jeswang.org/blog/2013/08/07/ppi-vs-dpi-you-shi-yao-qu-bie/" target="_blank" rel="noopener">http://blog.jeswang.org/blog/2013/08/07/ppi-vs-dpi-you-shi-yao-qu-bie/</a></li><li><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023" target="_blank" rel="noopener">http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023</a></li><li><a href="http://www.cnblogs.com/vanezkw/archive/2012/07/19/2599092.html" target="_blank" rel="noopener">http://www.cnblogs.com/vanezkw/archive/2012/07/19/2599092.html</a></li></ul><h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 屏幕适配 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
