<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android - Handler 消息机制]]></title>
    <url>%2F2017%2F05%2F15%2Fandroid-handler%2F</url>
    <content type="text"><![CDATA[Android - Handler 消息机制概述Android 的消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。 Handler 的主要作用是将某个任务切换到 Handler 所在的线程中去执行。 Handler机制Handler工作流程 Looper 每个线程中最多只能有一个 Looper 对象，由 Looper 来管理此线程里的 MessageQueue (消息队列)。 可以通过 Looper.myLooper() 获取当前线程的 Looper 实例，通过 Looper.getMainLooper() 获取主（UI）线程的 Looper 实例。 Lopper 会以无限循环的形式去查找是否有新消息，如果有就处理消息，否则就一直等待着。 Handler 你可以构造 Handler 对象来与 Looper 沟通，通过 push 发送新消息到 MessageQueue 里；或者通过 handleMessage 接收 Looper 从 MessageQueue 取出来消息。 MessageQueue MessageQueue是一个消息队列，内部存储了一组消息，以队列的形式对外提供插入和删除的工作，内部采用单链表的数据结构来存储消息列表。 ActivityThread 我们经常提到的主线程，也叫UI线程，它就是 ActivityThread，主线程启动会默认初始化一个 Looper 并创建 Handler。 一个线程中只有一个 Looper 实例，一个 MessageQueue 实例，可以有多个 Handler 实例。 ThreadLocal 一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获得数据。 对于 Handler 来说，它需要获取当前线程的 Looper ,而 Looper 的作用于就是线程并且不同的线程具有不同的 Looper ，通过 ThreadLocal 可以轻松实现线程中的存取。 ThreadLocal原理：不同线程访问同一个ThreadLoacl的get方法，ThreadLocal的get方法会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找对应的Value值。 源码分析通过上面分析我们知道使用 Handler 之前必须先调用 Looper.prepare(); 进行初始化，我们先看下 Looper 的源码。 1. Looper 工作原理先看一下 Looper 工作流程 Looper 源码最上面的注释里有一个使用示例如下，可以清晰的看出 Looper 的使用方法。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare();//先初始化 Looper mHandler = new Handler() &#123;//创建 Handler public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop();//启用 Looper 的 loop 方法开启消息轮询 &#125;&#125; 接续看一下 Looper 的完整源码，分析下工作过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public final class Looper &#123; static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //每个线程都会有一个ThreadLocal 用来保存 Looper对象（里面包含了主线程和 MessageQueue） private static Looper sMainLooper; // 主线程的 Looper final MessageQueue mQueue;//保存消息队列 final Thread mThread;//保存主线程 public static void prepare() &#123;//为当前线程创建 Looper prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; //一个线程只能有一个 Looper， 否则抛出异常 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//将创建的 Looper 放入 ThreadLocal &#125; //初始化主线程的 Looper public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; //获取主线程的 Looper public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125; &#125; //在当前线程中开启轮询 public static void loop() &#123; final Looper me = myLooper();//从 ThreadLocal 中取出当前线程的 Looper 对象 if (me == null) &#123; //Looper 没有调用 Looper.prepare() 初始化，抛出异常 throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue;//从 Looper 对象中取出消息队列 for (;;) &#123;//死循环 Message msg = queue.next(); // 不断的取出消息 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); //取出消息的 target (也就是 Handler)，执行分发消息的操作 &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked();//消息已经分发，进行回收操作 &#125; &#125; public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();//从 ThreadLocal 中取出当前线程的 Looper 对象 &#125; private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//创建消息队列 mThread = Thread.currentThread();//保存当前线程 &#125; public void quit() &#123; mQueue.quit(false);//直接退出消息循环，不管是否还有消息 &#125; public void quitSafely() &#123; mQueue.quit(true);//执行完所有的消息，退出消息循环 &#125; ...&#125; 2. MessageQueue 工作原理在 Looper 中创建了 MessageQueue，我们接着看下 MessageQueue 是怎么工作的。 MessageQueue 工作流程 MessageQueue的构造方法。 123456MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //构造函数，quitAllowed 用来标识是否允许退出。 //主线程是不允许退出的（不然会退出整个程序），子线程可以退出。 mPtr = nativeInit();&#125; 然后我们再看一下 MessageQueue.enqueueMessage() 的源码，分析下是怎么添加消息的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 如果消息队列里面没有消息，或者消息的执行时间比里面的消息早，就把这条消息设置成第一条消息。 //一般不会出现这种情况，因为系统一定会有很多消息。 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123;//如果消息队列里面有消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123;//找到消息队列里面的最后一条消息 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;//把消息添加到最后 &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 知道了怎么添加消息，我们再看下 MessageQueue.next() 方法是怎么取出消息的，也就是 Looper.loop() 方法中不断取消息的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages;//拿到当前的消息队列 if (msg != null &amp;&amp; msg.target == null) &#123; //处理异步的消息，暂不讨论 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; //取出一条消息，消息队列往后移动一个 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse();//标记为已使用 return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ... &#125;&#125; 我们知道 MessageQueue 是个链表结构，里面保存的是 Message，我们再看下 Message 是什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class Message implements Parcelable &#123; public int what;//消息类型，标识消息的作用 public int arg1;//整型参数1 public int arg2;//整型参数2 public Object obj;//复杂对象参数 public Messenger replyTo; public int sendingUid = -1; /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;//标记消息已使用 /** If set message is asynchronous */ /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;//标记消息是否异步 /** Flags to clear in the copyFrom method */ /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; /*package*/ int flags;//消息当前标记 /*package*/ long when;//消息执行时间 /*package*/ Bundle data; /*package*/ Handler target;//Handler 用于执行 handleMessage(); /*package*/ Runnable callback;//消息是一个Runnable // sometimes we store linked lists of these things /*package*/ Message next;//下一个消息 private static final Object sPoolSync = new Object();//控制并发访问 private static Message sPool;//消息池 private static int sPoolSize = 0;//消息池数量 private static final int MAX_POOL_SIZE = 50;//消息最大数量 ...&#125; 3. Handler 工作原理在 Message 中我们看到了 target 是一个 Handler，我们看下 Handler 是怎么与 Looper 和 MessageQueue 一起搭配工作的。 看一下 Handler 的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class Handler &#123; public interface Callback &#123; public boolean handleMessage(Message msg); &#125; public void handleMessage(Message msg) &#123;&#125; /** * 消息处理 */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123;//如果消息体是 Runnable 就执行 run() handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //如果创建 Handler 时传入了 Callback，就执行 Callback 里面的逻辑 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg);//如果上述两种都没有实现，就执行 handleMessage 的逻辑 &#125; &#125; public Handler() &#123; this(null, false); &#125; public Handler(Callback callback) &#123; this(callback, false); &#125; public Handler(Looper looper) &#123;//可以指定关联哪个线程的 Looper this(looper, null, false); &#125; public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false); &#125; public Handler(boolean async) &#123; this(null, async); &#125; /** * 主线程调用的构造方法，主线程已经调用了 Looper.prepareMainLooper(); * * @hide */ public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//取出主线程的 Looper if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//把 Handler 的 mQueue 指向 Looper 中的 mQueue mCallback = callback; mAsynchronous = async; &#125; /** * 第二种构造方法，专门给子线程中创建 Handler 时使用的 * * @hide */ public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; //发送 Runnable 消息 public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; //一般更新 UI 时发送的消息，延时时间为0 public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; //发送延时消息 public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; //发送指定时间发送的消息 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; //把字节传入 Message 中一起发送 //Looper 中需要使用 Handler 来执行 dispatchMessage 方法 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125;&#125; 4. ActivityThread 创建默认的 Handler上面说过，ActivityThread 主线程默认是有一个 Handler 的，我们来看一下主线程是怎么创建默认的 Handler 的。 我们看一下 ActivityThread 类中的 main 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser();//准备一些相关环境，给我们的组件启动 // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper();//初始化主线程 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//开启消息轮询，不断取出消息 throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 在 Activity 可以直接用 runOnUiThread() 来使用默认的 Handler 发送消息，我们来看下它是怎么实现的。 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123;//非主线程，发送 Runnable 消息 mHandler.post(action); &#125; else &#123;//在主线程中直接执行 run() action.run(); &#125;&#125; 5. HandlerThread 异步消息处理机制 HandlerThread 继承了 Thread，是一种可以使用 Handler 的 Thread； 在 run 方法中通过 looper.prepare() 来开启消息循环，这样就可以在 HandlerThread 中创建Handler了； 外界可以通过一个 Handler 的消息方式来通知 HandlerThread 来执行具体任务；确定不使用之后，可以通过 quit 或 quitSafely 方法来终止线程执行。 先分析一下 HandlerThread 的源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class HandlerThread extends Thread &#123; //线程的优先级 int mPriority; //线程的id int mTid = -1; //一个与Handler关联的Looper对象 Looper mLooper; public HandlerThread(String name) &#123; super(name); //设置优先级为默认线程 mPriority = android.os.Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; //可重写方法，Looper.loop之前在线程中需要处理的其他逻辑在这里实现 protected void onLooperPrepared() &#123; &#125; //HandlerThread线程的run方法 @Override public void run() &#123; //获取当前线程的id mTid = Process.myTid(); //创建Looper对象 //这就是为什么我们要在调用线程的start()方法后才能得到Looper(Looper.myLooper不为Null) Looper.prepare(); //同步代码块，当获得mLooper对象后，唤醒所有线程 synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; //设置线程优先级 Process.setThreadPriority(mPriority); //Looper.loop之前在线程中需要处理的其他逻辑 onLooperPrepared(); //建立了消息循环 Looper.loop(); //一般执行不到这句，除非quit消息队列 mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; //线程死了 return null; &#125; //同步代码块，正好和上面run方法中同步块对应 //只要线程活着并且mLooper为null，则一直等待 // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; //返回线程id return mTid; &#125;&#125; HandlerThread 使用代码示例 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private HandlerThread mHandlerThread = null; private Handler mThreadHandler = null; private Handler mUiHandler = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandlerThread = new HandlerThread("HandlerWorkThread"); //必须在实例化mThreadHandler之前调运start方法，原因上面源码已经分析了 mHandlerThread.start(); //将当前mHandlerThread子线程的Looper传入mThreadHandler，使得 //mThreadHandler的消息队列依赖于子线程（在子线程中执行） mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, "在子线程中处理！id="+Thread.currentThread().getId()); //从子线程往主线程发送消息 mUiHandler.sendEmptyMessage(0); &#125; &#125;; mUiHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, "在UI主线程中处理！id="+Thread.currentThread().getId()); &#125; &#125;; //从主线程往子线程发送消息 mThreadHandler.sendEmptyMessage(1); &#125;&#125; 总结到此 Handler 消息机制的源码已经分析完了，相信你一定明白了 Handler 消息机制。一句话，每个线程可以创建一个 Looper ，每个 Looper 轮询着一个 MessageQueue 不断取出消息，有消息则回调给 Handler，Handler 负责向 MessageQueue 中发送消息和处理回调的消息来完成线程之间的转换。 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - IPC 多进程]]></title>
    <url>%2F2017%2F05%2F08%2Fandroid-ipc%2F</url>
    <content type="text"><![CDATA[Android - IPC 多进程概述IPC 即 Inter-Process Communication，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。 线程是 CPU 调度的最小单元，是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上是指一个程序或者应用。进程与线程是包含与被包含的关系。一个进程可以包含多个线程。最简单的情况下一个进程只有一个线程，即主线程（例如 Android 的 UI 线程）。 任何操作系统都需要有相应的 IPC 机制。在 Android 中，IPC 的使用场景大概有以下： 有些模块由于特殊原因需要运行在单独的进程中。 通过多进程来获取多份内存空间。 当前应用需要向其他应用获取数据。 1. 开启多进程模式给四大组件在Manifest中指定 android:process 属性。这个属性的值就是进程名。1234&lt;service android:name=".service.RemoteService" android:process=":remote"&gt;&lt;/service&gt; tips：使用 adb shell ps 或 adb shell ps|grep 包名 查看当前所存在的进程信息。 2. 多线程模式的运行机制Android 为每个进程都分配了一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，导致不同的虚拟机访问同一个类的对象会产生多份副本。例如不同进程的 Activity 对静态变量的修改，对其他进程不会造成任何影响。所有运行在不同进程的四大组件，只要它们之间需要通过内存在共享数据，都会共享失败。四大组件之间不可能不通过中间层来共享数据。 多进程会带来以下问题： 静态成员和单例模式完全失效。 线程同步锁机制完全失效。这两点都是因为不同进程不在同一个内存空间下，锁的对象也不是同一个对象。 SharedPreferences 的可靠性下降。SharedPreferences 底层是 通过读/写 XML 文件实现的，并发读/写会导致一定几率的数据丢失。 Application 会多次创建。 由于系统创建新的进程的同时分配独立虚拟机，其实这就是启动一个应用的过程。在多进程模式中，不同进程的组件拥有独立的虚拟机、Application以及内存空间。实现跨进程的方式有很多： Intent传递数据。 共享文件和SharedPreferences。 基于Binder的Messenger和AIDL。 Socket。 3. BinderAndroid 中进程间通讯的核心就是 Binder 机制，强烈建议了解一下 Binder 机制。 Android Binder 进程间通讯 4. Android 中的 IPC 方式主要有以下方式： Intent 中附加 extras 来传递消息 共享文件 Binder 方式 四大组件之一的 ContentProvider Socket 1. 使用Bundle四大组件中的三大组件（Activity、Service、Receiver）都支持在 Intent 中传递 Bundle 数据。Bundle 实现了 Parcelable 接口，**当我们在一个进程中启动了另一个进程的 Activity、Service、Receiver，可以再 Bundle 中附加我们需要传输给远程进程的消息并通过 Intent 发送出去。被传输的数据必须能够被序列化。 2. 使用文件共享一些概念： 两个进程通过读写同一个文件来交换数据。还可以通过 ObjectOutputStream / ObjectInputStream 序列化一个对象到文件中，或者在另一个进程从文件中反序列这个对象。 注意：反序列化得到的对象只是内容上和序列化之前的对象一样，本质是两个对象。 文件并发读写会导致读出的对象可能不是最新的，并发写的话那就更严重了。所以文件共享方式适合对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写问题。 SharedPreferences 底层实现采用XML文件来存储键值对。系统对它的读/写有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对它的读/写变得不可靠，面对高并发读/写时 SharedPreferences 有很大几率丢失数据，因此不建议在IPC中使用 SharedPreferences 。 3. 使用MessengerMessenger 可以在不同进程间传递 Message 对象。是一种轻量级的 IPC 方案，底层实现是 AIDL。 具体使用时，分为服务端和客户端： 服务端：创建一个 Service 来处理客户端请求，同时创建一个 Handler 并通过它来创建一个Messenger，然后再 Service 的 onBind 中返回 Messenger 对象底层的 Binder 即可。 1private final Messenger mMessenger = new Messenger (new xxxHandler()); 客户端：绑定服务端的 Sevice，利用服务端返回的 IBinder 对象来创建一个 Messenger，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。 总而言之，就是客户端和服务端 拿到对方的 Messenger 来发送 Message 。只不过客户端通过 bindService 而服务端通过 message.replyTo 来获得对方的Messenger。 Messenger中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。 4. 使用AIDL如果有大量的并发请求，使用 Messenger 就不太适合，同时如果需要跨进程调用服务端的方法，Messenger 就无法做到了。这时我们可以使用AIDL。 流程如下： 服务端需要创建 Service来监听客户端请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在AIDL文件中声明，最后在Service中实现这个AIDL接口即可。 客户端首先绑定服务端的 Service，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，接着就可以调用 AIDL 中的方法了。 注意事项： AIDL 支持的数据类型： 基本数据类型、String、CharSequence List：只支持 ArrayList，里面的每个元素必须被AIDL支持 Map：只支持 HashMap，里面的每个元素必须被AIDL支持 Parcelable 所有的AIDL接口本身也可以在AIDL文件中使用 自定义的 Parcelable 对象和 AIDL 对象，不管它们与当前的 AIDL 文件是否位于同一个包，都必须显式 import 进来。 如果 AIDL 文件中使用了自定义的 Parcelable 对象，就必须新建一个和它同名的 AIDL 文件，并在其中声明它为 Parcelable 类型。 12package com.ryg.chapter_2.aidl;parcelable Book; AIDL接口中的参数除了基本类型以外都必须表明方向in/out。AIDL接口文件中只支持方法，不支持声明静态常量。建议把所有和AIDL相关的类和文件放在同一个包中，方便管理。 1void addBook(in Book book); AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接时，管理数据的集合直接采用 CopyOnWriteArrayList 来进行自动线程同步。类似的还有 ConcurrentHashMap 。 因为客户端的 listener 和服务端的 listener 不是同一个对象，所以 RecmoteCallbackList 是系统专门提供用于删除跨进程 listener 的接口，支持管理任意的 AIDL 接口，因为所有 AIDL 接口都继承自 IInterface 接口。 1public class RemoteCallbackList&lt;E extends IInterface&gt; 它内部通过一个Map接口来保存所有的 AIDL 回调，这个Map的key是 IBinder 类型，value是 Callback 类型。当客户端解除注册时，遍历服务端所有listener，找到和客户端 listener 具有相同 Binder 对象的服务端 listenr 并把它删掉。 客户端 RPC 的时候线程会被挂起，由于被调用的方法运行在服务端的 Binder 线程池中，可能很耗时，不能在主线程中去调用服务端的方法。 5. 使用ContentProvider ContentProvider 是四大组件之一，其底层实现和 Messenger 一样是 Binder。ContentProvider 天生就是用来进程间通信，只需要实现一个自定义或者系统预设置的 ContentProvider，通过 ContentResolver 的 query、update、insert 和 delete 方法即可。 创建 ContentProvider，只需继承 ContentProvider 实现 onCreate 、 query 、 update 、 insert 、 getType 六个抽象方法即可。除了 onCreate 由系统回调并运行在主线程，其他五个方法都由外界调用并运行在Binder线程池中。 6. 使用SocketSocket 可以实现计算机网络中的两个进程间的通信，当然也可以在本地实现进程间的通信。服务端 Service 监听本地端口，客户端连接指定的端口，建立连接成功后，拿到 Socket 对象就可以向服务端发送消息或者接受服务端发送的消息。 5. 具体实现参考代码： https://github.com/jeanboydev/Android-AIDLTest 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Activity LaunchMode 启动模式 & IntentFilter 匹配规则]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid-launch-mode-and-intent-filter%2F</url>
    <content type="text"><![CDATA[Android - Activity LaunchMode 启动模式 &amp; IntentFilter 匹配规则概述每个应用都会有多个 Activity，Android 中使用栈来管理 Activity。 Activity 的启动模式目前有四种：standard、singleTop、singleTask、singleIntance。 Activity 启动模式1. standard 标准模式，也就是系统的默认模式。 每次启动都会重新创建一个实例，不管这个 Activity 在栈中是否已经存在。 谁启动了这个 Activity，那么 Activity 就运行在启动它的那个 Activity 所在的栈中。 用 Application 去启动 Activity 时会报错，提示非 Activity 的 Context没有所谓的任务栈。解决办法是为需要启动的 Activity 指定 FLAG_ACTIVITY_NEW_TASK 标志位，这样就会为它创建一个新的任务栈。 2. singleTop 栈顶复用模式，在这种模式下，如果新 Activity 位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时回调 onNewIntent 方法。 如果新 Activity 已经存在但不是位于栈顶，那么新 Activity 仍然会被创建。 3. singleTask &amp; singleIntance singleTask 栈内复用模式，这是一种单实例模式，在这种模式下，只要 Activity 在栈中存在，那么多次启动这个 Activity 都不会重新创建实例，同时也会回调 onNewIntent 方法。 同时会导致在 Activity 之上的栈内 Activity 出栈。 如果 Activity 不存在重新创建。 singleIntance 单实例模式，这是一种加强的 singleTask 模式。 具有 singleTask 模式的所有特性外，同时具有此模式的 Activity 只能单独的位于一个任务栈中。 4. 其他情况假设目前有2个任务栈，前台任务栈的情况为 AB，而后台任务栈的情况为 CD，这里假设 CD 的启动模式为 singleTask。 现在请求启动 D，那么整个后台的任务栈都会被切换到前台，这个时候整个后退列表变成了 ABCD。 当用户按 back 键的时候，列表中的 Activity 会一一出栈。 5. TaskAffinity 属性TaskAffinity 参数标识了一个 Activity 所需要的任务栈的名字。 为字符串，且中间必须包含包名分隔符“.”。默认情况下，所有 Activity 所需的任务栈名字为应用包名。 TashAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用，其他情况下没有意义。 应用 A 启动了应用 B 的某个 Activity 后，如果 Activity 的 allowTaskReparenting 属性为 true 的话，那么当应用 B 被启动后，此 Activity 会直接从应用 A 的任务栈转移到应用 B 的任务栈中。 打个比方就是，应用 A 启动了应用 B 的 ActivityX，然后按 Home 回到桌面，单击应用 B 的图标，这时并不会启动 B 的主 Activity，而是重新显示已经被应用 A 启动的 ActivityX。 这是因为 ActivityX 的 TaskAffinity 值肯定不和应用 A 的任务栈相同（因为包名不同）。 所以当应用 B被启动以后，发现 ActivityX 原本所需的任务栈已经被创建了，所以把 ActivityX 从 A 的任务栈中转移过来了。 6. 设置启动模式 manifest中 设置下的 android:launchMode 属性。 启动 Activity 的 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 。 两种同时存在时，以第二种为准。 第一种方式无法直接为 Activity 添加 FLAG_ACTIVITY_CLEAR_TOP 标识，第二种方式无法指定 singleInstance 模式。 可以通过命令行 adb shell dumpsys activity 命令查看栈中的 Activity 信息。 Activity 的 Flags这些FLAG可以设定启动模式、可以影响Activity的运行状态。 FLAG_ACTIVITY_CLEAR_TOP具有此标记位的 Activity 启动时，同一个任务栈中位于它上面的 Activity 都要出栈，一般和 FLAG_ACTIVITY_NEW_TASK 配合使用。效果和 singleTask 一样。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS如果设置，新的 Activity 不会在最近启动的 Activity 的列表（就是安卓手机里显示最近打开的 Activity 那个系统级的UI）中保存。 IntentFilter 匹配规则启动Activity分为两种： 显示调用明确指定被启动对象的组件信息，包括包名和类名。 隐式调用不需要明确指定组件信息，需要 Intent 能够匹配目标组件中的 IntentFilter 中所设置的过滤信息。 IntentFilter 中的过滤信息有 action、 category、 data。 只有一个 Intent 同时匹配 action类别、 category类别、 data类别才能成功启动目标 Activity。 一个 Activity 可以有多个 intent-filter ，一个 Intent 只要能匹配任何一组 intent-filter 即可成功启动对应的 Activity。 12345678910111213141516171819202122232425&lt;activity android:name="MainActivity"&gt; &lt;!-- This activity is the main entry, should appear in app launcher --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name="ShareActivity"&gt; &lt;!-- This activity handles "SEND" actions with text data --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; &lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&gt; &lt;data android:mimeType="image/*"/&gt; &lt;data android:mimeType="video/*"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开： ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。 CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。 如果 元素未使用 icon 指定图标，则系统将使用 元素中的图标。 这两个元素必须配对使用，Activity 才会显示在应用启动器中。 第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。 尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent 过滤器之一匹配）的另一应用中直接进入 ShareActivity。 1. action action 是一个字符串。 系统预定义了一些，也可自己定义，区分大小写，例如 android.intent.action.SEND。 一个 intent-filter 可以有多个 aciton，只要 Intent 中的 action 能够和任何一个 action 相同即可成功匹配。匹配是指与 action 的字符串完全一样。 Intent 中如果没有指定 action，那么匹配失败。 2. category category 是一个字符串。 Intent 可以没有 category，但是如果你一旦有 category，不管有几个，每个都能够与 intent-filter 中的其中一个 category 相同。 系统在 startActivity 和 startActivityForResult 的时候，会默认为 Intent 加上 android.intent.category.DEFAULT 这个 category，所以为了我们的 activity能够接收隐式调用，就必须在intent-filter 中加上 android.intent.category.DEFAULT 这个 category。 3. data data 的匹配规则与 action一样，如果 intent-filter 中定义了 data，那么 Intent 中必须要定义可匹配的 data。 intent-filter 中 data 的语法： 1234567 &lt;data android:scheme="string"android:host="string"android:port="string"android:path="string"android:pathPattern="string"android:pathPrefix="string"android:mimeType="string"/&gt; Intent中 的 data 有两部分组成： mimeType 和 URI。 mimeType 是指媒体类型，比如 image/jpeg、audio/mpeg4-generic 和 video/* 等，可以表示图片、文本、视频等不同的媒体格式。 URI 的结构： ://:/[||] ```1234```Java//实际例子content://com.example.project:200/folder/subfolder/etchttp://www.baidu.com:80/search/info scheme：URI 的模式，比如 http、 file、 content 等，默认值是 file 。 host：URI 的主机名 port：URI 的端口号 path、 pathPattern 和 pathPrefix：这三个参数描述路径信息。 path、 pathPattern 可以表示完整的路径信息，其中 pathPattern 可以包含通配符 * ，表示0个或者多个任意字符。 pathPrefix 只表示路径的前缀信息。 Intent 指定 data 时，必须调用 setDataAndType 方法， setData 和 setType 会清除另一方的值。 4. 隐式调用需注意 当通过隐式调用启动 Activity 时，没找到对应的 Activity 系统就会抛出 android.content.ActivityNotFoundException 异常，所以需要判断是否有 Activity 能够匹配我们的隐式 Intent。 采用 PackageManager 的 resloveActivity 方法 12public abstract List&lt;ResolveInfo&gt; queryIntentActivityies(Intent intent, int flags);public abstract ResolveInfo resloveActivity(Intent intent, int flags); 以上的第二个参数使用 MATCH_DEFAULT_ONLY ，这个标志位的含义是仅仅匹配那些在 intent-filter 中声明了 android.intent.category.DEFAULT 这个 category 的 Activity。 因为如果把不含这个 category 的 Activity 匹配出来了，由于不含 DEFAULT 这个 category 的 Activity 是无法接受隐式 Intent 的从而导致 startActivity 失败。 采用 Intent 的 resloveActivity 方法 下面的 action 和 category 用来表明这是一个入口 Activity 并且会出现在系统的应用列表中，二者缺一不可。 12&lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt; 参考资料Google官方开发文档-任务和返回栈Google官方开发文档-Intent 和 Intent 过滤器《Android 开发艺术探索》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>LaunchMode</tag>
        <tag>启动模式</tag>
        <tag>IntentFilter</tag>
        <tag>匹配规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Activity 生命周期]]></title>
    <url>%2F2017%2F04%2F30%2Fandroid-life-cycle%2F</url>
    <content type="text"><![CDATA[Android - Activity 生命周期概述作为四大组件中我们使用最频繁的 Activity，它的生命周期大家都了解。 然而面试中经常问到可见它的重要性。下面从两个方面来分析一下 Activity 的生命周期和一些需要注意的细节。 Activity 生命周期图 典型情况下生命周期分析 一般情况下，当当前 Activity 从不可见重新变为可见状态时，onRestart 方法就会被调用。 当用户打开新的 Activity 或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新Activity采用了透明主题，那么 onStop 方法不会被回调。当用户再次回到原来的 Activity 时，回调如下：onRestart -&gt; onStart -&gt; onResume。 onStart 和 onStop 对应，它们是从 Activity 是否可见这个角度来回调的；onPause 和 onResume 方法对应，它们是从 Activity 是否位于前台这个角度来回调的。 从 Activity A 进入到 Activity B ，回调顺序是 onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在 onPause 方法中做重量级的操作。 异常情况下生命周期分析 onSaveInstanceState 方法只会出现在 Activity 被异常终止的情况下，它的调用时机是在 onStop 之前，它和 onPause 方法没有既定的时序关系，可能在它之前，也可能在它之后。 当 Activity 被重新创建的时候，onRestoreInstanceState 会被回调，它的调用时机是 onStart 之后。系统只会在 Activity 即将被销毁并且有机会重新显示的情况下才会去调用 onSaveInstanceState 方法。 当 Activity 在异常情况下需要重新创建时，系统会默认为我们保存当前 Activity 的视图结构，并且在 Activity 重启后为我们恢复这些数据。 比如：文本框中用户输入的数据、 listview 滚动的位置等，这些 view 相关的状态系统都会默认为我们恢复。 具体针对某一个 view 系统能为我们恢复哪些数据可以查看 view 的源码中的 onSaveInstanceState 和 onRestoreInstanceState 方法。 Activity按优先级的分类 前台 Activity &gt; 可见但非前台 Activity &gt; 后台 Activity android:configChanges=”xxx” 属性，常用的主要有下面三个选项： local：设备的本地位置发生了变化，一般指切换了系统语言； keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘； orientation：屏幕方向发生了变化，比如旋转了手机屏幕。 配置了 android:configChanges=”xxx” 属性之后，Activity就不会在对应变化发生时重新创建，而是调用 Activity 的 onConfigurationChanged 方法。 参考资料Google官方开发文档-Activity《Android 开发艺术探索》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>LifeCycle</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 反编译指南]]></title>
    <url>%2F2017%2F04%2F28%2Fdecompile%2F</url>
    <content type="text"><![CDATA[Android - 反编译指南反编译源码1. 使用 dex2jar作用：将 apk 反编译成 java 源码（classes.dex 转化成 jar 文件） dex2jar 下载：https://sourceforge.net/projects/dex2jar 下载最新的 dex2jar 并解压 2. 解压 apk 安装包，将 classes.dex 复制 dex2jar 目录下，执行下面命令1d2j-dex2jar classes.dex Win10 最新 PowerShell 窗口尝试下面命令： 1.\d2j-dex2jar.bat .\classes.dex 3. 得到 classes-dex2jar.jar 使用 jd-gui.exe 打开作用：查看 APK 中 classes.dex 转化成出的 jar 文件，即源码文件 dex2jar 下载：http://jd.benow.ca/ 反编译资源文件1. 使用 apktool作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看 apktool 下载：https://bitbucket.org/iBotPeaches/apktool/downloads/ 下载最新的 apktool 并解压 2. 将 apk 安装包复制到 apktool 目录下，执行命令1java -jar apktool.jar d -f xxx.apk -o res 注意：apktool.bat 与 apktool.jar 文件名为 apktool 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>逆向</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 屏幕适配全攻略]]></title>
    <url>%2F2017%2F04%2F26%2Fmulti-screen-support%2F</url>
    <content type="text"><![CDATA[Android-屏幕适配全攻略一、Android屏幕碎片化由于 Android 系统的开发性，任何用户、开发者、OEM厂商、运营商都可以对 Android 进行定制，修改成他们想要的样子。各大厂商、开发者的标准不统一，所以就造成了 Android 系统碎片化。 但是这种“碎片化”到底到达什么程度呢？ 下面这张图片所显示的内容足以充分说明当今 Android 系统碎片化问题的严重性，因为该图片中的每一个矩形都代表着一种 Android 设备。 而随着支持Android系统的设备(手机、平板、电视、手表)的增多，设备碎片化、品牌碎片化、系统碎片化、传感器碎片化和屏幕碎片化的程度也在不断地加深。而我们今天要探讨的，则是对我们开发影响比较大的——屏幕的碎片化。 下面这张图是Android屏幕尺寸的示意图，在这张图里面，蓝色矩形的大小代表不同尺寸，颜色深浅则代表所占百分比的大小。 而与之相对应的，则是下面这张图。这张图显示了 IOS 设备所需要进行适配的屏幕尺寸和占比。 当然，这张图片只是 4, 4s, 5, 5c, 5s 和平板的尺寸，现在还应该加上新推出的 iphone6 和 plus，但是和 Android 的屏幕碎片化程度相比而言，还是差的太远。 Android屏幕的碎片化如此严重，所以我们不得不进行屏幕的适配，如何面对如此多的屏幕进行适配？下面结合Google官方开发文档讨论下最优的解决方案。 二、术语和概念1. 什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？屏幕尺寸 按屏幕对角测量的实际物理尺寸。单位是英寸(inch)，1英寸 = 2.54厘米。 屏幕分辨率 屏幕上物理像素的总数。单位是 px，1px = 1像素点，一般是纵向像素×横向像素，如1280×720。 每英寸点数 是指每英寸多少点。单位是 dpi，即 “dot per inch” 的缩写，是打印机、鼠标等设备分辨率的单位。 屏幕像素密度 所表示的是每英寸所拥有的像素数量。单位是ppi，即 “Pixel per inch“ 的缩写，每英寸像素点数。针对显示器的设计时，dpi = ppi。 例如：计算Nexus5的屏幕像素密度：屏幕尺寸：4.95 inch、分辨率：1920×1080，屏幕像素密度(ppi)：445 2. 什么是dp、dip、dpi、sp、px？之间的关系是什么？dip/dp 在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。 Density Independent Pixels(密度无关像素)的缩写。以160dpi为基准，1dp = 1px。单位转换： px = dp * (dpi / 160)。 dpi 屏幕像素密度的单位，“dot per inch” 的缩写 px 像素，物理上的绝对单位 sp Scale-Independent Pixels 的缩写，可以根据文字大小首选项自动进行缩放。 Google推荐我们使用 12s p以上的大小，通常可以使用 12sp，14sp，18sp，22sp，最好不要使用奇数和小数。 3. 什么是mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？ 名称 像素密度范围 图片大小 mdpi(中) 120dp~160dp 48×48px hdpi(高) 160dp~240dp 72×72px xhdpi(超高) 240dp~320dp 96×96px xxhdpi(超超高) 320dp~480dp 144×144px xxxhdpi(超超超高) 480dp~640dp 192×192px 在Google官方开发文档中，说明了 mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi = 2：3：4：6：8 的尺寸比例进行缩放。例如，一个图标的大小为 48×48dp，表示在mdpi上，实际大小为 48×48px，在 hdpi 像素密度上，实际尺寸为 mdpi 上的1.5倍，即 72×72px，以此类推。 4. 支持的屏幕范围四种通用尺寸：小、正常、 大 和超大。 六种通用的密度： ldpi（低）~120dpi mdpi（中）~160dpi hdpi（高）~240dpi xhdpi（超高）~320dpi xxhdpi（超超高）~480dpi xxxhdpi（超超超高）~640dpi 屏幕尺寸与屏幕密度对比： 超大屏幕至少为 960dp x 720dp 大屏幕至少为 640dp x 480dp 正常屏幕至少为 470dp x 320dp 小屏幕至少为 426dp x 320dp 三、解决方案 - 支持各种屏幕尺寸1. 使用配置限定符 这里只是展示了常用的一些配置限定符，具体用法和详情请参阅：Google官方开发文档-使用配置限定符 2. 使用NinePatch(.9)图片什么是.9图？ NinePatch 是一种 PNG 图像，在其中可定义当视图中的内容超出正常图像边界时 Android 缩放的可拉伸区域。 后缀以 .9.png 结尾，命名格式为：xxx.9.png。如：普通图：ic_launcher.png .9图 为：ic_launcher.9.png 文件位置： res/drawable/filename.9.png 文件名用作资源 ID。 怎么制作.9图？ 使用 Photoshop（不推荐）使用 Android SDK 自带工具，在 …\Android\SDK\tools\ 下名字为 draw9patch 的文件。使用 Android Studio 同上。 draw9patch如图 ： 拉伸区域 红色框区域：表示纵向拉伸的区域，也就是说，当图片需要纵向拉伸的时候它会只指定拉伸红色区域，其他区域在纵向是不会拉伸的。 绿色框区域：表示横向拉伸的区域，也就是说，当图片需要横向拉伸的时候它会只指定拉伸绿色区域，其他区域在横向是不会拉伸的。 显然红色和绿色相交的部分是既会进行横向拉伸也会进行纵向拉伸的。 前景的显示区域 蓝色区域：表示前景能显示的纵向范围。即前景的最上面可以显示到什么地方，最下面可以显示的什么地方。 黄色区域：表示前景能显示的横向范围。即前景的最左边可以显示到什么地方，最右边可以显示的什么地方。 蓝色和黄色相交部分：表示整个前景能显示的区域。一个区域是矩形的，蓝色规定了上下边界，黄色规定了左右边界，两者共同当然也就规定了一个矩形区域。 3.可绘制的资源文件Drawable 请参考：Google官方开发文档-可绘制对象资源 4. 最佳做法 在 XML 布局文件中指定尺寸时使用 wrap_content、 match_parent 或 dp 单位 。 不要在应用代码中使用硬编码的像素值 。 不要使用 AbsoluteLayout（已弃用） 。 为不同屏幕密度提供替代位图可绘制对象 。 5. 总结 表格里面列出了目前主流的 Android 手机设备分辨率对应的 dpi 缩放级别。一般设计师会以 1920 x 1080 来设计效果图，那么只需要将效果图测量出来的 px值 填入 第6行-px列 中即可自动计算出所需的 dp/sp 的值。通常情况下以 1280 x 720 的效果图来写布局是比较好的方式，因为测量出来的 px值是 dp/sp 的两倍，方便计算。表格下载：Android屏幕适配单位转换.xls 参考资料 https://developer.android.com/guide/practices/screens_support.html?hl=zh-cn#DeclaringTabletLayouts http://blog.jeswang.org/blog/2013/08/07/ppi-vs-dpi-you-shi-yao-qu-bie/ http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023 http://www.cnblogs.com/vanezkw/archive/2012/07/19/2599092.html 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
</search>
