<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android - 系统启动过程]]></title>
    <url>%2F2017%2F09%2F09%2Fandroid-bootloader%2F</url>
    <content type="text"><![CDATA[Android - 系统启动过程计算机是如何启动的？首先熟悉一些概念，计算机的硬件包括：CPU，内存，硬盘，显卡，显示器，键盘鼠标等其他输入输出设备。 所有的软件（比如：操作系统）都是存放在硬盘上，程序执行时需要将程序从硬盘上读取到内存中然后加载到 CPU 中来运行。 当我们按下开机键时，此时内存中什么都没有，因此需要借助某种方式，将操作系统加载到内存中，而完成这项任务的就是 BIOS。 引导阶段 BIOS: Basic Input/Output System（基本输入输出系统），在 IBM PC 兼容系统上，是一种业界标准的固件接口（来自维基百科）。 BIOS 一般是主板芯片上的一个程序，计算机通电后，第一件事就是读取它。 BIOS 程序首先检查计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为 POST。 如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。 如果没有问题，屏幕就会显示出 CPU，内存，硬盘等信息。 硬件自检完成后，BIOS 把控制权转交给下一阶段的启动程序。 这时 BIOS 需要知道，下一阶段的启动程序到底存放在哪一个设备当中。 也就是说 BIOS 需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。 这种排序叫做启动排序，也就是我们平时进入 BIOS 界面时能看到的 Boot Sequence。 如果我们没有进行特殊操作的话，那么 BIOS 就会按照这个启动顺序将控制权交给下一个存储设备。 我们在使用 U 盘光盘之类的装系统时就是在这里将启动顺序改变了，将本来要移交给硬盘的控制权交给了 U 盘或者光盘。 第一存储设备被激活后，计算机读取该设备的第一个扇区，也就是读取最前面的 512 个字节。 如果这 512 个字节的最后两个字节是 0x55 和 0xAA ，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给“启动顺序”中的下一个设备。 这最前面的 512 个字节，就叫做”主引导记录”（Master boot record，缩写为 MBR）。 主引导记录 MBR 是位于磁盘最前边的一段引导代码。它负责磁盘操作系统对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统在对硬盘进行初始化时产生的。 硬盘的主引导记录 MBR 是不属于任何一个操作系统的，它先于所有的操作系统而被调入内存，并发挥作用，然后才将控制权交给主分区内的操作系统，并用主分区信息表来管理硬盘。 MBR 只有512个字节，放不了太多东西。 它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。 我们找到可用的 MBR 后，计算机从 MBR 中读取前面 446 字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。 加载内核阶段 选择完操作系统后，控制权转交给操作系统，操作系统的内核首先被载入内存。 以 Linux 系统为例，先载入 /boot 目录下面的 kernel。 内核加载成功后，第一个运行的程序是 /sbin/init。 它根据配置文件（Debian 系统是 /etc/initab ）产生 init 进程。 这是 Linux 启动后的第一个进程，pid 进程编号为 1，其他进程都是它的后代。 然后，init 线程加载系统的各个模块，比如：窗口程序和网络程序，直至执行 /bin/login 程序，跳出登录界面，等待用户输入用户名和密码。 至此，全部启动过程完成。 Android 手机的启动过程Android 系统虽然也是基于 Linux 系统的，但是由于 Android 属于嵌入式设备，并没有像 PC 那样的 BIOS 程序。 取而代之的是 Bootloader —— 系统启动加载器。 它类似于 BIOS，在系统加载前，用以初始化硬件设备，建立内存空间的映像图，为最终调用系统内核准备好环境。 在 Android 里没有硬盘，而是 ROM，它类似于硬盘存放操作系统，用户程序等。 ROM 跟硬盘一样也会划分为不同的区域，用于放置不同的程序，在 Android 中主要划分为一下几个分区： /boot：存放引导程序，包括内核和内存操作程序 /system：相当于电脑c盘，存放Android系统及系统应用 /recovery：恢复分区，可以进入该分区进行系统恢复 /data：用户数据区，包含了用户的数据：联系人、短信、设置、用户安装的程序 /cache：安卓系统缓存区，保存系统最常访问的数据和应用程序 /misc：包含一些杂项内容，如系统设置和系统功能启用禁用设置 /sdcard：用户自己的存储区，可以存放照片，音乐，视频等文件 那么 Bootloader 是如何被加载的呢？跟 PC 启动过程类似，当开机通电时首先会加载 Bootloader，Bootloader 会读取 ROM 找到操作系统并将 Linux 内核加载到 RAM 中。 当 Linux 内核启动后会初始化各种软硬件环境，加载驱动程序，挂载根文件系统，Linux 内核加载的最后阶段会启动执行第一个用户空间进程 init 进程。 init 进程 init 是 Linux 系统中用户空间的第一个进程(pid=1)，Kernel 启动后会调用 /system/core/init/Init.cpp 的 main() 方法。 Init.main() 首先初始化 Kernel log，创建一块共享的内存空间，加载 /default.prop 文件，解析 init.rc 文件。 init.rc 文件init.rc 文件是 Android 系统的重要配置文件，位于 /system/core/rootdir/ 目录中。 主要功能是定义了系统启动时需要执行的一系列 action 及执行特定动作、设置环境变量和属性和执行特定的 service。 init.rc 脚本文件配置了一些重要的服务，init 进程通过创建子进程启动这些服务，这里创建的 service 都属于 native 服务，运行在 Linux 空间，通过 socket 向上层提供特定的服务，并以守护进程的方式运行在后台。 通过 init.rc 脚本系统启动了以下几个重要的服务： service_manager：启动 binder IPC，管理所有的 Android 系统服务 mountd：设备安装 Daemon，负责设备安装及状态通知 debuggerd：启动 debug system，处理调试进程的请求 rild：启动 radio interface layer daemon 服务，处理电话相关的事件和请求 media_server：启动 AudioFlinger，MediaPlayerService 和 CameraService，负责多媒体播放相关的功能，包括音视频解码 surface_flinger：启动 SurfaceFlinger 负责显示输出 zygote：进程孵化器，启动 Android Java VMRuntime 和启动 systemserver，负责 Android 应用进程的孵化工作 在这个阶段你可以在设备的屏幕上看到 “Android” logo 了。 以上工作执行完，init 进程就会进入 loop 状态。 service_manager 进程ServiceManager 是 Binder IPC 通信过程中的守护进程，本身也是一个 Binder 服务。ServiceManager 进程主要是启动 Binder，提供服务的查询和注册。 具体过程详见 Binder：Android Binder 进程间通讯 surface_flinger 进程SurfaceFlinger 负责图像绘制，是应用 UI 的核心，其功能是合成所有 Surface 并渲染到显示设备。SurfaceFlinger 进程主要是启动 FrameBuffer，初始化显示系统。 media_server 进程MediaServer 进程主要是启动 AudioFlinger 音频服务，CameraService 相机服务。负责处理音频解析播放，相机相关的处理。 Zygote 进程fork 创建进程过程： Zygote 进程孵化了所有的 Android 应用进程，是 Android Framework 的基础，该进程的启动也标志着 Framework 框架初始化启动的开始。 Zygote 服务进程的主要功能： 注册底层功能的 JNI 函数到虚拟机 预加载 Java 类和资源 fork 并启动 system_server 核心进程 作为守护进程监听处理“孵化新进程”的请求 当 Zygote 进程启动后, 便会执行到 frameworks/base/cmds/app_process/App_main.cpp 文件的 main() 方法。 123App_main.main() //设置进程名，并启动 AppRuntime。AndroidRuntime::start() //创建 Java 虚拟机，注册 JNI 方法，调用 ZygoteInit.main() 方法。ZygoteInit.main() //为 Zygote 注册 socket，预加载类和资源，启动 system_server 进程。 然后 Zygote 进程会进入 loop 状态，等待下次 fork 进程。 system_server 进程system_server 进程 由 Zygote 进程 fork 而来。接下来看下 system_server 启动过程。 1234567891011121314151617181920212223242526//首先会调用 ZygoteInit.startSystemServer() 方法ZygoteInit.startSystemServer() //fork 子进程 system_server，进入 system_server 进程。ZygoteInit.handleSystemServerProcess() //设置当前进程名为“system_server”，创建 PathClassLoader 类加载器。RuntimeInit.zygoteInit() //重定向 log 输出，通用的初始化（设置默认异常捕捉方法，时区等），初始化 Zygote -&gt; nativeZygoteInit()。nativeZygoteInit() //方法经过层层调用，会进入 app_main.cpp 中的 onZygoteInit() 方法。app_main::onZygoteInit()// 启动新 Binder 线程。applicationInit() //方法经过层层调用，会抛出异常 ZygoteInit.MethodAndArgsCaller(m, argv), ZygoteInit.main() 会捕捉该异常。ZygoteInit.main() //开启 DDMS 功能，preload() 加载资源，预加载 OpenGL，调用 SystemServer.main() 方法。SystemServer.main() //先初始化 SystemServer 对象，再调用对象的 run() 方法。SystemServer.run() //准备主线程 looper，加载 android_servers.so 库，该库包含的源码在 frameworks/base/services/ 目录下。 system_server 进程启动后将初始化系统上下文（设置主题），创建系统服务管理 SystemServiceManager，然后启动各种系统服务： 12345678910111213141516171819startBootstrapServices(); // 启动引导服务//该方法主要启动服务 ActivityManagerService，PowerManagerService，LightsService，DisplayManagerService，PackageManagerService，UserManagerService。//设置 ActivityManagerService，启动传感器服务。startCoreServices(); // 启动核心服务//该方法主要//启动服务 BatteryService 用于统计电池电量，需要 LightService。//启动服务 UsageStatsService，用于统计应用使用情况。//启动服务 WebViewUpdateService。startOtherServices(); // 启动其他服务//该方法主要启动服务 InputManagerService，WindowManagerService。//等待 ServiceManager，SurfaceFlinger启动完成，然后显示启动界面。//启动服务 StatusBarManagerService，//准备好 window, power, package, display 服务：// - WindowManagerService.systemReady()// - PowerManagerService.systemReady()// - PackageManagerService.systemReady()// - DisplayManagerService.systemReady() 所有的服务启动完成后会注册到 ServiceManager。ActivityManagerService 服务启动完成后，会进入 ActivityManagerService.systemReady()，然后启动 SystemUI，WebViewFactory，Watchdog，最后启动桌面 Launcher App。 最后会进入循环 Looper.loop()。 ActivityManagerService 启动启动桌面 Launcher App 需要等待 ActivityManagerService 启动完成。我们来看下 ActivityManagerService 启动过程。 12345678910111213141516ActivityManagerService(Context) //创建名为“ActivityManager”的前台线程，并获取mHandler。//通过 UiThread 类，创建名为“android.ui”的线程。//创建前台广播和后台广播接收器。//创建目录 /data/system。//创建服务 BatteryStatsService。ActivityManagerService.start() //启动电池统计服务，创建 LocalService，并添加到 LocalServices。ActivityManagerService.startOtherServices() -&gt; installSystemProviders()//安装所有的系统 Provider。ActivityManagerService.systemReady()//恢复最近任务栏的 task。//启动 WebView，SystemUI，开启 Watchdog，启动桌面 Launcher App。//发送系统广播。 启动桌面 Launcher App，首先会通过 Zygote 进程 fork 一个新进程作为 App 进程，然后创建 Application，创建启动 Activity，最后用户才会看到桌面。 完整启动过程 参考资料 计算机是如何启动的？ 按下电源键之后，电脑又默默干了很多事 Android系统启动-概述 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
        <tag>Bootloader</tag>
        <tag>开机过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Binder 进程间通讯]]></title>
    <url>%2F2017%2F08%2F08%2Fandroid-binder%2F</url>
    <content type="text"><![CDATA[Android - Binder 进程间通讯概述最近在学习 Binder 机制，在网上查阅了大量的资料，也看了老罗的 Binder 系列的博客和 Innost 的深入理解 Binder 系列的博客，都是从底层开始讲的，全是 C 代码，虽然之前学过 C 和 C++，然而各种函数之间花式跳转，看的我都怀疑人生。 毫不夸张的讲每看一遍都是新的内容，跟没看过一样。 后来又看到了 Gityuan 的博客看到了一些图解仿佛发现了新大陆。 下面就以图解的方式介绍下 Binder 机制，相信你看这篇文章，一定有所收获。 什么是 Binder？Binder 是 Android 系统中进程间通讯（IPC）的一种方式，也是 Android 系统中最重要的特性之一。 Android 中的四大组件 Activity，Service，Broadcast，ContentProvider，不同的 App 等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 理解 Binder 对于理解整个 Android 系统有着非常重要的作用，如果对 Binder 不了解，就很难对 Android 系统机制有更深入的理解。 1. Binder 架构 Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。 Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。 2. Binder 机制 首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。 有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码： 12//获取WindowManager服务引用WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); 获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。 有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。 怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。 3. Binder 驱动我们先来了解下用户空间与内核空间是怎么交互的。 先了解一些概念 用户空间/内核空间详细解释可以参考 Kernel Space Definition； 简单理解如下： Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 系统调用/内核态/用户态虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？ Kernel space can be accessed by user processes only through the use of system calls. 用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。 内核模块/驱动通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。 在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动; 驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作； 驱动就是操作硬件的接口，为了支持 Binder 通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。 熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。 4. Binder 进程与线程 对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。 Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。 5. ServiceManager 启动了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。 ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。 ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。 ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。 6. ServiceManager 注册服务 注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。 事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。 7. ServiceManager 获取服务 获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。 8. 进行一次完整通讯 我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。 首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。 ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。 总结好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。 努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。 网上资料很多，个人觉得比较好的如下： Bander设计与实现 老罗的 Android进程间通信（IPC）机制Binder简要介绍和学习计划 系列 Innost的 深入理解Binder 系列 Gityuan的 Binder系列 (基于 Android 6.0) Binder学习指南 参考资料 Binder系列 Binder学习指南 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
        <tag>进程间通信</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 多渠道打包最佳实践]]></title>
    <url>%2F2017%2F07%2F07%2Fandroid-flavors%2F</url>
    <content type="text"><![CDATA[Android - Flavors概述该项目演示了在 Android Studio 中使用 gradle 构建渠道包。已更新支持 Android Studio 3.x，Gradle 4.x。 渠道号以友盟 SDK 为例，打包多渠道：GooglePlay，小米，友盟，360，豌豆荚，应用宝。 在 AndroidManifest.xml 中加入渠道区分标识。 123&lt;meta-data android:name="UMENG_CHANNEL" android:value="$&#123;UMENG_CHANNEL_VALUE&#125;" /&gt; 然后在 build.gradle(Module: app) 中加入渠道打包替换对应的 UMENG_CHANNEL_VALUE 代码。 123456789101112131415// 渠道Flavors，配置不同的渠道productFlavors &#123; GooglePlay &#123;&#125; xiaomi &#123;&#125; umeng &#123;&#125; qihu360 &#123;&#125; wandoujia &#123;&#125; yingyongbao &#123;&#125; //其他...&#125;// 批量配置渠道productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]&#125; 自定义 apk 名字我们可以指定不同渠道号生成的 apk 的名字，这样方便打包出来区别哪个 apk 是对应哪个渠道的。 如下命名格式为：渠道名-v版本号-打包时间.apk 123456789101112//打包重命名applicationVariants.all &#123; variant -&gt; if (variant.buildType.name == "release") &#123; variant.outputs.all &#123; output -&gt; def fileName = output.outputFile.name if (fileName.endsWith(".apk")) &#123; def apkName = "$&#123;variant.productFlavors[0].name&#125;-v$&#123;variant.versionName&#125;-$&#123;releaseTime()&#125;.apk"; outputFileName = apkName &#125; &#125; &#125; &#125; 渠道自定义不同的渠道定义不同的 applicationId, versionCode, versionName 123456789101112131415161718192021222324252627282930flavorDimensions "test","test1","test2"//定义渠道productFlavors &#123; main_test &#123; applicationId "com.jeanboy.app.flavors" versionCode rootProject.ext.mainTestVersionCode versionName rootProject.ext.mainTestVersionName //定义manifest中替换值，如：渠道号 resValue("string", "test_app_id", "2017-8-14 12:09:35") //定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), './src/main_test/proguard-rules.pro' dimension "test" &#125; main_test1 &#123; applicationId "com.jeanboy.app.flavorstest1" versionCode rootProject.ext.mainTest1VersionCode versionName rootProject.ext.mainTest1VersionName resValue("string", "test_app_id", "2017-8-14 12:09:35") proguardFiles getDefaultProguardFile('proguard-android.txt'), './src/main_test1/proguard-rules.pro' dimension "test1" &#125; main_test2 &#123; applicationId "com.jeanboy.app.flavorstest2" versionCode rootProject.ext.mainTest2VersionCode versionName rootProject.ext.mainTest2VersionName resValue("string", "test_app_id", "2017-8-14 12:09:35") proguardFiles getDefaultProguardFile('proguard-android.txt'), './src/main_test2/proguard-rules.pro' dimension "test2" &#125;&#125; 不同渠道不同签名文件定义渠道包签名文件 1234567891011121314151617181920signingConfigs &#123; test &#123; storeFile file('../resources/test.jks')//密钥文件位置 storePassword 'test123'//密钥密码 keyAlias 'test'//密钥别名 keyPassword 'test123'//别名密码 &#125; test1 &#123; storeFile file('../resources/test1.jks') storePassword 'test123' keyAlias 'test' keyPassword 'test123' &#125; test2 &#123; storeFile file('../resources/test2.jks') storePassword 'test123' keyAlias 'test' keyPassword 'test123' &#125;&#125; 指定不同渠道使用的签名文件 12345678910111213141516171819202122232425buildTypes &#123; debug &#123; minifyEnabled false shrinkResources false zipAlignEnabled true versionNameSuffix "-debug"//版本命名后缀 buildConfigField "boolean", "LOG_DEBUG", "true" //定义debug时使用的签名文件 signingConfig signingConfigs.test signingConfig signingConfigs.test1 signingConfig signingConfigs.test2 &#125; release &#123; minifyEnabled true//是否开启代码混淆 shrinkResources true//移除无用的资源文件，依赖于minifyEnabled必须一起用 multiDexEnabled true//解决65535 zipAlignEnabled true//对齐zip debuggable false // 是否debug buildConfigField "boolean", "LOG_DEBUG", "false" signingConfig signingConfigs.test signingConfig signingConfigs.test1 signingConfig signingConfigs.test2 &#125;&#125; 不同渠道不同资源文件例如：不同渠道需要不同的应用名 12345678910111213141516171819202122|-app |-src |-main | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors&lt;/string&gt; |-main_test | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors-test&lt;/string&gt; |-main_test1 | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors-test1&lt;/string&gt; |-main_test2 | |-res | |-values | |-strings.xml | |-&lt;string name="app_name"&gt;Android-Flavors-test2&lt;/string&gt; 在 src 下创建与 main 同级的渠道目录，里面可创建与 main 目录下对应的目录或文件，打包时会以增量或覆盖的方式替换。 res 目录下的文件可以同名覆盖，java 或其他代码目录中类名不允许重复。 编译某个渠道包的时候遵循以下4条准则： 所有的源码(src/*/java)会用来共同编译生成一个 Apk，不允许覆盖，会提示 duplicate class found 所有的 Manifests 都将会合并，这样一来就允许渠道包中可以定义不同的组件与权限，具体可参考官方 Manifest Merger 渠道中的资源会以覆盖或增量的形式与 main 合并，优先级为 Build Type &gt; Product Flavor &gt; Main sourceSet 每个 Build Variant 都会生成自己的 R 文件 第三方 SDK例如：test1 渠道中需要使用某个 SDK，而其他渠道不需要使用。1234567891011android &#123; productFlavors &#123; test1 &#123; &#125; &#125;&#125;...dependencies &#123; provided 'com.xxx.sdk:xxx:1.0'//提供 sdk test1Compile 'com.xxx.sdk:xxx:1.0'//指定 test1 渠道编译&#125; 接下来，需要在代码中使用反射技术判断应用程序是否添加了该SDK，从而决定是否要使用 SDK。部分代码如下： 12345678910111213class MyActivity extends Activity &#123; private boolean useSdk; @override public void onCreate(Bundle savedInstanceState) &#123; try &#123; Class.forName("com.xxx.sdk.XXX"); useSdk = true; &#125; catch (ClassNotFoundException ignored) &#123; &#125; &#125;&#125; 项目地址https://github.com/jeanboydev/Android-Flavors 参考资料美团Android自动化之旅—适配渠道包 Gradle App项目的多渠道打包实现 多渠道打包 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flavors</tag>
        <tag>多渠道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.0 升级指南]]></title>
    <url>%2F2017%2F06%2F15%2Fandroid-update-to-sutdio-3%2F</url>
    <content type="text"><![CDATA[Android Studio 3.0 升级指南Gradle 版本升级 Gradle Plugin 升级到 3.0.0 及以上，修改 project/build.gradle 文件： 123456789101112131415161718buildscript &#123; repositories &#123; ... google()//*增加 &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.1'//*修改 ... &#125;&#125;allprojects &#123; repositories &#123; jcenter() google()//*增加 &#125;&#125; Gradle 升级到 4.1 及以上，修改 project/gradle/gradle-wrapper.properties 文件： 123...//*修改distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip 多渠道 Error:All flavors must now belong to a named flavor dimension.The flavor ‘flavor_name’ is not assigned to a flavor dimension. 3.0 后 Gradle 添加了 flavorDimensions 属性，用来控制多个版本的代码和资源，缺失就会报错。在项目 app 下 build.gradle 文件中，添加 flavorDimensions： 1234567891011121314android &#123; ... flavorDimensions "tier","minApi" productFlavors&#123; fees&#123; dimension "tier" ... &#125; minApi23&#123; dimension "minApi" ... &#125; &#125;&#125; 如果不需要多版本控制只需添加：flavorDimensions “code”： 12345678android &#123; ... defaultConfig &#123; ... flavorDimensions "code" &#125; ...&#125; Gradle 自定义 apk 名称 Error:(88, 0) Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=appDebug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. 之前改 Apk 名字的代码类似： 1234567applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def file = output.outputFile def apkName = 'xxx-xxx-xxx-signed.apk' output.outputFile = new File(file.parent, apkName) &#125;&#125; 由于 outputFile 属性变为只读，需要进行如下修改，直接对 outputFileName 属性赋值即可： 123456applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123;//each 改为 each def apkName = 'xxx-xxx-xxx-signed.apk' outputFileName = apkName//output.outputFile 改为 outputFileName &#125;&#125; 依赖关键字变化 compile： 1234567891011dependencies &#123; ... //3.0 之前 compile 'com.android.support:appcompat-v7:26.1.0' compile fileTree(include: ['*.jar'], dir: 'libs') compile files('libs/gson-2.3.1.jar') //3.0 之后 implementation 'com.android.support:appcompat-v7:26.1.0' implementation fileTree(include: ['*.jar'], dir: 'libs') implementation files('libs/gson-2.3.1.jar')&#125; api: 对应之前的 compile 关键字，功能一模一样。会传递依赖，导致 gradle 编译的时候遍历整颗依赖树 implementation: 对应之前的 compile ，与 api 类似，关键区别是不会有依赖传递 compileOnly: 对应之前的 provided，依赖仅用于编译期不会打包进最终的 apk 中 runtimeOnly: 对应之前的 apk，与上面的 compileOnly 相反 关于 implementation 与 api 的区别，主要在依赖是否会传递上。如：A 依赖 B，B 依赖 C，若使用api则 A 可以引用 C，而 implementation 则不能引用。 这里更推荐用 implementation，一是不会间接的暴露引用，清晰知道目前项目的依赖情况；二是可以提高编译时依赖树的查找速度，进而提升编译速度。 Java 8 支持Gradle 带来了新的 Java 8 兼容方案 desugar，启用方式十分简单，只要在 gradle android 层次之下加入如下代码即可： 1234567android &#123; ... compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 停用 desugar，在 gradle.properties 文件中加入以下代码： 1android.enableDesugar=false 官方文档 - 使用 Java 8 语言功能 AAPT2AAPT2 将默认启用，如果遇到离奇的问题，可以尝试禁用，只要在 gradle.properties 中加入： 1android.enableAapt2=false 参考资料 官方文档 - 迁移到 Android Plugin for Gradle 3.0.0 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 环境下载 Android 源码]]></title>
    <url>%2F2017%2F06%2F06%2Fdownload-android-sources-code-for-windows%2F</url>
    <content type="text"><![CDATA[Windows 环境下载 Android 源码前言Android 官网（该方式不适合 Windows 平台）：https://source.android.com/source/downloading.html 可是我就想在 Windows 中使用 Source Insight 看看源代码，当然可以！ 准备环境 安装 git 安装 Python 自备梯子 硬盘剩余容量最好大于 100G 1. 安装 git官网：https://git-scm.com/downloads/ 图形化工具：https://tortoisegit.org/ 什么？不会安装 git，那还看什么源码！自行百度！ 2. 安装 Python官网：https://www.python.org/downloads/ 安装参考：http://jingyan.baidu.com/article/c910274be14d64cd361d2dd8.html 只需要安装好运行环境即可 3. 自备梯子没有梯子？那就使用清华源：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 下载源码1. 打开 Git Bash，用 git 克隆源代码仓库123git clone https://android.googlesource.com/platform/manifest.git//没有梯子使用清华源git clone https://aosp.tuna.tsinghua.edu.cn/platform/manifest.git 这时 D:/android_source_code/ 目录下会出现一个 manifest 目录，进入此目录，里面除了 git 的配置目录外，clone 下来了一个 default.xml 文件。 2. 切换到想要的源码版本分支去这里 https://source.android.com/source/build-numbers.html#source-code-tags-and-builds 找到想要的版本分支，并复制。 1234cd manifest//没有梯子，使用 git branch -a 查看所有分支，找到想要的分支git branch -agit checkout android-6.0.1_r79 //这里以 6.0 最后一个版本下载 3. 使用 Python 执行脚本进行源代码下载将下面的代码复制，创建文件 python_download.py，并保存。 123456789101112131415161718192021222324252627282930313233import xml.dom.minidomimport osfrom subprocess import call # 1. 修改为源码要保存的路径rootdir = "D:/android_source_code/Android_6_0_1" # 2. 设置 git 安装的路径git = "C:/Develop/Git/bin/git.exe"# 3. 修改为第一步中 manifest 中 default.xml 保存的路径dom = xml.dom.minidom.parse("D:/android_source_code/manifest/default.xml")root = dom.documentElement #prefix = git + " clone https://android.googlesource.com/"# 4. 没有梯子使用清华源下载prefix = git + " clone https://aosp.tuna.tsinghua.edu.cn/"suffix = ".git" if not os.path.exists(rootdir): os.mkdir(rootdir) for node in root.getElementsByTagName("project"): os.chdir(rootdir) d = node.getAttribute("path") last = d.rfind("/") if last != -1: d = rootdir + "/" + d[:last] if not os.path.exists(d): os.makedirs(d) os.chdir(d) cmd = prefix + node.getAttribute("name") + suffix call(cmd) 4. 执行 Python 脚本开始下载打开 Python 客户端 打开上一步保存的 python_download.py 脚本文件 点击 Run-&gt;Run Module 来运行脚本，或直接按F5运行。 静静地等待下载完成吧。 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Source Code</tag>
        <tag>Download</tag>
        <tag>源码下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Handler 消息机制]]></title>
    <url>%2F2017%2F05%2F15%2Fandroid-handler%2F</url>
    <content type="text"><![CDATA[Android - Handler 消息机制概述Android 的消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。 Handler 的主要作用是将某个任务切换到 Handler 所在的线程中去执行。 Handler机制Handler工作流程 Looper 每个线程中最多只能有一个 Looper 对象，由 Looper 来管理此线程里的 MessageQueue (消息队列)。 可以通过 Looper.myLooper() 获取当前线程的 Looper 实例，通过 Looper.getMainLooper() 获取主（UI）线程的 Looper 实例。 Lopper 会以无限循环的形式去查找是否有新消息，如果有就处理消息，否则就一直等待着。 Handler 你可以构造 Handler 对象来与 Looper 沟通，通过 push 发送新消息到 MessageQueue 里；或者通过 handleMessage 接收 Looper 从 MessageQueue 取出来消息。 MessageQueue MessageQueue是一个消息队列，内部存储了一组消息，以队列的形式对外提供插入和删除的工作，内部采用单链表的数据结构来存储消息列表。 ActivityThread 我们经常提到的主线程，也叫UI线程，它就是 ActivityThread，主线程启动会默认初始化一个 Looper 并创建 Handler。 一个线程中只有一个 Looper 实例，一个 MessageQueue 实例，可以有多个 Handler 实例。 ThreadLocal 一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获得数据。 对于 Handler 来说，它需要获取当前线程的 Looper ,而 Looper 的作用于就是线程并且不同的线程具有不同的 Looper ，通过 ThreadLocal 可以轻松实现线程中的存取。 ThreadLocal原理：不同线程访问同一个ThreadLoacl的get方法，ThreadLocal的get方法会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找对应的Value值。 源码分析通过上面分析我们知道使用 Handler 之前必须先调用 Looper.prepare(); 进行初始化，我们先看下 Looper 的源码。 1. Looper 工作原理先看一下 Looper 工作流程 Looper 源码最上面的注释里有一个使用示例如下，可以清晰的看出 Looper 的使用方法。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare();//先初始化 Looper mHandler = new Handler() &#123;//创建 Handler public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop();//启用 Looper 的 loop 方法开启消息轮询 &#125;&#125; 接续看一下 Looper 的完整源码，分析下工作过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public final class Looper &#123; static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //每个线程都会有一个ThreadLocal 用来保存 Looper对象（里面包含了主线程和 MessageQueue） private static Looper sMainLooper; // 主线程的 Looper final MessageQueue mQueue;//保存消息队列 final Thread mThread;//保存主线程 public static void prepare() &#123;//为当前线程创建 Looper prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; //一个线程只能有一个 Looper， 否则抛出异常 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//将创建的 Looper 放入 ThreadLocal &#125; //初始化主线程的 Looper public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; //获取主线程的 Looper public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125; &#125; //在当前线程中开启轮询 public static void loop() &#123; final Looper me = myLooper();//从 ThreadLocal 中取出当前线程的 Looper 对象 if (me == null) &#123; //Looper 没有调用 Looper.prepare() 初始化，抛出异常 throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue;//从 Looper 对象中取出消息队列 for (;;) &#123;//死循环 Message msg = queue.next(); // 不断的取出消息 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); //取出消息的 target (也就是 Handler)，执行分发消息的操作 &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked();//消息已经分发，进行回收操作 &#125; &#125; public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();//从 ThreadLocal 中取出当前线程的 Looper 对象 &#125; private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//创建消息队列 mThread = Thread.currentThread();//保存当前线程 &#125; public void quit() &#123; mQueue.quit(false);//直接退出消息循环，不管是否还有消息 &#125; public void quitSafely() &#123; mQueue.quit(true);//执行完所有的消息，退出消息循环 &#125; ...&#125; 2. MessageQueue 工作原理在 Looper 中创建了 MessageQueue，我们接着看下 MessageQueue 是怎么工作的。 MessageQueue 工作流程 MessageQueue的构造方法。 123456MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //构造函数，quitAllowed 用来标识是否允许退出。 //主线程是不允许退出的（不然会退出整个程序），子线程可以退出。 mPtr = nativeInit();&#125; 然后我们再看一下 MessageQueue.enqueueMessage() 的源码，分析下是怎么添加消息的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 如果消息队列里面没有消息，或者消息的执行时间比里面的消息早，就把这条消息设置成第一条消息。 //一般不会出现这种情况，因为系统一定会有很多消息。 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123;//如果消息队列里面有消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123;//找到消息队列里面的最后一条消息 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;//把消息添加到最后 &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 知道了怎么添加消息，我们再看下 MessageQueue.next() 方法是怎么取出消息的，也就是 Looper.loop() 方法中不断取消息的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages;//拿到当前的消息队列 if (msg != null &amp;&amp; msg.target == null) &#123; //处理异步的消息，暂不讨论 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; //取出一条消息，消息队列往后移动一个 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse();//标记为已使用 return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ... &#125;&#125; 我们知道 MessageQueue 是个链表结构，里面保存的是 Message，我们再看下 Message 是什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class Message implements Parcelable &#123; public int what;//消息类型，标识消息的作用 public int arg1;//整型参数1 public int arg2;//整型参数2 public Object obj;//复杂对象参数 public Messenger replyTo; public int sendingUid = -1; /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;//标记消息已使用 /** If set message is asynchronous */ /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;//标记消息是否异步 /** Flags to clear in the copyFrom method */ /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; /*package*/ int flags;//消息当前标记 /*package*/ long when;//消息执行时间 /*package*/ Bundle data; /*package*/ Handler target;//Handler 用于执行 handleMessage(); /*package*/ Runnable callback;//消息是一个Runnable // sometimes we store linked lists of these things /*package*/ Message next;//下一个消息 private static final Object sPoolSync = new Object();//控制并发访问 private static Message sPool;//消息池 private static int sPoolSize = 0;//消息池数量 private static final int MAX_POOL_SIZE = 50;//消息最大数量 ...&#125; 3. Handler 工作原理在 Message 中我们看到了 target 是一个 Handler，我们看下 Handler 是怎么与 Looper 和 MessageQueue 一起搭配工作的。 看一下 Handler 的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class Handler &#123; public interface Callback &#123; public boolean handleMessage(Message msg); &#125; public void handleMessage(Message msg) &#123;&#125; /** * 消息处理 */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123;//如果消息体是 Runnable 就执行 run() handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //如果创建 Handler 时传入了 Callback，就执行 Callback 里面的逻辑 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg);//如果上述两种都没有实现，就执行 handleMessage 的逻辑 &#125; &#125; public Handler() &#123; this(null, false); &#125; public Handler(Callback callback) &#123; this(callback, false); &#125; public Handler(Looper looper) &#123;//可以指定关联哪个线程的 Looper this(looper, null, false); &#125; public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false); &#125; public Handler(boolean async) &#123; this(null, async); &#125; /** * 主线程调用的构造方法，主线程已经调用了 Looper.prepareMainLooper(); * * @hide */ public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//取出主线程的 Looper if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//把 Handler 的 mQueue 指向 Looper 中的 mQueue mCallback = callback; mAsynchronous = async; &#125; /** * 第二种构造方法，专门给子线程中创建 Handler 时使用的 * * @hide */ public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; //发送 Runnable 消息 public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; //一般更新 UI 时发送的消息，延时时间为0 public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; //发送延时消息 public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; //发送指定时间发送的消息 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; //把字节传入 Message 中一起发送 //Looper 中需要使用 Handler 来执行 dispatchMessage 方法 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125;&#125; 4. ActivityThread 创建默认的 Handler上面说过，ActivityThread 主线程默认是有一个 Handler 的，我们来看一下主线程是怎么创建默认的 Handler 的。 我们看一下 ActivityThread 类中的 main 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser();//准备一些相关环境，给我们的组件启动 // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper();//初始化主线程 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//开启消息轮询，不断取出消息 throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 在 Activity 可以直接用 runOnUiThread() 来使用默认的 Handler 发送消息，我们来看下它是怎么实现的。 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123;//非主线程，发送 Runnable 消息 mHandler.post(action); &#125; else &#123;//在主线程中直接执行 run() action.run(); &#125;&#125; 5. HandlerThread 异步消息处理机制 HandlerThread 继承了 Thread，是一种可以使用 Handler 的 Thread； 在 run 方法中通过 looper.prepare() 来开启消息循环，这样就可以在 HandlerThread 中创建Handler了； 外界可以通过一个 Handler 的消息方式来通知 HandlerThread 来执行具体任务；确定不使用之后，可以通过 quit 或 quitSafely 方法来终止线程执行。 先分析一下 HandlerThread 的源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class HandlerThread extends Thread &#123; //线程的优先级 int mPriority; //线程的id int mTid = -1; //一个与Handler关联的Looper对象 Looper mLooper; public HandlerThread(String name) &#123; super(name); //设置优先级为默认线程 mPriority = android.os.Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; //可重写方法，Looper.loop之前在线程中需要处理的其他逻辑在这里实现 protected void onLooperPrepared() &#123; &#125; //HandlerThread线程的run方法 @Override public void run() &#123; //获取当前线程的id mTid = Process.myTid(); //创建Looper对象 //这就是为什么我们要在调用线程的start()方法后才能得到Looper(Looper.myLooper不为Null) Looper.prepare(); //同步代码块，当获得mLooper对象后，唤醒所有线程 synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; //设置线程优先级 Process.setThreadPriority(mPriority); //Looper.loop之前在线程中需要处理的其他逻辑 onLooperPrepared(); //建立了消息循环 Looper.loop(); //一般执行不到这句，除非quit消息队列 mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; //线程死了 return null; &#125; //同步代码块，正好和上面run方法中同步块对应 //只要线程活着并且mLooper为null，则一直等待 // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; //返回线程id return mTid; &#125;&#125; HandlerThread 使用代码示例 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private HandlerThread mHandlerThread = null; private Handler mThreadHandler = null; private Handler mUiHandler = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandlerThread = new HandlerThread("HandlerWorkThread"); //必须在实例化mThreadHandler之前调运start方法，原因上面源码已经分析了 mHandlerThread.start(); //将当前mHandlerThread子线程的Looper传入mThreadHandler，使得 //mThreadHandler的消息队列依赖于子线程（在子线程中执行） mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, "在子线程中处理！id="+Thread.currentThread().getId()); //从子线程往主线程发送消息 mUiHandler.sendEmptyMessage(0); &#125; &#125;; mUiHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, "在UI主线程中处理！id="+Thread.currentThread().getId()); &#125; &#125;; //从主线程往子线程发送消息 mThreadHandler.sendEmptyMessage(1); &#125;&#125; 总结到此 Handler 消息机制的源码已经分析完了，相信你一定明白了 Handler 消息机制。一句话，每个线程可以创建一个 Looper ，每个 Looper 轮询着一个 MessageQueue 不断取出消息，有消息则回调给 Handler，Handler 负责向 MessageQueue 中发送消息和处理回调的消息来完成线程之间的转换。 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - IPC 多进程]]></title>
    <url>%2F2017%2F05%2F08%2Fandroid-ipc%2F</url>
    <content type="text"><![CDATA[Android - IPC 多进程概述IPC 即 Inter-Process Communication，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。 线程是 CPU 调度的最小单元，是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上是指一个程序或者应用。进程与线程是包含与被包含的关系。一个进程可以包含多个线程。最简单的情况下一个进程只有一个线程，即主线程（例如 Android 的 UI 线程）。 任何操作系统都需要有相应的 IPC 机制。在 Android 中，IPC 的使用场景大概有以下： 有些模块由于特殊原因需要运行在单独的进程中。 通过多进程来获取多份内存空间。 当前应用需要向其他应用获取数据。 1. 开启多进程模式给四大组件在Manifest中指定 android:process 属性。这个属性的值就是进程名。1234&lt;service android:name=".service.RemoteService" android:process=":remote"&gt;&lt;/service&gt; tips：使用 adb shell ps 或 adb shell ps|grep 包名 查看当前所存在的进程信息。 2. 多线程模式的运行机制Android 为每个进程都分配了一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，导致不同的虚拟机访问同一个类的对象会产生多份副本。例如不同进程的 Activity 对静态变量的修改，对其他进程不会造成任何影响。所有运行在不同进程的四大组件，只要它们之间需要通过内存在共享数据，都会共享失败。四大组件之间不可能不通过中间层来共享数据。 多进程会带来以下问题： 静态成员和单例模式完全失效。 线程同步锁机制完全失效。这两点都是因为不同进程不在同一个内存空间下，锁的对象也不是同一个对象。 SharedPreferences 的可靠性下降。SharedPreferences 底层是 通过读/写 XML 文件实现的，并发读/写会导致一定几率的数据丢失。 Application 会多次创建。 由于系统创建新的进程的同时分配独立虚拟机，其实这就是启动一个应用的过程。在多进程模式中，不同进程的组件拥有独立的虚拟机、Application以及内存空间。实现跨进程的方式有很多： Intent传递数据。 共享文件和SharedPreferences。 基于Binder的Messenger和AIDL。 Socket。 3. BinderAndroid 中进程间通讯的核心就是 Binder 机制，强烈建议了解一下 Binder 机制。 Android Binder 进程间通讯 4. Android 中的 IPC 方式主要有以下方式： Intent 中附加 extras 来传递消息 共享文件 Binder 方式 四大组件之一的 ContentProvider Socket 1. 使用Bundle四大组件中的三大组件（Activity、Service、Receiver）都支持在 Intent 中传递 Bundle 数据。Bundle 实现了 Parcelable 接口，**当我们在一个进程中启动了另一个进程的 Activity、Service、Receiver，可以再 Bundle 中附加我们需要传输给远程进程的消息并通过 Intent 发送出去。被传输的数据必须能够被序列化。 2. 使用文件共享一些概念： 两个进程通过读写同一个文件来交换数据。还可以通过 ObjectOutputStream / ObjectInputStream 序列化一个对象到文件中，或者在另一个进程从文件中反序列这个对象。 注意：反序列化得到的对象只是内容上和序列化之前的对象一样，本质是两个对象。 文件并发读写会导致读出的对象可能不是最新的，并发写的话那就更严重了。所以文件共享方式适合对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写问题。 SharedPreferences 底层实现采用XML文件来存储键值对。系统对它的读/写有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对它的读/写变得不可靠，面对高并发读/写时 SharedPreferences 有很大几率丢失数据，因此不建议在IPC中使用 SharedPreferences 。 3. 使用 MessengerMessenger 可以在不同进程间传递 Message 对象。是一种轻量级的 IPC 方案，底层实现是 AIDL。 具体使用时，分为服务端和客户端： 服务端：创建一个 Service 来处理客户端请求，同时创建一个 Handler 并通过它来创建一个Messenger，然后再 Service 的 onBind 中返回 Messenger 对象底层的 Binder 即可。 1private final Messenger mMessenger = new Messenger (new xxxHandler()); 客户端：绑定服务端的 Sevice，利用服务端返回的 IBinder 对象来创建一个 Messenger，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个Handler并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。 总而言之，就是客户端和服务端 拿到对方的 Messenger 来发送 Message 。只不过客户端通过 bindService 而服务端通过 message.replyTo 来获得对方的Messenger。 Messenger中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。 4. 使用 AIDL如果有大量的并发请求，使用 Messenger 就不太适合，同时如果需要跨进程调用服务端的方法，Messenger 就无法做到了。这时我们可以使用AIDL。 流程如下： 服务端需要创建 Service来监听客户端请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在AIDL文件中声明，最后在Service中实现这个AIDL接口即可。 客户端首先绑定服务端的 Service，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，接着就可以调用 AIDL 中的方法了。 注意事项： AIDL 支持的数据类型： 基本数据类型、String、CharSequence List：只支持 ArrayList，里面的每个元素必须被AIDL支持 Map：只支持 HashMap，里面的每个元素必须被AIDL支持 Parcelable 所有的AIDL接口本身也可以在AIDL文件中使用 自定义的 Parcelable 对象和 AIDL 对象，不管它们与当前的 AIDL 文件是否位于同一个包，都必须显式 import 进来。 如果 AIDL 文件中使用了自定义的 Parcelable 对象，就必须新建一个和它同名的 AIDL 文件，并在其中声明它为 Parcelable 类型。 12package com.ryg.chapter_2.aidl;parcelable Book; AIDL接口中的参数除了基本类型以外都必须表明方向in/out。AIDL接口文件中只支持方法，不支持声明静态常量。建议把所有和AIDL相关的类和文件放在同一个包中，方便管理。 1void addBook(in Book book); AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接时，管理数据的集合直接采用 CopyOnWriteArrayList 来进行自动线程同步。类似的还有 ConcurrentHashMap 。 因为客户端的 listener 和服务端的 listener 不是同一个对象，所以 RecmoteCallbackList 是系统专门提供用于删除跨进程 listener 的接口，支持管理任意的 AIDL 接口，因为所有 AIDL 接口都继承自 IInterface 接口。 1public class RemoteCallbackList&lt;E extends IInterface&gt; 它内部通过一个Map接口来保存所有的 AIDL 回调，这个Map的key是 IBinder 类型，value是 Callback 类型。当客户端解除注册时，遍历服务端所有listener，找到和客户端 listener 具有相同 Binder 对象的服务端 listenr 并把它删掉。 客户端 RPC 的时候线程会被挂起，由于被调用的方法运行在服务端的 Binder 线程池中，可能很耗时，不能在主线程中去调用服务端的方法。 5. 使用ContentProvider ContentProvider 是四大组件之一，其底层实现和 Messenger 一样是 Binder。ContentProvider 天生就是用来进程间通信，只需要实现一个自定义或者系统预设置的 ContentProvider，通过 ContentResolver 的 query、update、insert 和 delete 方法即可。 创建 ContentProvider，只需继承 ContentProvider 实现 onCreate 、 query 、 update 、 insert 、 getType 六个抽象方法即可。除了 onCreate 由系统回调并运行在主线程，其他五个方法都由外界调用并运行在Binder线程池中。 6. 使用SocketSocket 可以实现计算机网络中的两个进程间的通信，当然也可以在本地实现进程间的通信。服务端 Service 监听本地端口，客户端连接指定的端口，建立连接成功后，拿到 Socket 对象就可以向服务端发送消息或者接受服务端发送的消息。 5. 具体实现参考代码： https://github.com/jeanboydev/Android-AIDLTest 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Activity LaunchMode 启动模式 & IntentFilter 匹配规则]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid-launch-mode-and-intent-filter%2F</url>
    <content type="text"><![CDATA[Android - Activity LaunchMode 启动模式 &amp; IntentFilter 匹配规则概述每个应用都会有多个 Activity，Android 中使用栈来管理 Activity。 Activity 的启动模式目前有四种：standard、singleTop、singleTask、singleIntance。 Activity 启动模式1. standard 标准模式，也就是系统的默认模式。 每次启动都会重新创建一个实例，不管这个 Activity 在栈中是否已经存在。 谁启动了这个 Activity，那么 Activity 就运行在启动它的那个 Activity 所在的栈中。 用 Application 去启动 Activity 时会报错，提示非 Activity 的 Context没有所谓的任务栈。解决办法是为需要启动的 Activity 指定 FLAG_ACTIVITY_NEW_TASK 标志位，这样就会为它创建一个新的任务栈。 2. singleTop 栈顶复用模式，在这种模式下，如果新 Activity 位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时回调 onNewIntent 方法。 如果新 Activity 已经存在但不是位于栈顶，那么新 Activity 仍然会被创建。 3. singleTask &amp; singleIntance singleTask 栈内复用模式，这是一种单实例模式，在这种模式下，只要 Activity 在栈中存在，那么多次启动这个 Activity 都不会重新创建实例，同时也会回调 onNewIntent 方法。 同时会导致在 Activity 之上的栈内 Activity 出栈。 如果 Activity 不存在重新创建。 singleIntance 单实例模式，这是一种加强的 singleTask 模式。 具有 singleTask 模式的所有特性外，同时具有此模式的 Activity 只能单独的位于一个任务栈中。 4. 其他情况假设目前有2个任务栈，前台任务栈的情况为 AB，而后台任务栈的情况为 CD，这里假设 CD 的启动模式为 singleTask。 现在请求启动 D，那么整个后台的任务栈都会被切换到前台，这个时候整个后退列表变成了 ABCD。 当用户按 back 键的时候，列表中的 Activity 会一一出栈。 5. TaskAffinity 属性TaskAffinity 参数标识了一个 Activity 所需要的任务栈的名字。 为字符串，且中间必须包含包名分隔符“.”。默认情况下，所有 Activity 所需的任务栈名字为应用包名。 TashAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用，其他情况下没有意义。 应用 A 启动了应用 B 的某个 Activity 后，如果 Activity 的 allowTaskReparenting 属性为 true 的话，那么当应用 B 被启动后，此 Activity 会直接从应用 A 的任务栈转移到应用 B 的任务栈中。 打个比方就是，应用 A 启动了应用 B 的 ActivityX，然后按 Home 回到桌面，单击应用 B 的图标，这时并不会启动 B 的主 Activity，而是重新显示已经被应用 A 启动的 ActivityX。 这是因为 ActivityX 的 TaskAffinity 值肯定不和应用 A 的任务栈相同（因为包名不同）。 所以当应用 B被启动以后，发现 ActivityX 原本所需的任务栈已经被创建了，所以把 ActivityX 从 A 的任务栈中转移过来了。 6. 设置启动模式 manifest中 设置下的 android:launchMode 属性。 启动 Activity 的 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 。 两种同时存在时，以第二种为准。 第一种方式无法直接为 Activity 添加 FLAG_ACTIVITY_CLEAR_TOP 标识，第二种方式无法指定 singleInstance 模式。 可以通过命令行 adb shell dumpsys activity 命令查看栈中的 Activity 信息。 Activity 的 Flags这些FLAG可以设定启动模式、可以影响Activity的运行状态。 FLAG_ACTIVITY_CLEAR_TOP具有此标记位的 Activity 启动时，同一个任务栈中位于它上面的 Activity 都要出栈，一般和 FLAG_ACTIVITY_NEW_TASK 配合使用。效果和 singleTask 一样。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS如果设置，新的 Activity 不会在最近启动的 Activity 的列表（就是安卓手机里显示最近打开的 Activity 那个系统级的UI）中保存。 IntentFilter 匹配规则启动Activity分为两种： 显示调用明确指定被启动对象的组件信息，包括包名和类名。 隐式调用不需要明确指定组件信息，需要 Intent 能够匹配目标组件中的 IntentFilter 中所设置的过滤信息。 IntentFilter 中的过滤信息有 action、 category、 data。 只有一个 Intent 同时匹配 action类别、 category类别、 data类别才能成功启动目标 Activity。 一个 Activity 可以有多个 intent-filter ，一个 Intent 只要能匹配任何一组 intent-filter 即可成功启动对应的 Activity。 12345678910111213141516171819202122232425&lt;activity android:name="MainActivity"&gt; &lt;!-- This activity is the main entry, should appear in app launcher --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name="ShareActivity"&gt; &lt;!-- This activity handles "SEND" actions with text data --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; &lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&gt; &lt;data android:mimeType="image/*"/&gt; &lt;data android:mimeType="video/*"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开： ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。 CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。 如果 元素未使用 icon 指定图标，则系统将使用 元素中的图标。 这两个元素必须配对使用，Activity 才会显示在应用启动器中。 第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。 尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent 过滤器之一匹配）的另一应用中直接进入 ShareActivity。 1. action action 是一个字符串。 系统预定义了一些，也可自己定义，区分大小写，例如 android.intent.action.SEND。 一个 intent-filter 可以有多个 aciton，只要 Intent 中的 action 能够和任何一个 action 相同即可成功匹配。匹配是指与 action 的字符串完全一样。 Intent 中如果没有指定 action，那么匹配失败。 2. category category 是一个字符串。 Intent 可以没有 category，但是如果你一旦有 category，不管有几个，每个都能够与 intent-filter 中的其中一个 category 相同。 系统在 startActivity 和 startActivityForResult 的时候，会默认为 Intent 加上 android.intent.category.DEFAULT 这个 category，所以为了我们的 activity能够接收隐式调用，就必须在intent-filter 中加上 android.intent.category.DEFAULT 这个 category。 3. data data 的匹配规则与 action一样，如果 intent-filter 中定义了 data，那么 Intent 中必须要定义可匹配的 data。 intent-filter 中 data 的语法： 1234567 &lt;data android:scheme="string"android:host="string"android:port="string"android:path="string"android:pathPattern="string"android:pathPrefix="string"android:mimeType="string"/&gt; Intent中 的 data 有两部分组成： mimeType 和 URI。 mimeType 是指媒体类型，比如 image/jpeg、audio/mpeg4-generic 和 video/* 等，可以表示图片、文本、视频等不同的媒体格式。 URI 的结构： ://:/[||] ```1234```Java//实际例子content://com.example.project:200/folder/subfolder/etchttp://www.baidu.com:80/search/info scheme：URI 的模式，比如 http、 file、 content 等，默认值是 file 。 host：URI 的主机名 port：URI 的端口号 path、 pathPattern 和 pathPrefix：这三个参数描述路径信息。 path、 pathPattern 可以表示完整的路径信息，其中 pathPattern 可以包含通配符 * ，表示0个或者多个任意字符。 pathPrefix 只表示路径的前缀信息。 Intent 指定 data 时，必须调用 setDataAndType 方法， setData 和 setType 会清除另一方的值。 4. 隐式调用需注意 当通过隐式调用启动 Activity 时，没找到对应的 Activity 系统就会抛出 android.content.ActivityNotFoundException 异常，所以需要判断是否有 Activity 能够匹配我们的隐式 Intent。 采用 PackageManager 的 resloveActivity 方法 12public abstract List&lt;ResolveInfo&gt; queryIntentActivityies(Intent intent, int flags);public abstract ResolveInfo resloveActivity(Intent intent, int flags); 以上的第二个参数使用 MATCH_DEFAULT_ONLY ，这个标志位的含义是仅仅匹配那些在 intent-filter 中声明了 android.intent.category.DEFAULT 这个 category 的 Activity。 因为如果把不含这个 category 的 Activity 匹配出来了，由于不含 DEFAULT 这个 category 的 Activity 是无法接受隐式 Intent 的从而导致 startActivity 失败。 采用 Intent 的 resloveActivity 方法 下面的 action 和 category 用来表明这是一个入口 Activity 并且会出现在系统的应用列表中，二者缺一不可。 12&lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt; 参考资料Google官方开发文档-任务和返回栈Google官方开发文档-Intent 和 Intent 过滤器《Android 开发艺术探索》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>LaunchMode</tag>
        <tag>启动模式</tag>
        <tag>IntentFilter</tag>
        <tag>匹配规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Activity 生命周期]]></title>
    <url>%2F2017%2F04%2F30%2Fandroid-life-cycle%2F</url>
    <content type="text"><![CDATA[Android - Activity 生命周期概述作为四大组件中我们使用最频繁的 Activity，它的生命周期大家都了解。 然而面试中经常问到可见它的重要性。下面从两个方面来分析一下 Activity 的生命周期和一些需要注意的细节。 Activity 生命周期图 典型情况下生命周期分析 一般情况下，当当前 Activity 从不可见重新变为可见状态时，onRestart 方法就会被调用。 当用户打开新的 Activity 或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新 Activity 采用了透明主题，那么 onStop 方法不会被回调。当用户再次回到原来的 Activity 时，回调如下：onRestart -&gt; onStart -&gt; onResume。 onStart 和 onStop 对应，它们是从 Activity 是否可见这个角度来回调的；onPause 和 onResume 方法对应，它们是从 Activity 是否位于前台这个角度来回调的。 从 Activity A 进入到 Activity B ，回调顺序是 onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在 onPause 方法中做重量级的操作。 异常情况下生命周期分析 onSaveInstanceState 方法只会出现在 Activity 被异常终止的情况下，它的调用时机是在 onStop 之前，它和 onPause 方法没有既定的时序关系，可能在它之前，也可能在它之后。 当 Activity 被重新创建的时候，onRestoreInstanceState 会被回调，它的调用时机是 onStart 之后。系统只会在 Activity 即将被销毁并且有机会重新显示的情况下才会去调用 onSaveInstanceState 方法。 当 Activity 在异常情况下需要重新创建时，系统会默认为我们保存当前 Activity 的视图结构，并且在 Activity 重启后为我们恢复这些数据。 比如：文本框中用户输入的数据、 listview 滚动的位置等，这些 view 相关的状态系统都会默认为我们恢复。 具体针对某一个 view 系统能为我们恢复哪些数据可以查看 view 的源码中的 onSaveInstanceState 和 onRestoreInstanceState 方法。 Activity按优先级的分类 前台 Activity &gt; 可见但非前台 Activity &gt; 后台 Activity android:configChanges=”xxx” 属性，常用的主要有下面三个选项： local：设备的本地位置发生了变化，一般指切换了系统语言； keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘； orientation：屏幕方向发生了变化，比如旋转了手机屏幕。 配置了 android:configChanges=”xxx” 属性之后，Activity就不会在对应变化发生时重新创建，而是调用 Activity 的 onConfigurationChanged 方法。 参考资料Google官方开发文档-Activity《Android 开发艺术探索》 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>LifeCycle</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 反编译指南]]></title>
    <url>%2F2017%2F04%2F28%2Fdecompile%2F</url>
    <content type="text"><![CDATA[Android - 反编译指南反编译源码1. 使用 dex2jar作用：将 apk 反编译成 java 源码（classes.dex 转化成 jar 文件） dex2jar 下载：https://sourceforge.net/projects/dex2jar 下载最新的 dex2jar 并解压 2. 解压 apk 安装包，将 classes.dex 复制 dex2jar 目录下，执行下面命令1d2j-dex2jar classes.dex Win10 最新 PowerShell 窗口尝试下面命令： 1.\d2j-dex2jar.bat .\classes.dex 3. 得到 classes-dex2jar.jar 使用 jd-gui.exe 打开作用：查看 APK 中 classes.dex 转化成出的 jar 文件，即源码文件 dex2jar 下载：http://jd.benow.ca/ 反编译资源文件1. 使用 apktool作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看 apktool 下载：https://bitbucket.org/iBotPeaches/apktool/downloads/ 下载最新的 apktool 并解压 2. 将 apk 安装包复制到 apktool 目录下，执行命令1java -jar apktool.jar d -f xxx.apk -o res 注意：apktool.bat 与 apktool.jar 文件名为 apktool 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>逆向</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 屏幕适配全攻略]]></title>
    <url>%2F2017%2F04%2F26%2Fmulti-screen-support%2F</url>
    <content type="text"><![CDATA[Android - 屏幕适配全攻略一、Android 屏幕碎片化由于 Android 系统的开发性，任何用户、开发者、OEM厂商、运营商都可以对 Android 进行定制，修改成他们想要的样子。各大厂商、开发者的标准不统一，所以就造成了 Android 系统碎片化。 但是这种“碎片化”到底到达什么程度呢？ 下面这张图片所显示的内容足以充分说明当今 Android 系统碎片化问题的严重性，因为该图片中的每一个矩形都代表着一种 Android 设备。 而随着支持 Android 系统的设备(手机、平板、电视、手表)的增多，设备碎片化、品牌碎片化、系统碎片化、传感器碎片化和屏幕碎片化的程度也在不断地加深。而我们今天要探讨的，则是对我们开发影响比较大的——屏幕的碎片化。 下面这张图是 Android 屏幕尺寸的示意图，在这张图里面，蓝色矩形的大小代表不同尺寸，颜色深浅则代表所占百分比的大小。 而与之相对应的，则是下面这张图。这张图显示了 IOS 设备所需要进行适配的屏幕尺寸和占比。 当然，这张图片只是 4, 4s, 5, 5c, 5s 和平板的尺寸，现在还应该加上新推出的 iphone6 和 plus，但是和 Android 的屏幕碎片化程度相比而言，还是差的太远。 Android屏幕的碎片化如此严重，所以我们不得不进行屏幕的适配，如何面对如此多的屏幕进行适配？下面结合Google官方开发文档讨论下最优的解决方案。 二、术语和概念1. 什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？屏幕尺寸 按屏幕对角测量的实际物理尺寸。单位是英寸(inch)，1英寸 = 2.54厘米。 屏幕分辨率 屏幕上物理像素的总数。单位是 px，1px = 1像素点，一般是纵向像素×横向像素，如1280×720。 每英寸点数 是指每英寸多少点。单位是 dpi，即 “dot per inch” 的缩写，是打印机、鼠标等设备分辨率的单位。 屏幕像素密度 所表示的是每英寸所拥有的像素数量。单位是ppi，即 “Pixel per inch“ 的缩写，每英寸像素点数。针对显示器的设计时，dpi = ppi。 例如：计算Nexus5的屏幕像素密度：屏幕尺寸：4.95 inch、分辨率：1920×1080，屏幕像素密度(ppi)：445 2. 什么是 dp、dip、dpi、sp、px？之间的关系是什么？dip/dp 在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。 Density Independent Pixels(密度无关像素)的缩写。以160dpi为基准，1dp = 1px。单位转换： px = dp * (dpi / 160)。 dpi 屏幕像素密度的单位，“dot per inch” 的缩写 px 像素，物理上的绝对单位 sp Scale-Independent Pixels 的缩写，可以根据文字大小首选项自动进行缩放。 Google 推荐我们使用 12s p以上的大小，通常可以使用 12sp，14sp，18sp，22sp，最好不要使用奇数和小数。 3. 什么是 mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？ 名称 像素密度范围 图片大小 mdpi(中) 120dp~160dp 48×48px hdpi(高) 160dp~240dp 72×72px xhdpi(超高) 240dp~320dp 96×96px xxhdpi(超超高) 320dp~480dp 144×144px xxxhdpi(超超超高) 480dp~640dp 192×192px 在Google官方开发文档中，说明了 mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi = 2：3：4：6：8 的尺寸比例进行缩放。例如，一个图标的大小为 48×48dp，表示在mdpi上，实际大小为 48×48px，在 hdpi 像素密度上，实际尺寸为 mdpi 上的1.5倍，即 72×72px，以此类推。 4. 支持的屏幕范围四种通用尺寸：小、正常、 大 和超大。 六种通用的密度： ldpi（低）~120dpi mdpi（中）~160dpi hdpi（高）~240dpi xhdpi（超高）~320dpi xxhdpi（超超高）~480dpi xxxhdpi（超超超高）~640dpi 屏幕尺寸与屏幕密度对比： 超大屏幕至少为 960dp x 720dp 大屏幕至少为 640dp x 480dp 正常屏幕至少为 470dp x 320dp 小屏幕至少为 426dp x 320dp 三、解决方案 - 支持各种屏幕尺寸1. 使用配置限定符 这里只是展示了常用的一些配置限定符，具体用法和详情请参阅：Google官方开发文档-使用配置限定符 2. 使用 NinePatch(.9) 图片什么是.9图？ NinePatch 是一种 PNG 图像，在其中可定义当视图中的内容超出正常图像边界时 Android 缩放的可拉伸区域。 后缀以 .9.png 结尾，命名格式为：xxx.9.png。如：普通图：ic_launcher.png .9图 为：ic_launcher.9.png 文件位置： res/drawable/filename.9.png 文件名用作资源 ID。 怎么制作.9图？ 使用 Photoshop（不推荐）使用 Android SDK 自带工具，在 …\Android\SDK\tools\ 下名字为 draw9patch 的文件。使用 Android Studio 同上。 draw9patch如图 ： 拉伸区域 红色框区域：表示纵向拉伸的区域，也就是说，当图片需要纵向拉伸的时候它会只指定拉伸红色区域，其他区域在纵向是不会拉伸的。 绿色框区域：表示横向拉伸的区域，也就是说，当图片需要横向拉伸的时候它会只指定拉伸绿色区域，其他区域在横向是不会拉伸的。 显然红色和绿色相交的部分是既会进行横向拉伸也会进行纵向拉伸的。 前景的显示区域 蓝色区域：表示前景能显示的纵向范围。即前景的最上面可以显示到什么地方，最下面可以显示的什么地方。 黄色区域：表示前景能显示的横向范围。即前景的最左边可以显示到什么地方，最右边可以显示的什么地方。 蓝色和黄色相交部分：表示整个前景能显示的区域。一个区域是矩形的，蓝色规定了上下边界，黄色规定了左右边界，两者共同当然也就规定了一个矩形区域。 3.可绘制的资源文件 Drawable 请参考：Google官方开发文档-可绘制对象资源 4. 最佳做法 在 XML 布局文件中指定尺寸时使用 wrap_content、 match_parent 或 dp 单位 。 不要在应用代码中使用硬编码的像素值 。 不要使用 AbsoluteLayout（已弃用） 。 为不同屏幕密度提供替代位图可绘制对象 。 5. 总结 表格里面列出了目前主流的 Android 手机设备分辨率对应的 dpi 缩放级别。一般设计师会以 1920 x 1080 来设计效果图，那么只需要将效果图测量出来的 px值 填入 第6行-px列 中即可自动计算出所需的 dp/sp 的值。通常情况下以 1280 x 720 的效果图来写布局是比较好的方式，因为测量出来的 px值是 dp/sp 的两倍，方便计算。表格下载：Android屏幕适配单位转换.xls 参考资料 https://developer.android.com/guide/practices/screens_support.html?hl=zh-cn#DeclaringTabletLayouts http://blog.jeswang.org/blog/2013/08/07/ppi-vs-dpi-you-shi-yao-qu-bie/ http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023 http://www.cnblogs.com/vanezkw/archive/2012/07/19/2599092.html 扫一扫关注我的公众账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
</search>
