<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="嗨，我是曹建波（@jeanboy），一名来自中国的 Android / iOS / 前端 开发者。现居北京，专注于移动应用开发，热爱分享。">
    

    <!--Author-->
    
        <meta name="author" content="曹建波（@jeanboy）">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="嗨，我是曹建波（@jeanboy），一名来自中国的 Android / iOS / 前端 开发者。现居北京，专注于移动应用开发，热爱分享。" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Jeanboy | 曹建波"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系 - Jeanboy | 曹建波</title>

    <!-- Tachyons Core CSS -->
    <link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Analytics -->
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-121861403-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-121861403-1');
    </script>
    
    
    <!-- Baidu Analytics -->
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?63e553d8293bc74f1160b044738c6107";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
    <!-- google-site-verification -->
    <meta name="google-site-verification" content="R8TtKySmf9yNtEuFKXO0c3YwtVbtTjJU6jWQrzlsxDM" />
    <!-- baidu-site-verification -->
    <meta name="baidu-site-verification" content="T8pesQWGrJ" />

</head>


<body>

<!-- Main Content -->
<!-- Banner -->
<!-- Banner -->
<div class="w-100 bg-1 ph5-ns ph3 text-light">
    
    <nav class="db dt-l w-100 mw8 center border-box pv3">
        <a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="Jeanboy | 曹建波">
            <img src="http://www.codeblocq.com/assets/projects/hexo-theme-anodyne/assets/anodyne.svg" class="dib h3" alt="Jeanboy | 曹建波">
        </a>
        <div class="db dtc-l v-mid w-100 w-75-l tc tr-l">
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/" 
                    title="首页">
                    首页
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/archives" 
                    title="归档">
                    归档
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/tags" 
                    title="标签">
                    标签
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/categories" 
                    title="分类">
                    分类
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/about" 
                    title="关于我">
                    关于我
                </a>
            
        </div>
    </nav>

    <!-- Title -->
    <div class="w-100 mw8 center vh-40 dt">
        <div class="dtc v-mid white">
            <h1 class="f1-l f2-m tc tc-m tl-ns">一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系</h1>
            <p class="f4 fw3 pab-100px tc tc-m tl-ns">2018-03-08</p>
        </div>
    </div>

    <!-- Icon -->
    <div class="relative w-100 mw8 center white dn dn-m db-ns">
        <i class="header-icon fa fa fa-android"></i>
    </div>
</div>

<!-- Content -->
<div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l">
    <div class="content">
        <div class="mw8 center">
            <div class="cf">
                <div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content">
                    <!-- Tags Vertical -->
                    
                        <div class="tags-container-vertical">
                            <div class="tags-sub-container">
                                <a class="fw3 ph1 dib" href="/tags/Android/">#Android</a> <a class="fw3 ph1 dib" href="/tags/源码分析/">#源码分析</a> <a class="fw3 ph1 dib" href="/tags/Surface/">#Surface</a> <a class="fw3 ph1 dib" href="/tags/SurfaceFlinger/">#SurfaceFlinger</a> <a class="fw3 ph1 dib" href="/tags/视图显示原理/">#视图显示原理</a>
                            </div>
                        </div>
                    

                    <!-- Main Post Content -->
                    <h1 id="Android-SurfaceFlinger-图形系统"><a href="#Android-SurfaceFlinger-图形系统" class="headerlink" title="Android - SurfaceFlinger 图形系统"></a>Android - SurfaceFlinger 图形系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-系统启动过程.md" target="_blank" rel="noopener">Android 系统启动过程</a></li>
<li><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Activity启动过程.md" target="_blank" rel="noopener">Activity 创建过程</a></li>
<li><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Activity与Window与View之间的关系.md" target="_blank" rel="noopener">Activity 与 Window 与 View 之间的关系</a></li>
</ul>
<p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_boot_loader/android-bootloader.png?raw=true" alt=""></p>
<p>通过前面的知识我们知道了，Android 系统从按下开机键到桌面，从桌面点击 App 图标到 Activity 显示的过程。但是 Activity 是怎么显示在屏幕上的呢？下面我们就来讨论下这一过程。</p>
<h2 id="SurfaceFlinger-启动过程"><a href="#SurfaceFlinger-启动过程" class="headerlink" title="SurfaceFlinger 启动过程"></a>SurfaceFlinger 启动过程</h2><p>SurfaceFlinger 启动过程：<br><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_surfaceflinger/surfaceflinger_start.png?raw=true" alt=""></p>
<p>SurfaceFlinger 进程是由 init 进程创建的，运行在独立的 SurfaceFlinger 进程中。init 进程读取 init.rc 文件启动 SurfaceFlinger。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">graphics</span> <span class="title">drmrpc</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure>
<p>SurfaceFlinger 的创建会执行 main() 方法：<br>main_surfaceflinger.cpp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化 surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger =  <span class="keyword">new</span> SurfaceFlinger();</span><br><span class="line"></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发布 surface flinger，注册到 ServiceManager</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行在当前线程</span></span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SurfaceFlinger 的实例化会执行到：onFirstRef()<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onFirstRef() &#123;</span><br><span class="line">    mEventQueue.init(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onFirstRef() 中会创建 Handler 并初始化。<br>MessageQueue.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::init(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">true</span>);</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后会执行到 SurfaceFlinger::init()：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 EGL，作为默认的显示</span></span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化硬件 composer 对象</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>, *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 RenderEngine 引擎</span></span><br><span class="line">    mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检索创建的 EGL 上下文</span></span><br><span class="line">    mEGLContext = mRenderEngine-&gt;getEGLContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化非虚拟显示屏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        <span class="comment">//建立已连接的显示设备</span></span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            <span class="keyword">bool</span> isSecure = <span class="literal">true</span>;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token = mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            <span class="comment">//创建 BufferQueue 的生产者和消费者</span></span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    <span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs = <span class="keyword">new</span> FramebufferSurface(*mHwc, i, consumer);</span><br><span class="line">            <span class="keyword">int32_t</span> hwcId = allocateHwcDisplayId(type);</span><br><span class="line">            <span class="comment">//创建显示设备</span></span><br><span class="line">            sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            <span class="keyword">if</span> (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当应用和 sf 的 vsync 偏移量一致时，则只创建一个 EventThread 线程</span></span><br><span class="line">    <span class="keyword">if</span> (vsyncPhaseOffsetNs != sfVsyncPhaseOffsetNs) &#123;</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">        mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">        mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建 DispSyncSource 对象</span></span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf-app"</span>);</span><br><span class="line">        <span class="comment">//创建线程 EventThread</span></span><br><span class="line">        mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);</span><br><span class="line">        <span class="comment">//设置 EventThread</span></span><br><span class="line">        mEventQueue.setEventThread(mEventThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 EventControl</span></span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">"EventControl"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当不存在 HWComposer 时，则设置软件 vsync</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc-&gt;initCheck() != NO_ERROR) &#123;</span><br><span class="line">        mPrimaryDispSync.setPeriod(<span class="number">16666667</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化绘图状态</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化显示设备</span></span><br><span class="line">    initializeDisplays();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动开机动画</span></span><br><span class="line">    startBootAnim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要功能是：</p>
<ol>
<li>初始化 EGL</li>
<li>创建 HWComposer</li>
<li>初始化非虚拟显示屏</li>
<li>启动 EventThread 线程</li>
<li>启动开机动画</li>
</ol>
<p>创建 HWComposer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler):mFlinger(flinger), mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>), mCBContext(<span class="keyword">new</span> cb_context), mEventHandler(handler), mDebugForceFakeVSync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> needVSyncThread = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> fberr = loadFbHalModule(); <span class="comment">//加载 framebuffer 的 HAL 层模块</span></span><br><span class="line">    loadHwcModule(); <span class="comment">//加载 HWComposer 模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记已分配的 display ID</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;</span><br><span class="line">        mAllocatedDisplayIDs.markBit(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            mCBContext-&gt;hwc = <span class="keyword">this</span>;</span><br><span class="line">            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;</span><br><span class="line">            <span class="comment">//VSYNC 信号的回调方法</span></span><br><span class="line">            mCBContext-&gt;procs.vsync = &amp;hook_vsync;</span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));</span><br><span class="line">            <span class="comment">//注册回调函数</span></span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入此处，说明已成功打开硬件 composer 设备，则不再需要 vsync 线程</span></span><br><span class="line">        needVSyncThread = <span class="literal">false</span>;</span><br><span class="line">        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;</span><br><span class="line">        <span class="comment">//不支持硬件的 VSYNC，则会创建线程来模拟定时 VSYNC 信号</span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HWComposer 代表着硬件显示设备，注册了 VSYNC 信号的回调。VSYNC 信号本身是由显示驱动产生的，在不支持硬件的 VSYNC，则会创建“VSyncThread”线程来模拟定时 VSYNC 信号。</p>
<p>当硬件产生VSYNC信号时，则会发送消息，handler 收到消息进行处理。当 SurfaceFlinger 进程收到 VSync 信号后经层层调用，最终调用到该对象的 handleMessageRefresh() 方法。</p>
<p>SurfaceFlinger.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    preComposition();<span class="comment">//处理显示设备与 layers 的改变，更新光标</span></span><br><span class="line">    rebuildLayerStacks();<span class="comment">//重建所有可见 Layer 列表，根据Z轴排序</span></span><br><span class="line">    setUpHWComposer();<span class="comment">//更新 HWComposer 图层</span></span><br><span class="line">    doDebugFlashRegions(); </span><br><span class="line">    doComposition();<span class="comment">//生成 OpenGL 纹理图像</span></span><br><span class="line">    postComposition();<span class="comment">//将图像传递到物理屏幕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Surface-创建过程"><a href="#Surface-创建过程" class="headerlink" title="Surface 创建过程"></a>Surface 创建过程</h2><p>Surface 创建过程：<br><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_surfaceflinger/surface_creat.png?raw=true" alt=""></p>
<p>Surface 创建的过程就是 Activity 显示的过程，在 ActivityThread.handleResumeActivity() 中调用了 Activity.makeVisible()，我们接着看下 Activity 是怎么显示出来的。</p>
<p>Activity.makeVisible：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();<span class="comment">//此处 getWindowManager 获取的是 WindowManagerImpl 对象</span></span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WindowManagerImpl.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WindowManagerGlobal.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">//创建 ViewRootImpl</span></span><br><span class="line">    ViewRootImpl root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    <span class="comment">//设置 View</span></span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 ViewRootImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">ThreadedRenderer</span>.<span class="title">DrawCallbacks</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface(); <span class="comment">//创建 Surface，此时 Surface 创建完什么都没有，详见下面分析</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="comment">//获取 IWindowSession 的代理类</span></span><br><span class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">        mDisplay = display;</span><br><span class="line">        mThread = Thread.currentThread(); <span class="comment">//主线程</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WindowManagerGlobal.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取 IMS 的代理类</span></span><br><span class="line">                InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取 WMS 的代理类</span></span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                <span class="comment">//经过 Binder 调用，最终调用 WMS</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;...&#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WindowManagerService.openSession：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建 Session 对象</span></span><br><span class="line">    Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback, client, inputContext);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次经过 Binder 将数据写回 app 进程，则获取的便是 Session 的代理对象 IWindowSession。</p>
<p>创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。<br>ViewRootImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    requestLayout(); <span class="comment">//详见下面分析</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过 Binder调用，进入 system 进程的 Session</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">          getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">          mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">          mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> <span class="keyword">extends</span> <span class="title">IWindowSession</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用 WMS.addWindow</span></span><br><span class="line">        <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">                outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowManagerService.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">    <span class="comment">//创建 WindowState</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调整 WindowManager 的 LayoutParams 参数</span></span><br><span class="line">    mPolicy.adjustWindowParamsLw(win.mAttrs);</span><br><span class="line">    res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">    addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 设置 input</span></span><br><span class="line">    mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    <span class="comment">//详见下面分析</span></span><br><span class="line">    win.attach();</span><br><span class="line">    mWindowMap.put(client.asBinder(), win);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">//当该窗口能接收按键事件，则更新聚焦窗口</span></span><br><span class="line">        focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WindowState.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 SurfaceSession 对象，并将当前 Session 添加到 WMS.mSessions 成员变量。<br>Session.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SurfaceSession 的创建会调用 JNI，在 JNI 调用 nativeCreate()。<br>android_view_SurfaceSession.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">    client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 SurfaceComposerClient 对象， 作为跟 SurfaceFlinger 通信的代理对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient() &#123;</span><br><span class="line">    <span class="comment">//getComposerService() 将返回 SF 的 Binder 代理端的 BpSurfaceFlinger 对象</span></span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sm(getComposerService());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先调用 SF 的 createConnection()，再调用_init</span></span><br><span class="line">    _init(sm, sm-&gt;createConnection());</span><br><span class="line">    <span class="keyword">if</span>(mClient != <span class="number">0</span>) &#123;</span><br><span class="line">       Mutex::Autolock _l(gLock);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//gActiveConnections 是全局变量，把刚才创建的 client 保存到这个 map 中去</span></span><br><span class="line">       gActiveConnections.add(mClient-&gt;asBinder(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SurfaceFlinger.cpp：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceFlingerClient&gt;SurfaceFlinger::createConnection() &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="keyword">uint32_t</span> token = mTokens.acquire();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先创建一个Client</span></span><br><span class="line">    sp&lt;Client&gt; client = <span class="keyword">new</span> Client(token, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把这个Client对象保存到mClientsMap中，token是它的标识。</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mClientsMap.add(token, client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个用于 Binder 通信的 BClient，BClient 派生于 ISurfaceFlingerClient，</span></span><br><span class="line"><span class="comment">    它的作用是接受客户端的请求，然后把处理提交给 SF，注意，并不是提交给 Client。</span></span><br><span class="line"><span class="comment">    Client 会创建一块共享内存，该内存由 getControlBlockMemory 函数返回。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sp&lt;BClient&gt; bclient = <span class="keyword">new</span> BClient(<span class="keyword">this</span>, token,client-&gt;getControlBlockMemory());</span><br><span class="line">    <span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Client::Client(ClientID clientID, constsp&lt;SurfaceFlinger&gt;&amp; flinger):ctrlblk(<span class="number">0</span>), cid(clientID), mPid(<span class="number">0</span>), mBitmap(<span class="number">0</span>), mFlinger(flinger) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pgsize = getpagesize();</span><br><span class="line">    <span class="comment">//下面这个操作会使 cblksize 为页的大小，目前是4096字节</span></span><br><span class="line">    constint cblksize = ((<span class="keyword">sizeof</span>(SharedClient)+(pgsize<span class="number">-1</span>))&amp;~(pgsize<span class="number">-1</span>));</span><br><span class="line">    mCblkHeap = <span class="keyword">new</span> MemoryHeapBase(cblksize, <span class="number">0</span>, <span class="string">"SurfaceFlinger Clientcontrol-block"</span>);</span><br><span class="line"></span><br><span class="line">    ctrlblk = <span class="keyword">static_cast</span>&lt;SharedClient *&gt;(mCblkHeap-&gt;getBase());</span><br><span class="line">    <span class="keyword">if</span>(ctrlblk) &#123;</span><br><span class="line">       <span class="keyword">new</span>(ctrlblk) SharedClient;<span class="comment">//原来 Surface 的 CB 对象就是在共享内存中创建的这个 SharedClient 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SharedClient：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedClient</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   SharedClient();</span><br><span class="line">   ~SharedClient();</span><br><span class="line">   <span class="keyword">status_t</span> validate(<span class="keyword">size_t</span> token) <span class="keyword">const</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> getIdentity(<span class="keyword">size_t</span> token) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutexlock;</span><br><span class="line">    Condition cv; <span class="comment">//支持跨进程的同步对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//NUM_LAYERS_MAX 为 31，SharedBufferStack 是什么？</span></span><br><span class="line">    SharedBufferStack surfaces[ NUM_LAYERS_MAX ];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SharedClient的构造函数，没什么新意，不如Audio的CB对象复杂</span></span><br><span class="line">SharedClient::SharedClient():lock(Mutex::SHARED), cv(Condition::SHARED) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个 Client 最多支持 31 个显示层。每一个显示层的生产/消费步调都由会对应的 SharedBufferStack 来控制。而它内部就用了几个成员变量来控制读写位置。</p>
<p>SharedBufferStack.h：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SharedBufferStack</span>&#123;</span></span><br><span class="line">     ......</span><br><span class="line">    <span class="comment">//Buffer 是按块使用的，每个 Buffer 都有自己的编号，其实就是数组中的索引号。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> head;     <span class="comment">//FrontBuffer 的编号</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> available; <span class="comment">//空闲 Buffer 的个数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> queued;  <span class="comment">//脏 Buffer 的个数，脏 Buffer 表示有新数据的 Buffer</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> inUse; <span class="comment">//SF 当前正在使用的 Buffer 的编号   </span></span><br><span class="line">    <span class="keyword">volatilestatus_t</span> status; <span class="comment">//状态码</span></span><br><span class="line">     ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>SF 的一个 Client 分配一个跨进程共享的 SharedClient 对象。这个对象有31个 SharedBufferStack 元素，每一个 SharedBufferStack 对应于一个显示层。</p>
<p>一个显示层将创建两个 Buffer，后续的 PageFlipping 就是基于这两个 Buffer 展开的。</p>
<p>接着看 SurfaceComposerClient 中这个_init函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceComposerClient::_init(</span><br><span class="line">       <span class="keyword">const</span> sp&lt;ISurfaceComposer&gt;&amp; sm, constsp&lt;ISurfaceFlingerClient&gt;&amp; conn) &#123;</span><br><span class="line">    mPrebuiltLayerState = <span class="number">0</span>;</span><br><span class="line">    mTransactionOpen = <span class="number">0</span>;</span><br><span class="line">    mStatus = NO_ERROR;</span><br><span class="line">    mControl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mClient = conn;<span class="comment">// mClient 就是 BClient 的客户端</span></span><br><span class="line">    mControlMemory =mClient-&gt;getControlBlock();</span><br><span class="line">    mSignalServer = sm;<span class="comment">// mSignalServer 就是 BpSurfaceFlinger</span></span><br><span class="line">    <span class="comment">//mControl 就是那个创建于共享内存之中的 SharedClient</span></span><br><span class="line">    mControl = <span class="keyword">static_cast</span>&lt;SharedClient*&gt;(mControlMemory-&gt;getBase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。在 setView() 中调用了 requestLayout() 方法我们来看下这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   checkThread();</span><br><span class="line">   mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">   scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mTraversalScheduled) &#123;</span><br><span class="line">       mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">       sendEmptyMessage(DO_TRAVERSAL); <span class="comment">//发送 DO_TRAVERSAL 消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> DO_TRAVERSAL:</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();<span class="comment">//调用 performTraversals()</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalView host = mView;<span class="comment">//还记得这mView吗？它就是 DecorView</span></span><br><span class="line">    booleaninitialized = <span class="keyword">false</span>;</span><br><span class="line">    booleancontentInsetsChanged = <span class="keyword">false</span>;</span><br><span class="line">    booleanvisibleInsetsChanged;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        relayoutResult= <span class="comment">// 1. 关键函数relayoutWindow</span></span><br><span class="line">        relayoutWindow(params, viewVisibility,insetsPending);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    draw(fullRedrawNeeded);<span class="comment">// 2. 开始绘制</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility, <span class="keyword">boolean</span> insetsPending)</span><span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">       <span class="comment">//原来是调用 IWindowSession 的 relayout()，暂且记住这个调用</span></span><br><span class="line">       <span class="keyword">int</span> relayoutResult = sWindowSession.relayout(mWindow, params, (<span class="keyword">int</span>) (mView.mMeasuredWidth * appScale + <span class="number">0.5f</span>),  (<span class="keyword">int</span>) (mView.mMeasuredHeight * appScale + <span class="number">0.5f</span>), viewVisibility, insetsPending, mWinFrame, mPendingContentInsets, mPendingVisibleInsets, mPendingConfiguration, mSurface); <span class="comment">//mSurface 做为参数传进去了。</span></span><br><span class="line">       &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;<span class="comment">//mSurface 是 ViewRoot 的成员变量</span></span><br><span class="line">    ......</span><br><span class="line">    Canvascanvas;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">       <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">       <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">       <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//从 mSurface 中 lock 一块 Canvas</span></span><br><span class="line">       canvas = surface.lockCanvas(dirty);</span><br><span class="line">       ......</span><br><span class="line">       mView.draw(canvas);<span class="comment">//调用 DecorView 的 draw 函数，canvas 就是画布</span></span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">//unlock 画布，屏幕上马上就能看到 View 的样子了</span></span><br><span class="line">       surface.unlockCanvasAndPost(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ViewRoot 构造时，会创建一个 Surface，它使用无参构造函数，代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure></p>
<p>此时创建完的 Surface 是空的，什么都没有。接着继续分析 relayoutWindow()，在 relayoutWindow() 中会调用 IWindowSession 的 relayout()，这是一个跨进程方法会调用到 WMS 中的 Session.relayout()，最后调用到 WindowManagerService.relayoutWindow()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session,IWindow client,</span></span></span><br><span class="line"><span class="function"><span class="params">           WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">boolean</span> insetsPending,</span></span></span><br><span class="line"><span class="function"><span class="params">           Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration outConfig, SurfaceoutSurface)</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//win 就是 WinState，这里将创建一个本地的 Surface 对象</span></span><br><span class="line">        Surfacesurface = win.createSurfaceLocked();</span><br><span class="line">        <span class="keyword">if</span>(surface != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先创建一个本地 surface，然后在 outSurface 的对象上调用 copyFrom</span></span><br><span class="line">            <span class="comment">//将本地 Surface 的信息拷贝到 outSurface 中，为什么要这么麻烦呢？</span></span><br><span class="line">            outSurface.copyFrom(surface);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WindowManagerService.java::WindowState：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Surface <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//mSurfaceSession 就是在 Session 上创建的 SurfaceSession 对象</span></span><br><span class="line">        <span class="comment">//这里，以它为参数，构造一个新的 Surface 对象</span></span><br><span class="line">        mSurface = <span class="keyword">new</span> Surface(mSession.mSurfaceSession, mSession.mPid, mAttrs.getTitle().toString(), <span class="number">0</span>, w, h, mAttrs.format, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    Surface.openTransaction();<span class="comment">//打开一个事务处理</span></span><br><span class="line">    ......</span><br><span class="line">    Surface.closeTransaction();<span class="comment">//关闭一个事务处理</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造 Surface 对象：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">(SurfaceSession s,<span class="comment">//传入一个SurfaceSession对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> pid, String name, <span class="keyword">int</span> display, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span> throws OutOfResourcesException </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">       mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line">       <span class="comment">//又一个 native 函数</span></span><br><span class="line">       init(s,pid,name,display,w,h,format,flags);</span><br><span class="line">       mName = name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Surface_init</span><span class="params">(JNIEnv*env, jobject clazz, jobject session, jint pid, jstring jname, jint dpy, jint w, jint h, jint format, jintflags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 SurfaceSession 对象中取出之前创建的那个 SurfaceComposerClient 对象</span></span><br><span class="line">    SurfaceComposerClient* client = (SurfaceComposerClient*)env-&gt;GetIntField(session, sso.client);</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;<span class="comment">//注意它的类型是 SurfaceControl</span></span><br><span class="line">    <span class="keyword">if</span> (jname == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用 SurfaceComposerClient 的 createSurface 函数，返回的 surface 是一个 SurfaceControl 类型</span></span><br><span class="line">        surface = client-&gt;createSurface(pid, dpy, w, h, format, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//把这个 surfaceControl 对象设置到 Java 层的 Surface 对象中</span></span><br><span class="line">   setSurfaceControl(env, clazz, surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 createSurface 内部会使用 Binder 通信将请求发给 SurfaceFlinger：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurface&gt;SurfaceFlinger::createSurface(ClientID clientId, <span class="keyword">int</span> pid, <span class="keyword">const</span> String8&amp; name, ISurfaceFlingerClient::<span class="keyword">surface_data_t</span>* params, DisplayID d, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;LayerBaseClient&gt; layer;<span class="comment">//LayerBaseClient 是 Layer 家族的基类</span></span><br><span class="line">    <span class="comment">//这里又冒出一个 LayerBaseClient 的内部类，它也叫Surface</span></span><br><span class="line">    sp&lt;LayerBaseClient::Surface&gt; surfaceHandle;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 clientId 找到 createConnection 时加入的那个 Client 对象</span></span><br><span class="line">    sp&lt;Client&gt; client = mClientsMap.valueFor(clientId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//注意这个 id，它的值表示 Client 创建的是第几个显示层</span></span><br><span class="line">    <span class="comment">//同时也表示将使用 SharedBufferStatck 数组的第 id 个元素</span></span><br><span class="line">    <span class="keyword">int32_t</span> id = client-&gt;generateId(pid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个 Client 不能创建多于 NUM_LAYERS_MAX 个的Layer</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">uint32_t</span>(id) &gt;= NUM_LAYERS_MAX) &#123;</span><br><span class="line">       <span class="keyword">return</span> surfaceHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 flags 参数来创建不同类型的显示层</span></span><br><span class="line">    <span class="keyword">switch</span>(flags &amp; eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> eFXSurfaceNormal:</span><br><span class="line">           <span class="keyword">if</span> (UNLIKELY(flags &amp; ePushBuffers)) &#123;</span><br><span class="line">             <span class="comment">//创建 PushBuffer 类型的显示层</span></span><br><span class="line">            layer = createPushBuffersSurfaceLocked(client, d, id, w, h, flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//创建 Normal 类型的显示层</span></span><br><span class="line">               layer = createNormalSurfaceLocked(client, d, id, w, h, flags, format);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> eFXSurfaceBlur:</span><br><span class="line">            <span class="comment">//创建 Blur 类型的显示层</span></span><br><span class="line">           layer = createBlurSurfaceLocked(client, d, id, w, h, flags);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> eFXSurfaceDim:</span><br><span class="line">            <span class="comment">//创建 Dim 类型的显示层</span></span><br><span class="line">           layer = createDimSurfaceLocked(client, d, id, w, h, flags);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(layer != <span class="number">0</span>) &#123;</span><br><span class="line">        layer-&gt;setName(name);</span><br><span class="line">        setTransactionFlags(eTransactionNeeded);</span><br><span class="line">        <span class="comment">//从显示层对象中取出一个 ISurface 对象赋值给 SurfaceHandle</span></span><br><span class="line">        surfaceHandle = layer-&gt;getSurface();</span><br><span class="line">        <span class="keyword">if</span>(surfaceHandle != <span class="number">0</span>) &#123;</span><br><span class="line">           params-&gt;token = surfaceHandle-&gt;getToken();</span><br><span class="line">           params-&gt;identity = surfaceHandle-&gt;getIdentity();</span><br><span class="line">           params-&gt;width = w;</span><br><span class="line">           params-&gt;height = h;</span><br><span class="line">           params-&gt;format = format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> surfaceHandle;<span class="comment">//ISurface 的 Bn 端就是这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;LayerBaseClient&gt;SurfaceFlinger::createNormalSurfaceLocked(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client, DisplayID display, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(format) &#123; <span class="comment">//一些图像方面的参数设置，可以不去管它</span></span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">       format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">       format = PIXEL_FORMAT_RGB_565;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个 Layer 类型的对象</span></span><br><span class="line">    sp&lt;Layer&gt; layer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, display,client, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 Buffer</span></span><br><span class="line">    <span class="keyword">status_t</span> err = layer-&gt;setBuffers(w, h, format, flags);</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(err == NO_ERROR)) &#123;</span><br><span class="line">        <span class="comment">//初始化这个新 layer 的一些状态</span></span><br><span class="line">        layer-&gt;initStates(w, h, flags);</span><br><span class="line">        <span class="comment">//下面这个函数把这个 layer 加入到 Z 轴集合中</span></span><br><span class="line">        addLayer_l(layer);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createNormalSurfaceLocked 函数有三个关键点，它们是：</p>
<ul>
<li>构造一个Layer对象。</li>
<li>调用Layer对象的setBuffers函数。</li>
<li>调用SF的addLayer_l函数。</li>
</ul>
<p>当跨进程的 createSurface() 执行完返回一个 ISurface 对象，接下来会创建 SurfaceControl 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl::SurfaceControl(</span><br><span class="line">       <span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">       <span class="keyword">const</span> sp&lt;ISurface&gt;&amp; surface,</span><br><span class="line">       <span class="keyword">const</span> ISurfaceFlingerClient::surface_data_t&amp; data,</span><br><span class="line">       uint32_t w, uint32_t h, PixelFormat format, uint32_t flags)</span><br><span class="line">    <span class="comment">//mClient 为 SurfaceComposerClient，而 mSurface 指向跨进程 createSurface() 调用返回的 ISurface 对象</span></span><br><span class="line">    :mClient(client), mSurface(surface),</span><br><span class="line">     mToken(data.token), mIdentity(data.identity),</span><br><span class="line">     mWidth(data.width), mHeight(data.height), mFormat(data.format),</span><br><span class="line">     mFlags(flags)&#123;</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SurfaceControl 类可以看作是一个 wrapper 类，它封装了一些函数，通过这些函数可以方便地调用 mClient 或 ISurface 提供的函数。</p>
<p>最后会执行 copyFrom() 返回给 App 客户端：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Surface_copyFrom</span><span class="params">(JNIEnv* env,jobject clazz, jobject other)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据JNI函数的规则，clazz 是 copyFrom 的调用对象，而 other 是 copyFrom 的参数。</span></span><br><span class="line">    <span class="comment">//目标对象此时还没有设置 SurfaceControl，而源对象在前面已经创建了 SurfaceControl</span></span><br><span class="line">    constsp&lt;SurfaceControl&gt;&amp; surface = getSurfaceControl(env, clazz);</span><br><span class="line">    constsp&lt;SurfaceControl&gt;&amp; rhs = getSurfaceControl(env, other);</span><br><span class="line">    <span class="keyword">if</span> (!SurfaceControl::isSameSurface(surface, rhs)) &#123;</span><br><span class="line">        <span class="comment">//把源 SurfaceControl 对象设置到目标 Surface 中</span></span><br><span class="line">        setSurfaceControl(env, clazz, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>copyFrom 期间一共有三个关键对象，它们分别是：</p>
<ul>
<li>SurfaceComposerClient</li>
<li>SurfaceControl</li>
<li>Surface，这个 Surface 对象属于 Native 层，和 Java 层的 Surface 相对应</li>
</ul>
<p>其中转移到 ViewRoot 成员变量 mSurface 中的，就是最后这个 Surface 对象了。</p>
<p>在 SurfaceFlinger 进程中，Client 的一个 Layer 将使用 SharedBufferStack 数组中的一个成员，并通过 SharedBufferServer 结构来控制这个成员，我们知道 SurfaceFlinger 是消费者，所以可由 SharedBufferServer 来控制数据的读取。</p>
<p>与之相对应，客户端的进程也会有一个对象来使用这个 SharedBufferStack，可它是通过另外一个叫 SharedBufferClient 的结构来控制的。客户端为 SurfaceFlinger 提供数据，所以可由 SharedBufferClient 控制数据的写入。</p>
<h2 id="Surface-显示过程"><a href="#Surface-显示过程" class="headerlink" title="Surface 显示过程"></a>Surface 显示过程</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/android_surfaceflinger/surface_display.png?raw=true" alt=""></p>
<p>如图所示，在 App 进程中创建 PhoneWindow 后会创建 ViewRoot。ViewRoot 的创建会创建一个 Surface，这个 Surface 其实是空的，通过与 WindowManagerService 通信 copyFrom() 一个 NativeSurface。在与 SurfaceFlinger 通信时，会创建 SharedClient 一段共享内存，里面存放的是 SharedBufferStack 对应 SurfaceFlinger 中的 SurfaceLayer 每个 Layer 其实是一个 FrameBuffer，每个 FrameBuffer 中有两个 GraphicBuffer 记作 FrontBuffer 和 BackBuffer。</p>
<p>在 SurfaceFlinger 中 SharedBufferServer 来管理 FrameBuffer。同时在 App 端 copyFrom() 出来 NativeSurface 时会创建一个 SharedBufferClient 与 SharedClient 这块共享内存关联。当客户端 addView() 或者需要更新 View 时，会通过 SharedBufferClient 写入数据到 ShareClient 中，SurfaceFlinger 中的 SharedBufferServer 接收到通知会将 FrameBuffer 中的数据传输到屏幕上。</p>
<p>HWComposer 是基于硬件来产生 VSync 信号的，来通知 SurfaceFlinger 重绘控制显示的帧率。</p>
<p>以上理解属于个人观点，能力有限，若有错误欢迎指出，欢迎交流学习，共同进步。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/innost/article/details/47208337" target="_blank" rel="noopener">深入理解Surface系统</a></li>
<li><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">Android图形系统</a></li>
<li><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">SurfaceFlinger启动篇</a></li>
<li><a href="http://gityuan.com/2017/02/18/surface_flinger_2/" target="_blank" rel="noopener">SurfaceFlinger绘图篇</a></li>
<li>《深入理解 Android 内核设计思想》</li>
</ul>
<h2 id="扫一扫关注我的公众账号"><a href="#扫一扫关注我的公众账号" class="headerlink" title="扫一扫关注我的公众账号"></a>扫一扫关注我的公众账号</h2><p><img src="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/resources/images/wechat/qrcode_for_gh_26eef6f9e7c1_258.jpg?raw=true" width="256" height="256"></p>

                    
                    <!-- Tags Bottom -->
                    
                        <div class="tags-container-bottom">
                            <i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/Android/">#Android</a> <a class="fw3 ph1 dib" href="/tags/源码分析/">#源码分析</a> <a class="fw3 ph1 dib" href="/tags/Surface/">#Surface</a> <a class="fw3 ph1 dib" href="/tags/SurfaceFlinger/">#SurfaceFlinger</a> <a class="fw3 ph1 dib" href="/tags/视图显示原理/">#视图显示原理</a>
                        </div>
                    

                    <!-- Comments -->
                    



                </div>
                <div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50">
                    
                    <hr class="dn-l mw4 black-50 mt5" />
                    
                    <!-- Widget 1: About -->
                    <div class="mt5 mt0-l">
    <article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3">
        <div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width: 6rem;">
            <img src="https://avatars2.githubusercontent.com/u/5093954?s=460&v=4" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="曹建波（@jeanboy）">
        </div>
        <div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">
            嗨，我是曹建波（@jeanboy），一名来自中国的 Android / iOS / 前端 开发者。<br/><br/>现居北京，专注于移动应用开发，热爱开源，热爱分享。
        </div>
    </article>
</div>

                    <hr class="dn-l mw4 black-50 mt5" />
                    
                    <!-- Widget 2: Categories -->
                    
                        <div class="mt5 tc tl-l">
    <h3>分类</h3>
    
        <p>
            <a href="/categories/Android/">Android</a>
        </p>
    
</div>


                        <hr class="dn-l mw4 black-50 mt5" />
                    

                    <!-- Widget 3: Recent Posts -->
                    <div class="mt5 tc tl-l">
    <h3>近期文章</h3>
    
        <p>
            <a href="/2018/07/06/jvm-memory/">Java 虚拟机内存分配机制</a>
        </p>
    
        <p>
            <a href="/2018/06/16/jvm-gc/">Java 虚拟机垃圾回收机制</a>
        </p>
    
        <p>
            <a href="/2018/05/22/internet-http-https/">一篇文章看明白 HTTP，HTTPS，SSL/TSL 之间的关系</a>
        </p>
    
        <p>
            <a href="/2018/05/05/internet-tcp-ip/">一篇文章看明白 TCP/IP，TCP，UDP，IP，Socket 之间的关系</a>
        </p>
    
        <p>
            <a href="/2018/04/21/android-service-start/">一篇文章看明白 Android Service 启动过程</a>
        </p>
    
</div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Footer -->
<div class="bg-1 ph2 ph5-ns pv5 bg-2">
    <div class="mv8">
        <div class="center tc">
            
                <div class="dib mh3">
                    <a class="f3 f2-ns white dim" href="https://github.com/jeanboydev" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </div>
                
                <div class="dib mh3">
                    <a class="f3 f2-ns white dim" href="mailto:jeanboy@foxmail.com" target="_blank">
                        <i class="fa fa-envelope"></i>
                    </a>
                </div>
                
        </div>
        <div class="f6 f5-ns center tc white pt5 fw3">
            ©2018 Jeanboy All Rights Reserved | Design & Hexo
        </div>
    </div>
</div>

<!-- After Footer -->
<!-- Disqus Comments -->



</body>

</html>